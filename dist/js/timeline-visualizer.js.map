{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/index.js","dist/lib/timelineVisualizer.js","node_modules/browserify/lib/_empty.js","node_modules/events/events.js","node_modules/lodash.isequal/index.js","node_modules/superfly-timeline/dist/api/expression.js","node_modules/superfly-timeline/dist/api/index.js","node_modules/superfly-timeline/dist/api/resolvedTimeline.js","node_modules/superfly-timeline/dist/api/resolver.js","node_modules/superfly-timeline/dist/api/state.js","node_modules/superfly-timeline/dist/api/timeline.js","node_modules/superfly-timeline/dist/api/types.js","node_modules/superfly-timeline/dist/index.js","node_modules/superfly-timeline/dist/resolver/CacheHandler.js","node_modules/superfly-timeline/dist/resolver/ExpressionHandler.js","node_modules/superfly-timeline/dist/resolver/InstanceHandler.js","node_modules/superfly-timeline/dist/resolver/LayerStateHandler.js","node_modules/superfly-timeline/dist/resolver/ReferenceHandler.js","node_modules/superfly-timeline/dist/resolver/ResolvedTimelineHandler.js","node_modules/superfly-timeline/dist/resolver/ResolverHandler.js","node_modules/superfly-timeline/dist/resolver/StateHandler.js","node_modules/superfly-timeline/dist/resolver/TimelineValidator.js","node_modules/superfly-timeline/dist/resolver/lib/cache.js","node_modules/superfly-timeline/dist/resolver/lib/cap.js","node_modules/superfly-timeline/dist/resolver/lib/event.js","node_modules/superfly-timeline/dist/resolver/lib/expression.js","node_modules/superfly-timeline/dist/resolver/lib/instance.js","node_modules/superfly-timeline/dist/resolver/lib/lib.js","node_modules/superfly-timeline/dist/resolver/lib/performance.js","node_modules/superfly-timeline/dist/resolver/lib/reference.js","node_modules/superfly-timeline/dist/resolver/lib/timeline.js","node_modules/superfly-timeline/node_modules/tslib/tslib.js","node_modules/tslib/tslib.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACphCA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxzDA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACn6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACraA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"timeline-visualizer.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./lib/timelineVisualizer\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TimelineVisualizer = void 0;\nconst isEqual = require(\"lodash.isequal\");\nconst superfly_timeline_1 = require(\"superfly-timeline\");\nconst events_1 = require(\"events\");\n/** Step size/ time step. */\nconst DEFAULT_STEP_SIZE = 1;\n/** Width of label column. */\nconst LABEL_WIDTH_OF_TIMELINE = 0.25;\n/** Default zoom */\nconst DEFAULT_ZOOM_VALUE = 100;\n/** Factor to zoom by */\nconst ZOOM_FACTOR = 1.001;\n/** Factor to pan by (pan = PAN_FACTOR * STEP_SIZE) */\nconst PAN_FACTOR = 10;\n/** Maximum layer height */\nconst MAX_LAYER_HEIGHT = 60;\n/** Amount to move playhead per second. */\nconst DEFAULT_PLAYHEAD_SPEED = 1;\n/** BEGIN STYLING VALUES */\n/** Timeline background color. */\nconst COLOR_BACKGROUND = '#333333';\n/** Layer label background color. */\nconst COLOR_LABEL_BACKGROUND = '#666666';\n/** Color of the ruler lines */\nconst RULER_LINE_COLOR = '#999999';\n/** Width of the ruler lines */\nconst RULER_LINE_WIDTH = 1;\n/** Playhead color. */\nconst COLOR_PLAYHEAD = 'rgba(255, 0, 0, 0.5)';\n/** Playhead thickness. */\nconst THICKNESS_PLAYHEAD = 5;\n/** Color of line separating timeline rows. */\nconst COLOR_LINE = 'black';\n/** Height of line separating rows. */\nconst THICKNESS_LINE = 1;\n/** Text properties. */\nconst TEXT_FONT_FAMILY = 'Calibri';\nconst TEXT_FONT_SIZE = 16;\nconst TEXT_COLOR = 'white';\n/** Timeline object properties. */\nconst COLOR_TIMELINE_OBJECT_FILL = 'rgb(22, 102, 247, 0.75)';\nconst COLOR_TIMELINE_OBJECT_BORDER = 'rgba(232, 240, 255, 0.85)';\nconst THICKNESS_TIMELINE_OBJECT_BORDER = 1;\n/** Timeline object height as a proportion of the row height. */\nconst TIMELINE_OBJECT_HEIGHT = 1;\n/** END STYLING VALUES */\n/** BEGIN CONSTANTS FOR STATE MANAGEMENT */\nconst MOUSEIN = 0;\nconst MOUSEOUT = 1;\nclass TimelineVisualizer extends events_1.EventEmitter {\n    /**\n     * @param {string} canvasId The ID of the canvas object to draw within.\n     */\n    constructor(canvasId, options = {}) {\n        super();\n        // Step size.\n        this.stepSize = DEFAULT_STEP_SIZE;\n        /** @private @readonly Proportion of the canvas to be used for the layer labels column. */\n        this._layerLabelWidthProportionOfCanvas = LABEL_WIDTH_OF_TIMELINE;\n        /** Layers on timeline. */\n        this._layerLabels = {};\n        /** State of the timeline. */\n        this._timelineState = {};\n        /** Map of objects for determining hovered object */\n        this._hoveredObjectMap = {};\n        /** Start time of the current view. Defines the objects within view on the timeline [time] */\n        this._viewStartTime = 0;\n        /** Range of the current view [time] */\n        // private _viewTimeRange: number = 1\n        // private _drawTimeEnd: number\n        /** Store whether the mouse is held down, for scrolling. */\n        this._mouseDown = false;\n        /** Current zoom amount. */\n        this._timelineZoom = DEFAULT_ZOOM_VALUE;\n        /** Whether or not the playhead should move. */\n        this._playHeadPlaying = false;\n        /** Speed of the playhead [units / second] */\n        this._playSpeed = DEFAULT_PLAYHEAD_SPEED;\n        /** The current time position of the playhead. */\n        this._playHeadTime = 0;\n        /** The last time updateDraw() did a draw. */\n        this._updateDrawLastTime = 0;\n        /** Whether the mouse last moved over an object or out. */\n        this._lastHoverAction = MOUSEOUT;\n        /** Name of object that was last hovered over. */\n        this._lastHoveredHash = '';\n        /** If the visualizer automatically should re-resolve the timeline when navigating the viewport */\n        this._timelineResolveAuto = false;\n        /** At what time the timeline was resolved [time] */\n        this._timelineResolveStart = 0;\n        this._timelineResolveEnd = 0;\n        this._timelineResolveZoom = 1;\n        this._timelineResolveCount = 100;\n        this._timelineResolveCountAdjust = 1;\n        /** How much extra (outside the current viewport) the timeline should be resolved to [ratio] */\n        this._timelineResolveExpand = 3;\n        this.latestUpdateTime = 0;\n        this.reresolveTimeout = null;\n        this._mergeIterator = 0;\n        // Initialise other values.\n        this._canvasId = canvasId;\n        this.initCanvas();\n        this._drawPlayhead = !!options.drawPlayhead;\n        // Calculate width of label column.\n        this._layerLabelWidth = this._canvasWidth * this._layerLabelWidthProportionOfCanvas;\n        // Calculate timeline width and start point.\n        this._viewDrawX = this._layerLabelWidth;\n        this._viewDrawWidth = this._canvasWidth - this._layerLabelWidth;\n        // Draw background.\n        this.drawBackground();\n        // Draw playhead.\n        this.drawPlayhead();\n        this.updateDraw();\n    }\n    /**\n     * Initialises the canvas and registers canvas events.\n     */\n    initCanvas() {\n        // Create new canvas object.\n        this._canvasContainer = document.getElementById(this._canvasId);\n        if (!this._canvasContainer)\n            throw new Error(`Canvas \"${this._canvasId}\" not found`);\n        // Get rendering context.\n        this._canvas = this._canvasContainer.getContext('2d');\n        // Register canvas interaction event handlers.\n        this._canvasContainer.addEventListener('mousedown', (event) => this.canvasMouseDown(event));\n        this._canvasContainer.addEventListener('mouseup', (event) => this.canvasMouseUp(event));\n        this._canvasContainer.addEventListener('mousemove', (event) => this.canvasMouseMove(event));\n        this._canvasContainer.addEventListener('wheel', (event) => this.canvasScrollWheel(event));\n        // Get width and height of canvas.\n        this._canvasWidth = this._canvasContainer.width;\n        this._canvasHeight = this._canvasContainer.height;\n    }\n    /**\n     * Updates the timeline, should be called when actions are added/removed from a timeline\n     * but the same timeline is being drawn.\n     * @param {TimelineObject[]} timeline Timeline to draw.\n     * @param {ResolveOptions} options Resolve options.\n     */\n    updateTimeline(timeline, options) {\n        // If options have not been specified set time to 0.\n        if (options === undefined) {\n            options = {\n                time: 0,\n                limitCount: 10\n            };\n        }\n        this.latestTimeline = timeline;\n        this.latestOptions = options;\n        if (!options.limitTime) {\n            this._timelineResolveAuto = true;\n        }\n        else {\n            this._timelineResolveAuto = false;\n        }\n        const options2 = Object.assign({}, options);\n        if (this._timelineResolveAuto) {\n            this.updateTimelineResolveWindow();\n        }\n        if (this._resolvedTimeline === undefined) { // If first time this runs\n            // Set timeline start and end times.\n            if (options2.time !== undefined) {\n                this._viewStartTime = options2.time;\n            }\n            // Move playhead to start time.\n            this._playHeadTime = this._viewStartTime;\n        }\n        this._updateTimeline(true);\n    }\n    _updateTimeline(fromNewTimeline = false) {\n        const options2 = Object.assign({}, this.latestOptions);\n        if (this._timelineResolveAuto) {\n            options2.time = this._timelineResolveStart;\n            options2.limitTime = this._timelineResolveEnd;\n            options2.limitCount = Math.ceil(this._timelineResolveCount * this._timelineResolveCountAdjust);\n        }\n        // If the playhead is being drawn, the resolve time should be at the playhead time.\n        if (this._drawPlayhead && this._playHeadTime > options2.time) {\n            options2.time = this._playHeadTime;\n        }\n        // Resolve the timeline.\n        const startResolve = Date.now();\n        const resolvedTimeline = (0, superfly_timeline_1.resolveTimeline)(this.latestTimeline, options2);\n        if (this._resolvedTimeline === undefined) { // If first time this runs\n            this._resolvedTimeline = resolvedTimeline;\n        }\n        else {\n            if (this._drawPlayhead) {\n                // Trim the current timeline:\n                if (resolvedTimeline) {\n                    // Merge the timelines.\n                    this._resolvedTimeline = this.mergeTimelineObjects(this._resolvedTimeline, resolvedTimeline, fromNewTimeline);\n                }\n            }\n            else {\n                // Otherwise we only see one timeline at a time.\n                // Overwrite the previous timeline:\n                this._resolvedTimeline = resolvedTimeline;\n            }\n        }\n        // Update layers.\n        this.updateLayerLabels();\n        this.latestUpdateTime = Date.now() - startResolve;\n        // Redraw the timeline.\n        this.redrawTimeline();\n        this.latestUpdateTime = Date.now() - startResolve;\n    }\n    /**\n     * Sets the viewport to a position, zoom, and playback speed.\n     * Playback speed currently not implemented.\n     * @param viewPort Object to update viewport with.\n     */\n    setViewPort(viewPort) {\n        // Whether the viewport has changed.\n        let changed = false;\n        // If zoom has been specified.\n        if (viewPort.zoom !== undefined) {\n            // Zoom to specified zoom.\n            this._timelineZoom = viewPort.zoom;\n            changed = true;\n        }\n        // If timestamp has been specified.\n        if (viewPort.timestamp !== undefined) {\n            // Set start time to specified time.\n            if (viewPort.timestamp > 0) {\n                this._viewStartTime = viewPort.timestamp;\n                changed = true;\n            }\n        }\n        if (viewPort.playViewPort !== undefined) {\n            this._playViewPort = viewPort.playViewPort;\n        }\n        // If the playback speed has been set, set the new playback speed.\n        if (viewPort.playSpeed !== undefined) {\n            if (!this._drawPlayhead)\n                throw new Error('setViewPort: viewPort.playSpeed was set, but drawPlayhead was not set in constructor');\n            this._playSpeed = viewPort.playSpeed;\n        }\n        // Set playhead playing/ not playing.\n        if (viewPort.playPlayhead !== undefined) {\n            if (!this._drawPlayhead)\n                throw new Error('setViewPort: viewPort.playPlayhead was set, but drawPlayhead was not set in constructor');\n            this._playHeadPlaying = viewPort.playPlayhead;\n        }\n        if (viewPort.playheadTime !== undefined) {\n            if (!this._drawPlayhead)\n                throw new Error('setViewPort: viewPort.playheadTime was set, but drawPlayhead was not set in constructor');\n            this._playHeadTime = Math.max(0, viewPort.playheadTime);\n            if (this._playHeadTime > 0)\n                this._updateDrawLastTime = this._playHeadTime;\n            changed = true;\n        }\n        // Redraw timeline if anything has changed.\n        if (changed === true) {\n            this.redrawTimeline();\n        }\n    }\n    /**\n     * Accessor for polling the currently hovered over object.\n     */\n    getHoveredObject() {\n        return this._hoveredOver;\n    }\n    /**\n     * Calculates the height to give to each row to fit all layers on screen.\n     * @param {String[]} layers Map of layers to use.\n     * @returns Height of rows.\n     */\n    calculateRowHeight(layers) {\n        return Math.min(MAX_LAYER_HEIGHT, this._canvasHeight / Object.keys(layers).length);\n    }\n    updateLayerLabels() {\n        // Store layers to draw.\n        const o = this.getLayersToDraw();\n        if (!isEqual(this._layerLabels, o.layers)) {\n            this._layerLabels = o.layers;\n            // Calculate row height.\n            this._rowHeight = this.calculateRowHeight(this._layerLabels);\n            // Set timeline object height.\n            this._timelineObjectHeight = this._rowHeight * TIMELINE_OBJECT_HEIGHT;\n            this._numberOfLayers = Object.keys(this._layerLabels).length;\n            this._rowsTotalHeight = this._rowHeight * this._numberOfLayers;\n        }\n    }\n    getLayers() {\n        const layers = Object.entries(this._layerLabels);\n        layers.sort((a, b) => a[1] - b[1]);\n        return layers.map(l => l[0]);\n    }\n    /**\n     * Draws the layer labels to the canvas.\n     */\n    drawLayerLabels() {\n        let row = 0;\n        // Iterate through layers.\n        for (let layerName of this.getLayers()) {\n            this._canvas.fillStyle = COLOR_LABEL_BACKGROUND;\n            this._canvas.fillRect(0, row * this._rowHeight, this._layerLabelWidth, this._rowHeight);\n            this._canvas.fillStyle = TEXT_COLOR;\n            this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\n            this._canvas.textBaseline = 'middle';\n            this._canvas.fillText(layerName, 0, (row * this._rowHeight) + (this._rowHeight / 2), this._layerLabelWidth);\n            if (this._layerLabels[layerName] !== 0) {\n                this._canvas.fillStyle = COLOR_LINE;\n                this._canvas.fillRect(this._layerLabelWidth, row * this._rowHeight, this._viewDrawWidth, THICKNESS_LINE);\n            }\n            row++;\n        }\n    }\n    /**\n     * Draws the timeline background.\n     */\n    drawBackground() {\n        this._canvas.fillStyle = COLOR_BACKGROUND;\n        this._canvas.fillRect(0, 0, this._canvasWidth, this._canvasHeight);\n        this.drawBackgroundRuler();\n    }\n    /**\n     * Draw a ruler on top of background\n     */\n    drawBackgroundRuler() {\n        const range = this.viewRange;\n        const endTime = this.viewEndTime;\n        const circaNumberOfLines = 5;\n        const rounder = Math.pow(10, Math.floor(Math.log10(range / circaNumberOfLines))); // What to round the ruler to\n        const rounderNext = rounder * 10;\n        const numberOfLines = Math.floor(range / rounder);\n        const rulerDiff = rounder;\n        const startTime = Math.floor(this._viewStartTime / rounder) * rounder;\n        const opacity = (Math.min(1, circaNumberOfLines / numberOfLines));\n        if (rulerDiff) {\n            this._canvas.strokeStyle = RULER_LINE_COLOR;\n            this._canvas.lineWidth = RULER_LINE_WIDTH;\n            for (let rulerTime = startTime; rulerTime < endTime; rulerTime += rulerDiff) {\n                this._canvas.beginPath();\n                let x = this.timeToXCoord(rulerTime);\n                let distanceToNext = (rulerTime / rounderNext) % 1;\n                if (distanceToNext > 0.5)\n                    distanceToNext -= 1;\n                distanceToNext = Math.abs(distanceToNext);\n                if (distanceToNext < 0.01) {\n                    // Is a significant line\n                    this._canvas.globalAlpha = 1;\n                }\n                else {\n                    this._canvas.globalAlpha = opacity;\n                }\n                if (x >= this._viewDrawX) {\n                    this._canvas.moveTo(x, 0);\n                    this._canvas.lineTo(x, this._canvasHeight);\n                }\n                this._canvas.stroke();\n            }\n            this._canvas.globalAlpha = 1;\n        }\n    }\n    /**\n     * Draws the playhead initially.\n     */\n    drawPlayhead() {\n        // If the playhead should be draw.\n        if (this._drawPlayhead) {\n            if (this.istimeInView(this._playHeadTime)) {\n                this._canvas.fillStyle = COLOR_PLAYHEAD;\n                this._canvas.fillRect(this.timeToXCoord(this._playHeadTime), 0, THICKNESS_PLAYHEAD, this._canvasHeight);\n            }\n        }\n    }\n    /**\n     * Gets the layers to draw from the timeline.\n     */\n    getLayersToDraw() {\n        this._hoveredObjectMap = {};\n        const layersArray = this._resolvedTimeline ? Object.keys(this._resolvedTimeline.layers) : [];\n        layersArray.sort((a, b) => a.localeCompare(b));\n        const layers = {};\n        layersArray.forEach((layerName, index) => {\n            layers[layerName] = index;\n            this._hoveredObjectMap[layerName] = [];\n        });\n        return {\n            layers: layers,\n            layersArray: layersArray\n        };\n    }\n    /**\n     * Redraws the timeline to the canvas.\n     */\n    redrawTimeline() {\n        this._canvas.clearRect(0, 0, this._canvasWidth, this._canvasHeight);\n        this.drawBackground();\n        this.drawLayerLabels();\n        // Recompute objects positions\n        this._timelineState = this.getTimelineDrawState(this._resolvedTimeline);\n        // Draw the current state.\n        this.drawTimelineState(this._timelineState);\n        this.drawPlayhead();\n        this.checkAutomaticReresolve();\n    }\n    /**\n     * Draws a timeline state to the canvas.\n     * @param {TimelineDrawState} currentDrawState State to draw.\n     */\n    drawTimelineState(currentDrawState) {\n        for (let element in currentDrawState) {\n            const drawState = currentDrawState[element];\n            if (drawState.visible) {\n                this._canvas.fillStyle = COLOR_TIMELINE_OBJECT_FILL;\n                this._canvas.fillRect(drawState.left, drawState.top, drawState.width, drawState.height);\n                this._canvas.strokeStyle = COLOR_TIMELINE_OBJECT_BORDER;\n                this._canvas.lineWidth = THICKNESS_TIMELINE_OBJECT_BORDER;\n                this._canvas.strokeRect(drawState.left, drawState.top, drawState.width, drawState.height);\n                this._canvas.fillStyle = TEXT_COLOR;\n                this._canvas.font = TEXT_FONT_SIZE.toString() + 'px ' + TEXT_FONT_FAMILY;\n                this._canvas.textBaseline = 'top';\n                this._canvas.fillText(drawState.title, drawState.left, drawState.top);\n            }\n        }\n    }\n    /**\n     * Returns the draw states for all timeline objects.\n     * @param {ResolvedTimeline} timeline Timeline to draw.\n     * @returns {TimelineDrawState} State of time-based objects.\n     */\n    getTimelineDrawState(timeline) {\n        let currentDrawState = {};\n        if (timeline) {\n            for (let objId in timeline.objects) {\n                let timelineObj = timeline.objects[objId];\n                for (let _i = 0; _i < timelineObj.resolved.instances.length; _i++) {\n                    let instanceObj = timelineObj.resolved.instances[_i];\n                    let name = 'timelineObject:' + objId + ':' + instanceObj.id;\n                    currentDrawState[name] = this.createStateForObject(timelineObj, instanceObj.start, instanceObj.end);\n                    if (currentDrawState[name].visible === true) {\n                        if (!this._hoveredObjectMap[timelineObj.layer + ''])\n                            this._hoveredObjectMap[timelineObj.layer + ''] = [];\n                        this._hoveredObjectMap[timelineObj.layer + ''].push({\n                            startX: currentDrawState[name].left,\n                            endX: currentDrawState[name].left + currentDrawState[name].width,\n                            objectRefId: objId,\n                            instanceId: instanceObj.id,\n                            type: 'timelineObject',\n                            name: name\n                        });\n                    }\n                }\n            }\n        }\n        return currentDrawState;\n    }\n    /**\n     * Creates a draw state for a timeline object.\n     * @param {string} layer Object's layer.\n     * @param {number} start Start time.\n     * @param {number} end End time.\n     * @returns {DrawState} State of the object to draw.\n     */\n    createStateForObject(obj, start, end) {\n        // Default state (hidden).\n        let state = {\n            height: 0,\n            left: 0,\n            top: 0,\n            width: 0,\n            visible: false,\n            title: 'N/A'\n        };\n        // State should be default if the object is not being shown.\n        if (this.showOnTimeline(start, end)) {\n            // Get object dimensions and position.\n            let objectWidth = this.getObjectWidth(start, end);\n            let xCoord = this.capXcoordToView(this.timeToXCoord(start));\n            let objectTop = this.getObjectOffsetFromTop(obj.layer + '');\n            // Set state properties.\n            state.height = this._timelineObjectHeight;\n            state.left = xCoord;\n            state.top = objectTop;\n            state.width = objectWidth;\n            state.visible = true;\n            state.title = obj.id;\n        }\n        return state;\n    }\n    /**\n     * Calculates the offset, in pixels from the start of the timeline for an object.\n     * @param {number} start start time of the object.\n     * @returns {number} Offset in pixels.\n     */\n    // private getObjectOffsetFromTimelineStart (start: number): number {\n    // \t// Calculate offset.\n    // \tlet offset = (start - this._viewStartTime) * this.pixelsWidthPerUnitTime\n    // \t// Offset cannot be to the left of the timeline start position.\n    // \tif (offset < 0) {\n    // \t\toffset = 0\n    // \t}\n    // \treturn offset\n    // }\n    /**\n     * Calculates the width, in pixels, of an object based on its duration.\n     * @param {number} start Start time of the object.\n     * @param {number} end End time of the object.\n     * @returns {number} Width in pixels.\n     */\n    getObjectWidth(startTime, endTime) {\n        if (!endTime)\n            return this._canvasWidth;\n        // If the start time is less than the timeline start, set to timeline start.\n        if (startTime < this._viewStartTime) {\n            startTime = this._viewStartTime;\n        }\n        // Calculate duration of the object remaining on the timeline.\n        let duration = endTime - startTime;\n        // Return end point position in pixels.\n        return duration * this.pixelsWidthPerUnitTime;\n    }\n    /**\n     * Determines whether to show an object on the timeline.\n     * @param {number} start Object start time.\n     * @param {number} end Object end time.\n     * @returns {true} if object should be shown on the timeline.\n     */\n    showOnTimeline(start, end) {\n        let isAfter = start >= this.viewEndTime;\n        let isBefore = (end || Infinity) <= this._viewStartTime;\n        return !isAfter && !isBefore;\n    }\n    /**\n     * Calculate position of object instance from top of timeline according to its layer.\n     * @param {string} layer Object's layer.\n     * @returns Position relative to top of canvas in pixels.\n     */\n    getObjectOffsetFromTop(layerName) {\n        let top = this._layerLabels[layerName];\n        return top * this._rowHeight;\n    }\n    /**\n     * Moves the playhead. Called periodically.\n     */\n    updateDraw() {\n        const now = Date.now();\n        // How long time since last update:\n        const dt = (this._updateDrawLastTime > 0 ?\n            now - this._updateDrawLastTime :\n            1) / 1000;\n        this._updateDrawLastTime = now;\n        const deltaTime = this._playSpeed * dt;\n        // Check playhead should be drawn.\n        let needRedraw = false;\n        if (this._playHeadPlaying && this._drawPlayhead) {\n            if (this._playViewPort &&\n                this.istimeInView(this._playHeadTime) // Only play if playhead is in view\n            ) {\n                this._viewStartTime += deltaTime;\n            }\n            // Move playhead forward\n            this._playHeadTime += deltaTime;\n            needRedraw = true;\n        }\n        if (needRedraw) {\n            this.redrawTimeline();\n        }\n        // call this function on next frame\n        window.requestAnimationFrame(() => this.updateDraw());\n    }\n    /**\n     * Handles mouse down event.\n     * @param event Mouse event.\n     */\n    canvasMouseDown(event) {\n        // Store mouse is down.\n        this._mouseDown = true;\n        // Store X position of mouse on click.\n        this._mouseLastX = event.clientX;\n        // Prevent event.\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Handles mouse up event.\n     * @param event Mouse event.\n     */\n    canvasMouseUp(event) {\n        // Mouse no longer down.\n        this._mouseDown = false;\n        // Reset scroll direction.\n        this._lastScrollDirection = 0;\n        // Prevent event.\n        event.preventDefault();\n        event.stopPropagation();\n    }\n    /**\n     * Handles mouse movement on canvas.\n     * @param event Mouse event.\n     */\n    canvasMouseMove(event) {\n        // If mouse is down.\n        if (this._mouseDown) {\n            // If we are beginning scrolling, we can move freely.\n            if (this._lastScrollDirection === undefined || this._lastScrollDirection === 0) {\n                // Store current mouse X.\n                this._mouseLastX = event.clientX;\n                // Calculate change in X.\n                let deltaX = event.clientX - this._mouseLastX;\n                // Store scrolling direction.\n                if (deltaX < 0) {\n                    this._lastScrollDirection = -1;\n                }\n                else {\n                    this._lastScrollDirection = 1;\n                }\n                // Scroll to new X position.\n                this.canvasScrollByDeltaX(-deltaX);\n            }\n            else {\n                // Calculate scroll direction.\n                let direction = this._mouseLastX - event.clientX;\n                // If changing direction, store new direction but don't scroll.\n                if (direction < 0 && this._lastScrollDirection === 1) {\n                    this._mouseLastX = event.clientX;\n                    this._lastScrollDirection = -1;\n                }\n                else if (direction > 0 && this._lastScrollDirection === -1) {\n                    this._mouseLastX = event.clientX;\n                    this._lastScrollDirection = 1;\n                }\n                else {\n                    // Calculate change in X.\n                    let deltaX = event.clientX - this._mouseLastX;\n                    // Store last X position.\n                    this._mouseLastX = event.clientX;\n                    // Move by change in X.\n                    this.canvasScrollByDeltaX(-deltaX);\n                }\n            }\n            // Redraw timeline.\n            this.redrawTimeline();\n        }\n        else {\n            // Whether an object is under the cursor.\n            let found = false;\n            // Find the object that is currently hovered over.\n            let mousePos = this.getMousePos(this._canvasContainer, event);\n            if (mousePos.x > this._viewDrawX) {\n                if (mousePos.y < this._rowsTotalHeight) {\n                    let selectedRow = Math.floor((mousePos.y / this._rowsTotalHeight) * this._numberOfLayers);\n                    let layer;\n                    Object.keys(this._layerLabels).forEach(layerName => {\n                        if (this._layerLabels[layerName] === selectedRow)\n                            layer = layerName;\n                    });\n                    let hoverMapData = (layer ? this._hoveredObjectMap[layer] : []) || [];\n                    hoverMapData.forEach(object => {\n                        if (object.startX <= mousePos.x && object.endX >= mousePos.x) {\n                            found = true;\n                            const hoverHash = object.type + object.objectRefId + object.instanceId; // hash-ish\n                            if (this._lastHoveredHash !== hoverHash) {\n                                // Get object metadata from the object name of the hovered object.\n                                // If we are hovering over a timeline object.\n                                if (object.type === 'timelineObject') {\n                                    // Get the timeline object and the instance being hovered over.\n                                    if (this._resolvedTimeline) {\n                                        let timelineObject = this._resolvedTimeline.objects[object.objectRefId];\n                                        let instance = timelineObject.resolved.instances.find(instance => instance.id === object.instanceId);\n                                        if (instance) {\n                                            // Construct hover info.\n                                            let hoverInfo = {\n                                                object: timelineObject,\n                                                instance: instance,\n                                                pointer: { xPostion: mousePos.x, yPosition: mousePos.y }\n                                            };\n                                            // Set currently hovered object.\n                                            this._hoveredOver = hoverInfo;\n                                            // Emit event.\n                                            this.emit('timeline:hover', { detail: this._hoveredOver });\n                                        }\n                                        // Store last items.\n                                        this._lastHoverAction = MOUSEIN;\n                                        this._lastHoveredHash = hoverHash;\n                                    }\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n            // Emit undefined when mouse out.\n            if (!found && this._lastHoverAction === MOUSEIN) {\n                this.emit('timeline:hover', { detail: undefined });\n                this._lastHoverAction = MOUSEOUT;\n            }\n        }\n    }\n    /**\n     * Handles scroll wheel events on the canvas.\n     * @param event Scroll event.\n     */\n    canvasScrollWheel(event) {\n        // Get mouse pointer coordinates on canvas.\n        let canvasCoord = this.getMousePos(this._canvasContainer, event);\n        // Don't scroll if mouse is not over timeline.\n        if (canvasCoord.x <= this._viewDrawX) {\n            return;\n        }\n        let changed = false;\n        // CTRL + scroll to zoom.\n        if (event.ctrlKey === true) {\n            if (event.deltaY) {\n                changed = true;\n                const zoomFactor = Math.pow(ZOOM_FACTOR, -event.deltaY);\n                this.zoomUnderCursor(canvasCoord.x, zoomFactor);\n            }\n        }\n        else if (event.deltaX !== 0) { // Scroll on x-axis\n            changed = true;\n            // Pan.\n            this.canvasScrollByDeltaX((event.deltaX * (PAN_FACTOR * this.stepSize)));\n        }\n        else if (event.deltaY !== 0 && event.altKey === true) { // Also scroll on alt-key + scroll y-axis\n            changed = true;\n            // Pan.\n            this.canvasScrollByDeltaX((event.deltaY * (PAN_FACTOR * this.stepSize)));\n        }\n        // Prevent event.\n        event.preventDefault();\n        event.stopPropagation();\n        if (changed) {\n            // Redraw timeline.\n            this.redrawTimeline();\n        }\n    }\n    /**\n     * Scroll across the canvas by a specified X value.\n     * @param {number} deltaX Value to move by.\n     */\n    canvasScrollByDeltaX(deltaX) {\n        // Calculate new starting time.\n        let targetStart = this._viewStartTime + (deltaX / this.pixelsWidthPerUnitTime);\n        // Starting time cannot be < 0.\n        if (targetStart < 0) {\n            targetStart = 0;\n        }\n        // Optimisation, don't redraw if nothing has changed.\n        if (targetStart === this._viewStartTime) {\n            return;\n        }\n        this._viewStartTime = targetStart;\n    }\n    /**\n     * Zooms into/out of timeline, keeping the time under the cursor in the same position.\n     * @param cursorX Position of mouse cursor.\n     */\n    zoomUnderCursor(cursorX, zoomFactor) {\n        // Point in time of the cursor\n        let cursorTime = this.xCoordToTime(cursorX);\n        // Ratio (in view range) of the cursor\n        let cursorRatio = this.timeToRatio(cursorTime);\n        // Change zoom:\n        this._timelineZoom = this._timelineZoom * zoomFactor;\n        // Limit within current view\n        cursorRatio = Math.max(0, Math.min(1, cursorRatio));\n        // Calculate start\n        let targetStart = cursorTime - (cursorRatio * this.viewRange);\n        // Start cannot be less than 0\n        if (targetStart < 0) {\n            targetStart = 0;\n        }\n        // Set draw time\n        this._viewStartTime = targetStart;\n    }\n    /**\n     * Gets the mouse position relative to the top-left of the canvas [pixels]\n     * @param canvas\n     * @param evt\n     * @returns {x: number, y: number} Position.\n     */\n    getMousePos(canvas, evt) {\n        const rect = canvas.getBoundingClientRect();\n        return {\n            x: evt.clientX - rect.left,\n            y: evt.clientY - rect.top\n        };\n    }\n    /**\n     * Trims a timeline so that objects only exist within a specified time period.\n     * @param timeline Timeline to trim.\n     * @param trim Times to trim between.\n     */\n    trimTimeline(timeline, trim) {\n        // The new resolved objects.\n        let newObjects = {};\n        // Iterate through resolved objects.\n        Object.keys(timeline.objects).forEach((objId) => {\n            const obj = timeline.objects[objId];\n            const resultingInstances = [];\n            obj.resolved.instances.forEach(instance => {\n                // Whether to insert this object into the new timeline.\n                let useInstance = false;\n                let newInstance = Object.assign({}, instance); // clone\n                // If trimming the start time.\n                if (trim.start) {\n                    // If the object ends after the trim start time.\n                    if ((instance.end || Infinity) > trim.start) {\n                        useInstance = true;\n                        if (newInstance.start < trim.start) {\n                            newInstance.start = trim.start;\n                        }\n                    }\n                }\n                // If trimming the end time.\n                if (trim.end) {\n                    // If the object starts before the trim end time.\n                    if (instance.start < trim.end) {\n                        useInstance = true;\n                        if ((newInstance.end || Infinity) > trim.end) {\n                            newInstance.end = trim.end;\n                        }\n                    }\n                }\n                if (!trim.start && !trim.end) {\n                    useInstance = true;\n                }\n                if (useInstance &&\n                    newInstance.start < (newInstance.end || Infinity)) {\n                    resultingInstances.push(newInstance);\n                }\n            });\n            // If there isn't a resolved object for the new instance, create it.\n            if (!newObjects[objId]) {\n                let newObject = {\n                    content: obj.content,\n                    enable: obj.enable,\n                    id: obj.id,\n                    layer: obj.layer,\n                    resolved: Object.assign(Object.assign({}, obj.resolved), { instances: [] })\n                };\n                newObjects[objId] = newObject;\n            }\n            newObjects[objId].resolved.instances = resultingInstances;\n        });\n        return {\n            classes: timeline.classes,\n            layers: timeline.layers,\n            objects: newObjects,\n            statistics: timeline.statistics,\n            nextEvents: timeline.nextEvents\n        };\n    }\n    /**\n     * Merges two timelines by merging instances of objects that intersect each other.\n     * @param past Older timeline.\n     * @param present Newer timeline.\n     * @returns {ResolvedTimeline} containing merged timelines.\n     */\n    mergeTimelineObjects(past, present, fromNewTimeline) {\n        const resultingObjects = {};\n        if (fromNewTimeline) {\n            past = this.trimTimeline(past, { end: this._playHeadTime });\n            present = this.trimTimeline(present, { start: this._playHeadTime });\n            // Because we want to keep old objects, this iterator is used to create unique old ids for them\n            this._mergeIterator++;\n            Object.keys(past.objects).forEach((objId) => {\n                const pastObj = past.objects[objId];\n                // @ts-ignore: hack to mark it as a \"past object\"\n                if (pastObj.__pastObj) {\n                    // Copy over it right away, it's old. Don't do anything else\n                    resultingObjects[objId] = pastObj;\n                    return;\n                }\n                // If an object exists in both timelines\n                const presentObj = present.objects[objId];\n                if (presentObj) {\n                    if (\n                    // Compare the objects, only look into merging them if they look identical\n                    isEqual(Object.assign({}, pastObj, { resolved: null }), Object.assign({}, presentObj, { resolved: null }))) {\n                        // This assumes that all past instances stop at a certain time at the very latest,\n                        // and that all new instances start at that time at the very earliest.\n                        // Iterate over all instances of those objects.\n                        const allInstances = {};\n                        pastObj.resolved.instances.forEach(pastInstance => {\n                            allInstances[pastInstance.end + ''] = pastInstance;\n                        });\n                        presentObj.resolved.instances.forEach(presentInstance => {\n                            if (allInstances[presentInstance.start + '']) {\n                                // The instances are next to each other, merge them into one:\n                                allInstances[presentInstance.start + ''].end = presentInstance.end;\n                            }\n                            else {\n                                allInstances[presentInstance.start + ''] = presentInstance;\n                            }\n                        });\n                        presentObj.resolved.instances = [];\n                        Object.keys(allInstances).forEach(key => {\n                            const instance = allInstances[key];\n                            presentObj.resolved.instances.push(instance);\n                        });\n                        // Copy over the new object\n                        resultingObjects[objId] = presentObj;\n                        return; // don't copy over old object\n                    }\n                    else {\n                        // The objects doesn't look identical\n                        // Copy over the new object\n                        resultingObjects[objId] = presentObj;\n                    }\n                }\n                else {\n                    // The old object doesn't exist in the new timeline\n                }\n                // @ts-ignore: hack to mark it as a \"past object\"\n                pastObj.__pastObj = true;\n                // Copy over the old object\n                resultingObjects[this._mergeIterator + '__' + objId] = pastObj;\n            });\n            // Iterate over the next objects\n            Object.keys(present.objects).forEach((objId) => {\n                const presentObj = present.objects[objId];\n                if (!past.objects[objId]) { // (if it did existed in the past, it has already been handled)\n                    // Just copy over the new object\n                    resultingObjects[objId] = presentObj;\n                }\n            });\n        }\n        else {\n            // No new timeline, objects and instances are only added\n            Object.keys(past.objects).forEach((objId) => {\n                const pastObj = past.objects[objId];\n                resultingObjects[objId] = pastObj;\n            });\n            Object.keys(present.objects).forEach((objId) => {\n                const presentObj = present.objects[objId];\n                const existingObj = resultingObjects[objId];\n                if (existingObj) {\n                    // merge with old instances\n                    const existingInstances = {};\n                    existingObj.resolved.instances.forEach(instance => {\n                        existingInstances[instance.start + '_' + instance.end] = true;\n                    });\n                    presentObj.resolved.instances.forEach(instance => {\n                        // Only push instances that aren't already present:\n                        if (!existingInstances[instance.start + '_' + instance.end]) {\n                            existingObj.resolved.instances.push(instance);\n                        }\n                    });\n                }\n                else {\n                    resultingObjects[objId] = presentObj;\n                }\n            });\n        }\n        const resultingLayers = {};\n        Object.keys(resultingObjects).forEach(key => {\n            const obj = resultingObjects[key];\n            const layer = obj.layer + '';\n            if (!resultingLayers[layer])\n                resultingLayers[layer] = [];\n            resultingLayers[layer].push(key);\n        });\n        return Object.assign(Object.assign({}, present), { objects: resultingObjects, layers: resultingLayers });\n    }\n    updateTimelineResolveWindow() {\n        const { start, end } = this.getExpandedStartEndTime(1);\n        this._timelineResolveStart = start;\n        this._timelineResolveEnd = end;\n        this._timelineResolveZoom = this._timelineZoom;\n        if (this.latestUpdateTime) {\n            // Calculate an optimal number of objects to create, so that the drawing still runs smoothly.\n            const targetResolveTime = 50; // ms\n            let ratio = targetResolveTime / this.latestUpdateTime;\n            this._timelineResolveCountAdjust = Math.max(0.1, Math.min(10, (1 + (this._timelineResolveCountAdjust * ratio)) / 2));\n        }\n    }\n    getExpandedStartEndTime(multiplier = 1) {\n        let start = this._viewStartTime;\n        let end = this.viewEndTime;\n        let duration = end - start;\n        let expand = duration * (this._timelineResolveExpand - 1) * multiplier;\n        start -= expand * 0.33;\n        end += expand * 0.66; // expand more into the future\n        start = Math.max(0, start);\n        end = Math.max(0, end);\n        const zoomDiff = Math.max(this._timelineResolveZoom, this._timelineZoom) /\n            Math.min(this._timelineResolveZoom, this._timelineZoom);\n        return { start, end, zoomDiff };\n    }\n    checkAutomaticReresolve() {\n        const { start, end, zoomDiff } = this.getExpandedStartEndTime(0.2);\n        if (this._timelineResolveAuto && (start < this._timelineResolveStart ||\n            end > this._timelineResolveEnd ||\n            zoomDiff > 3)) {\n            if (!this.reresolveTimeout) {\n                this.reresolveTimeout = setTimeout(() => {\n                    this.reresolveTimeout = null;\n                    this.updateTimelineResolveWindow();\n                    this._updateTimeline();\n                }, Math.max(100, this.latestUpdateTime * 5));\n            }\n        }\n    }\n    // --------------------- Conversions between position & time -------------\n    /**\n     * Calculate the X coordinate of a time value.\n     * @param {number} time The time to convert.\n     * @returns {number} The X coordinate of the time.\n     */\n    timeToXCoord(time) {\n        return this._viewDrawX + ((time - this._viewStartTime) * this.pixelsWidthPerUnitTime);\n    }\n    /**\n     * Calculate the time of a X coordinate.\n     * @param {number} time The X coordinate to convert.\n     * @returns {number} The time of the X coordinate.\n     */\n    xCoordToTime(position) {\n        return this._viewStartTime + ((position - this._viewDrawX) / this.pixelsWidthPerUnitTime);\n    }\n    /** Calculate the ratio of the time in current view (0 i beginning, 1 is end)  */\n    timeToRatio(time) {\n        return (time - this._viewStartTime) / this.viewRange;\n    }\n    /** Returns true if the position is within the current view  */\n    istimeInView(time) {\n        const ratio = this.timeToRatio(time);\n        return ratio >= 0 && ratio < 1;\n    }\n    capXcoordToView(position) {\n        return Math.max(this._viewDrawX, Math.min(this._viewDrawX + this._viewDrawWidth, position));\n    }\n    // -------------- Getters / Convenience functions ---------------------\n    /** Zoom factor [pixels / time] */\n    get pixelsWidthPerUnitTime() {\n        return (this._timelineZoom / 100);\n    }\n    /** The range of the view [time] */\n    get viewRange() {\n        return this._viewDrawWidth / this.pixelsWidthPerUnitTime;\n    }\n    /** The end time of the view [time] */\n    get viewEndTime() {\n        return this._viewStartTime + this.viewRange;\n    }\n}\nexports.TimelineVisualizer = TimelineVisualizer;\n//# sourceMappingURL=timelineVisualizer.js.map","","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar objectCreate = Object.create || objectCreatePolyfill\nvar objectKeys = Object.keys || objectKeysPolyfill\nvar bind = Function.prototype.bind || functionBindPolyfill\n\nfunction EventEmitter() {\n  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {\n    this._events = objectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nvar hasDefineProperty;\ntry {\n  var o = {};\n  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });\n  hasDefineProperty = o.x === 0;\n} catch (err) { hasDefineProperty = false }\nif (hasDefineProperty) {\n  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n    enumerable: true,\n    get: function() {\n      return defaultMaxListeners;\n    },\n    set: function(arg) {\n      // check whether the input is a positive number (whose value is zero or\n      // greater and not a NaN).\n      if (typeof arg !== 'number' || arg < 0 || arg !== arg)\n        throw new TypeError('\"defaultMaxListeners\" must be a positive number');\n      defaultMaxListeners = arg;\n    }\n  });\n} else {\n  EventEmitter.defaultMaxListeners = defaultMaxListeners;\n}\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    if (arguments.length > 1)\n      er = arguments[1];\n    if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Unhandled \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n      // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n      // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = objectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n          listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n          prepend ? [listener, existing] : [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n            existing.length + ' \"' + String(type) + '\" listeners ' +\n            'added. Use emitter.setMaxListeners() to ' +\n            'increase limit.');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        if (typeof console === 'object' && console.warn) {\n          console.warn('%s: %s', w.name, w.message);\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    switch (arguments.length) {\n      case 0:\n        return this.listener.call(this.target);\n      case 1:\n        return this.listener.call(this.target, arguments[0]);\n      case 2:\n        return this.listener.call(this.target, arguments[0], arguments[1]);\n      case 3:\n        return this.listener.call(this.target, arguments[0], arguments[1],\n            arguments[2]);\n      default:\n        var args = new Array(arguments.length);\n        for (var i = 0; i < args.length; ++i)\n          args[i] = arguments[i];\n        this.listener.apply(this.target, args);\n    }\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = bind.call(onceWrapper, state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = objectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else\n          spliceOne(list, position);\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = objectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = objectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = objectKeys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = objectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (!events)\n    return [];\n\n  var evlistener = events[type];\n  if (!evlistener)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction objectCreatePolyfill(proto) {\n  var F = function() {};\n  F.prototype = proto;\n  return new F;\n}\nfunction objectKeysPolyfill(obj) {\n  var keys = [];\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {\n    keys.push(k);\n  }\n  return k;\n}\nfunction functionBindPolyfill(context) {\n  var fn = this;\n  return function () {\n    return fn.apply(context, arguments);\n  };\n}\n","/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Performs a deep comparison between two values to determine if they are\n * equivalent.\n *\n * **Note:** This method supports comparing arrays, array buffers, booleans,\n * date objects, error objects, maps, numbers, `Object` objects, regexes,\n * sets, strings, symbols, and typed arrays. `Object` objects are compared\n * by their own, not inherited, enumerable properties. Functions and DOM\n * nodes are compared by strict equality, i.e. `===`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.isEqual(object, other);\n * // => true\n *\n * object === other;\n * // => false\n */\nfunction isEqual(value, other) {\n  return baseIsEqual(value, other);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = isEqual;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=expression.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./expression\"), exports);\ntslib_1.__exportStar(require(\"./resolvedTimeline\"), exports);\ntslib_1.__exportStar(require(\"./resolver\"), exports);\ntslib_1.__exportStar(require(\"./state\"), exports);\ntslib_1.__exportStar(require(\"./timeline\"), exports);\ntslib_1.__exportStar(require(\"./types\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EventType = void 0;\nvar EventType;\n(function (EventType) {\n    EventType[EventType[\"START\"] = 0] = \"START\";\n    EventType[EventType[\"END\"] = 1] = \"END\";\n    EventType[EventType[\"KEYFRAME\"] = 2] = \"KEYFRAME\";\n})(EventType = exports.EventType || (exports.EventType = {}));\n//# sourceMappingURL=resolvedTimeline.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=resolver.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=state.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=timeline.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.onCloseCleanup = exports.validateExpression = exports.wrapInnerExpressions = exports.simplifyExpression = exports.interpretExpression = exports.applyKeyframeContent = exports.validateReferenceString = exports.validateKeyframe = exports.validateObject = exports.validateTimeline = exports.getResolvedState = exports.resolveTimeline = void 0;\nconst tslib_1 = require(\"tslib\");\ntslib_1.__exportStar(require(\"./api\"), exports);\nconst StateHandler_1 = require(\"./resolver/StateHandler\");\nconst ExpressionHandler_1 = require(\"./resolver/ExpressionHandler\");\nconst ResolverHandler_1 = require(\"./resolver/ResolverHandler\");\nconst TimelineValidator_1 = require(\"./resolver/TimelineValidator\");\n/**\n * Resolves a timeline, i.e. resolves the references between objects\n * and calculates the absolute times for all objects in the timeline.\n */\nfunction resolveTimeline(timeline, options) {\n    const resolverInstance = new ResolverHandler_1.ResolverHandler(options);\n    return resolverInstance.resolveTimeline(timeline);\n}\nexports.resolveTimeline = resolveTimeline;\n/**\n * Retrieve the state for a certain point in time.\n * The state contains all objects that are active at that point in time.\n * @param resolvedTimeline\n * @param time\n * @param eventLimit\n */\nfunction getResolvedState(resolvedTimeline, time, eventLimit = 0) {\n    const stateHandler = new StateHandler_1.StateHandler();\n    return stateHandler.getState(resolvedTimeline, time, eventLimit);\n}\nexports.getResolvedState = getResolvedState;\n/**\n * Validates all objects in the timeline. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some optional strict rules. Set this to true to increase future compatibility.\n */\nfunction validateTimeline(timeline, strict) {\n    const validator = new TimelineValidator_1.TimelineValidator();\n    validator.validateTimeline(timeline, strict);\n}\nexports.validateTimeline = validateTimeline;\n/**\n * Validates a Timeline-object. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some optional strict rules. Set this to true to increase future compatibility.\n */\nfunction validateObject(obj, strict) {\n    const validator = new TimelineValidator_1.TimelineValidator();\n    validator.validateObject(obj, strict);\n}\nexports.validateObject = validateObject;\n/**\n * Validates a Timeline-keyframe. Throws an error if something's wrong\n * @param timeline The timeline to validate\n * @param strict Set to true to enable some optional strict rules. Set this to true to increase future compatibility.\n */\nfunction validateKeyframe(keyframe, strict) {\n    const validator = new TimelineValidator_1.TimelineValidator();\n    validator.validateKeyframe(keyframe, strict);\n}\nexports.validateKeyframe = validateKeyframe;\n/**\n * Validates a string that is used in Timeline as a reference (an id, a class or layer)\n * @param str The string to validate\n * @param strict Set to true to enable some optional strict rules. Set this to true to increase future compatibility.\n */\nfunction validateReferenceString(str, strict) {\n    TimelineValidator_1.TimelineValidator.validateReferenceString(str, strict);\n}\nexports.validateReferenceString = validateReferenceString;\n/**\n * Apply keyframe content onto its parent content.\n * The keyframe content is deeply-applied onto the parent content.\n * Note: This function mutates the parentContent.\n */\nfunction applyKeyframeContent(parentContent, keyframeContent) {\n    StateHandler_1.StateHandler.applyKeyframeContent(parentContent, keyframeContent);\n}\nexports.applyKeyframeContent = applyKeyframeContent;\nlet expressionHandler = undefined;\nfunction getExpressionHandler() {\n    if (!expressionHandler)\n        expressionHandler = new ExpressionHandler_1.ExpressionHandler(true);\n    return expressionHandler;\n}\nfunction interpretExpression(expression) {\n    return getExpressionHandler().interpretExpression(expression);\n}\nexports.interpretExpression = interpretExpression;\nfunction simplifyExpression(expr0) {\n    return getExpressionHandler().simplifyExpression(expr0);\n}\nexports.simplifyExpression = simplifyExpression;\nfunction wrapInnerExpressions(words) {\n    return getExpressionHandler().wrapInnerExpressions(words);\n}\nexports.wrapInnerExpressions = wrapInnerExpressions;\nfunction validateExpression(operatorList, expr0, breadcrumbs) {\n    return getExpressionHandler().validateExpression(operatorList, expr0, breadcrumbs);\n}\nexports.validateExpression = validateExpression;\n/**\n * If you have called any of the manual expression-functions, such as interpretExpression(),\n * you could call this to manually clean up an internal cache, to ensure your application quits cleanly.\n */\nfunction onCloseCleanup() {\n    if (expressionHandler)\n        expressionHandler.clearCache();\n}\nexports.onCloseCleanup = onCloseCleanup;\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hashTimelineObject = exports.CacheHandler = void 0;\nconst lib_1 = require(\"./lib/lib\");\nconst performance_1 = require(\"./lib/performance\");\nconst reference_1 = require(\"./lib/reference\");\nconst timeline_1 = require(\"./lib/timeline\");\nclass CacheHandler {\n    constructor(cache, resolvedTimeline) {\n        this.resolvedTimeline = resolvedTimeline;\n        if (!cache.objHashes)\n            cache.objHashes = {};\n        if (!cache.objects)\n            cache.objects = {};\n        if (!cache.canBeUsed) {\n            // Reset the cache:\n            cache.objHashes = {};\n            cache.objects = {};\n            this.canUseIncomingCache = false;\n        }\n        else {\n            this.canUseIncomingCache = true;\n        }\n        // cache.canBeUsed will be set in this.persistData()\n        cache.canBeUsed = false;\n        this.cache = cache;\n    }\n    debug(...args) {\n        if (this.resolvedTimeline.options.debug)\n            console.log(...args);\n    }\n    determineChangedObjects() {\n        const toc = (0, performance_1.tic)('  cache.determineChangedObjects');\n        // Go through all new objects, and determine whether they have changed:\n        const allNewObjects = {};\n        const changedReferences = {};\n        const addChangedObject = (obj) => {\n            const references = this.getAllReferencesThisObjectAffects(obj);\n            for (const ref of references) {\n                changedReferences[ref] = true;\n            }\n        };\n        for (const obj of this.resolvedTimeline.objectsMap.values()) {\n            const oldHash = this.cache.objHashes[obj.id];\n            const newHash = hashTimelineObject(obj);\n            allNewObjects[obj.id] = true;\n            if (!oldHash)\n                this.debug(`Cache: Object \"${obj.id}\" is new`);\n            else if (oldHash !== newHash)\n                this.debug(`Cache: Object \"${obj.id}\" has changed`);\n            if (\n            // Object is new:\n            !oldHash ||\n                // Object has changed:\n                oldHash !== newHash) {\n                this.cache.objHashes[obj.id] = newHash;\n                addChangedObject(obj);\n                const oldObj = this.cache.objects[obj.id];\n                if (oldObj)\n                    addChangedObject(oldObj);\n            }\n            else {\n                // No timing-affecting changes detected\n                /* istanbul ignore if */\n                if (!oldHash)\n                    this.debug(`Cache: Object \"${obj.id}\" is similar`);\n                // Even though the timeline-properties hasn't changed,\n                // the content (and other properties) might have:\n                const oldObj = this.cache.objects[obj.id];\n                /* istanbul ignore if */\n                if (!oldObj) {\n                    console.error('oldHash', oldHash);\n                    console.error('ids', Object.keys(this.cache.objects));\n                    throw new Error(`Internal Error: obj \"${obj.id}\" not found in cache, even though hashes match!`);\n                }\n                this.cache.objects[obj.id] = {\n                    ...obj,\n                    resolved: oldObj.resolved,\n                };\n            }\n        }\n        if (this.canUseIncomingCache) {\n            // Go through all old hashes, removing the ones that doesn't exist anymore\n            for (const objId in this.cache.objects) {\n                if (!allNewObjects[objId]) {\n                    const obj = this.cache.objects[objId];\n                    delete this.cache.objHashes[objId];\n                    addChangedObject(obj);\n                }\n            }\n            // Invalidate objects, by gradually removing the invalidated ones from validObjects\n            // Prepare validObjects:\n            const validObjects = {};\n            for (const obj of this.resolvedTimeline.objectsMap.values()) {\n                validObjects[obj.id] = obj;\n            }\n            /** All references that depend on another reference (ie objects, classs or layers): */\n            const affectReferenceMap = {};\n            for (const obj of this.resolvedTimeline.objectsMap.values()) {\n                // Add everything that this object affects:\n                const cachedObj = this.cache.objects[obj.id];\n                let affectedReferences = this.getAllReferencesThisObjectAffects(obj);\n                if (cachedObj) {\n                    affectedReferences = (0, reference_1.joinReferences)(affectedReferences, this.getAllReferencesThisObjectAffects(cachedObj));\n                }\n                for (let i = 0; i < affectedReferences.length; i++) {\n                    const ref = affectedReferences[i];\n                    const objRef = `#${obj.id}`;\n                    if (ref !== objRef) {\n                        if (!affectReferenceMap[objRef])\n                            affectReferenceMap[objRef] = [];\n                        affectReferenceMap[objRef].push(ref);\n                    }\n                }\n                // Add everything that this object is affected by:\n                if (changedReferences[`#${obj.id}`]) {\n                    // The object is directly said to be invalid, no need to add it to referencingObjects,\n                    // since it'll be easily invalidated anyway later\n                }\n                else {\n                    // Note: we only have to check for the OLD object, since if the old and the new object differs,\n                    // that would mean it'll be directly invalidated anyway.\n                    if (cachedObj) {\n                        // Fetch all references for the object from the last time it was resolved.\n                        // Note: This can be done, since _if_ the object was changed in any way since last resolve\n                        // it'll be invalidated anyway\n                        const dependOnReferences = cachedObj.resolved.directReferences;\n                        for (let i = 0; i < dependOnReferences.length; i++) {\n                            const ref = dependOnReferences[i];\n                            if (!affectReferenceMap[ref])\n                                affectReferenceMap[ref] = [];\n                            affectReferenceMap[ref].push(`#${obj.id}`);\n                        }\n                    }\n                }\n            }\n            // Invalidate all changed objects, and recursively invalidate all objects that reference those objects:\n            const handledReferences = {};\n            for (const reference of Object.keys(changedReferences)) {\n                this.invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects);\n            }\n            // The objects that are left in validObjects at this point are still valid.\n            // We can reuse the old resolving for those:\n            for (const obj of Object.values(validObjects)) {\n                if (!this.cache.objects[obj.id])\n                    /* istanbul ignore next */\n                    throw new Error(`Something went wrong: \"${obj.id}\" does not exist in cache.resolvedTimeline.objects`);\n                this.resolvedTimeline.objectsMap.set(obj.id, this.cache.objects[obj.id]);\n            }\n        }\n        toc();\n    }\n    persistData() {\n        const toc = (0, performance_1.tic)('  cache.persistData');\n        if (this.resolvedTimeline.resolveError) {\n            // If there was a resolve error, clear the cache:\n            this.cache.objHashes = {};\n            this.cache.objects = {};\n            this.cache.canBeUsed = false;\n        }\n        else {\n            this.cache.objects = (0, lib_1.mapToObject)(this.resolvedTimeline.objectsMap);\n            this.cache.canBeUsed = true;\n        }\n        toc();\n    }\n    getAllReferencesThisObjectAffects(newObj) {\n        const references = [`#${newObj.id}`];\n        if (newObj.classes) {\n            for (const className of newObj.classes) {\n                references.push(`.${className}`);\n            }\n        }\n        if ((0, timeline_1.objHasLayer)(newObj))\n            references.push(`$${newObj.layer}`);\n        if (newObj.children) {\n            for (const child of newObj.children) {\n                references.push(`#${child.id}`);\n            }\n        }\n        return references;\n    }\n    /** Invalidate all changed objects, and recursively invalidate all objects that reference those objects */\n    invalidateObjectsWithReference(handledReferences, reference, affectReferenceMap, validObjects) {\n        if (handledReferences[reference])\n            return; // to avoid infinite loops\n        handledReferences[reference] = true;\n        if ((0, reference_1.isObjectReference)(reference)) {\n            const objId = (0, reference_1.getRefObjectId)(reference);\n            if (validObjects[objId]) {\n                delete validObjects[objId];\n            }\n        }\n        // Invalidate all objects that depend on any of the references that this reference affects:\n        const affectedReferences = affectReferenceMap[reference];\n        if (affectedReferences) {\n            for (let i = 0; i < affectedReferences.length; i++) {\n                const referencingReference = affectedReferences[i];\n                this.invalidateObjectsWithReference(handledReferences, referencingReference, affectReferenceMap, validObjects);\n            }\n        }\n    }\n}\nexports.CacheHandler = CacheHandler;\n/** Return a \"hash-string\" which changes whenever anything that affects timing of a timeline-object has changed. */\nfunction hashTimelineObject(obj) {\n    /*\n    Note: The following properties are ignored, as they don't affect timing or resolving:\n     * id\n     * children\n     * keyframes\n     * isGroup\n     * content\n     */\n    return `${JSON.stringify(obj.enable)},${+!!obj.disabled},${obj.priority}',${obj.resolved.parentId},${+obj.resolved\n        .isKeyframe},${obj.classes ? obj.classes.join('.') : ''},${obj.layer},${+!!obj.seamless}`;\n}\nexports.hashTimelineObject = hashTimelineObject;\n//# sourceMappingURL=CacheHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ExpressionHandler = exports.REGEXP_OPERATORS = exports.OPERATORS = void 0;\nconst lib_1 = require(\"./lib/lib\");\nconst cache_1 = require(\"./lib/cache\");\nconst expression_1 = require(\"./lib/expression\");\nexports.OPERATORS = ['&', '|', '+', '-', '*', '/', '%', '!'];\nexports.REGEXP_OPERATORS = new RegExp('([' + exports.OPERATORS.map((o) => '\\\\' + o).join('') + '\\\\(\\\\)])', 'g');\nclass ExpressionHandler {\n    constructor(autoClearCache, skipValidation) {\n        this.skipValidation = skipValidation;\n        this.cache = new cache_1.Cache(autoClearCache);\n    }\n    interpretExpression(expression) {\n        if ((0, expression_1.isNumericExpr)(expression)) {\n            return parseFloat(expression);\n        }\n        else if (typeof expression === 'string') {\n            const expressionString = expression;\n            return this.cache.cacheResult(expressionString, () => {\n                const expr = expressionString.replace(exports.REGEXP_OPERATORS, ' $1 '); // Make sure there's a space between every operator & operand\n                const words = (0, lib_1.compact)(expr.split(' '));\n                if (words.length === 0)\n                    return null; // empty expression\n                // Fix special case: a + - b\n                for (let i = words.length - 2; i >= 1; i--) {\n                    if ((words[i] === '-' || words[i] === '+') && wordIsOperator(exports.OPERATORS, words[i - 1])) {\n                        words[i] = words[i] + words[i + 1];\n                        words.splice(i + 1, 1);\n                    }\n                }\n                const innerExpression = this.wrapInnerExpressions(words);\n                if (innerExpression.rest.length)\n                    throw new Error(`interpretExpression: syntax error: parentheses don't add up in \"${expr}\".`);\n                if (innerExpression.inner.length % 2 !== 1) {\n                    throw new Error(`interpretExpression: operands & operators don't add up: \"${innerExpression.inner.join(' ')}\".`);\n                }\n                const returnExpression = this.words2Expression(exports.OPERATORS, innerExpression.inner);\n                if (!this.skipValidation)\n                    this.validateExpression(exports.OPERATORS, returnExpression);\n                return returnExpression;\n            }, 60 * 60 * 1000 // 1 hour\n            );\n        }\n        else {\n            return expression;\n        }\n    }\n    /** Try to simplify an expression, this includes:\n     * * Combine constant operands, using arithmetic operators\n     * ...more to come?\n     */\n    simplifyExpression(expr0) {\n        const expr = typeof expr0 === 'string' ? this.interpretExpression(expr0) : expr0;\n        if (!expr)\n            return expr;\n        if (isExpressionObject(expr)) {\n            const l = this.simplifyExpression(expr.l);\n            const o = expr.o;\n            const r = this.simplifyExpression(expr.r);\n            if (typeof l === 'number' && typeof r === 'number') {\n                // The operands can be combined:\n                switch (o) {\n                    case '+':\n                        return l + r;\n                    case '-':\n                        return l - r;\n                    case '*':\n                        return l * r;\n                    case '/':\n                        return l / r;\n                    case '%':\n                        return l % r;\n                    default:\n                        return { l, o, r };\n                }\n            }\n            return { l, o, r };\n        }\n        return expr;\n    }\n    // Turns ['a', '(', 'b', 'c', ')'] into ['a', ['b', 'c']]\n    // or ['a', '&', '!', 'b'] into ['a', '&', ['', '!', 'b']]\n    wrapInnerExpressions(words) {\n        for (let i = 0; i < words.length; i++) {\n            switch (words[i]) {\n                case '(': {\n                    const tmp = this.wrapInnerExpressions(words.slice(i + 1));\n                    // insert inner expression and remove tha\n                    words[i] = tmp.inner;\n                    words.splice(i + 1, 99999, ...tmp.rest);\n                    break;\n                }\n                case ')':\n                    return {\n                        inner: words.slice(0, i),\n                        rest: words.slice(i + 1),\n                    };\n                case '!': {\n                    const tmp = this.wrapInnerExpressions(words.slice(i + 1));\n                    // insert inner expression after the '!'\n                    words[i] = ['', '!'].concat(tmp.inner);\n                    words.splice(i + 1, 99999, ...tmp.rest);\n                    break;\n                }\n            }\n        }\n        return {\n            inner: words,\n            rest: [],\n        };\n    }\n    /** Validates an expression. Returns true on success, throws error if not */\n    validateExpression(operatorList, expr0, breadcrumbs) {\n        if (!breadcrumbs)\n            breadcrumbs = 'ROOT';\n        if ((0, lib_1.isObject)(expr0) && !(0, lib_1.isArray)(expr0)) {\n            const expr = expr0;\n            if (expr.l === undefined)\n                throw new Error(`validateExpression: ${breadcrumbs}.l missing in ${JSON.stringify(expr)}`);\n            if (expr.o === undefined)\n                throw new Error(`validateExpression: ${breadcrumbs}.o missing in ${JSON.stringify(expr)}`);\n            if (expr.r === undefined)\n                throw new Error(`validateExpression: ${breadcrumbs}.r missing in ${JSON.stringify(expr)}`);\n            if (typeof expr.o !== 'string')\n                throw new Error(`validateExpression: ${breadcrumbs}.o not a string`);\n            if (!wordIsOperator(operatorList, expr.o))\n                throw new Error(breadcrumbs + '.o not valid: \"' + expr.o + '\"');\n            return (this.validateExpression(operatorList, expr.l, breadcrumbs + '.l') &&\n                this.validateExpression(operatorList, expr.r, breadcrumbs + '.r'));\n        }\n        else if (expr0 !== null && typeof expr0 !== 'string' && typeof expr0 !== 'number') {\n            throw new Error(`validateExpression: ${breadcrumbs} is of invalid type`);\n        }\n        return true;\n    }\n    clearCache() {\n        this.cache.clear();\n    }\n    words2Expression(operatorList, words) {\n        /* istanbul ignore if */\n        if (!words?.length)\n            throw new Error('words2Expression: syntax error: unbalanced expression');\n        while (words.length === 1 && words[0] !== null && (0, lib_1.isArray)(words[0]))\n            words = words[0];\n        if (words.length === 1)\n            return words[0];\n        // Find the operator with the highest priority:\n        let operatorI = -1;\n        for (let i = 0; i < operatorList.length; i++) {\n            const operator = operatorList[i];\n            if (operatorI === -1) {\n                operatorI = words.lastIndexOf(operator);\n            }\n        }\n        if (operatorI !== -1) {\n            const l = words.slice(0, operatorI);\n            const r = words.slice(operatorI + 1);\n            const expr = {\n                l: this.words2Expression(operatorList, l),\n                o: words[operatorI],\n                r: this.words2Expression(operatorList, r),\n            };\n            return expr;\n        }\n        else\n            throw new Error('words2Expression: syntax error: operator not found: \"' + words.join(' ') + '\"');\n    }\n}\nexports.ExpressionHandler = ExpressionHandler;\nfunction isExpressionObject(expr) {\n    return (typeof expr === 'object' &&\n        expr !== null &&\n        expr.l !== undefined &&\n        expr.o !== undefined &&\n        expr.r !== undefined);\n}\nfunction wordIsOperator(operatorList, word) {\n    if (operatorList.indexOf(word) !== -1)\n        return true;\n    return false;\n}\n//# sourceMappingURL=ExpressionHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InstanceHandler = void 0;\nconst cap_1 = require(\"./lib/cap\");\nconst event_1 = require(\"./lib/event\");\nconst instance_1 = require(\"./lib/instance\");\nconst lib_1 = require(\"./lib/lib\");\nconst reference_1 = require(\"./lib/reference\");\nclass InstanceHandler {\n    constructor(resolvedTimeline) {\n        this.resolvedTimeline = resolvedTimeline;\n    }\n    invertInstances(instances) {\n        if (instances.length) {\n            instances = this.cleanInstances(instances, true, true);\n            const invertedInstances = [];\n            if (instances[0].start !== 0) {\n                invertedInstances.push({\n                    id: this.resolvedTimeline.getInstanceId(),\n                    isFirst: true,\n                    start: 0,\n                    end: null,\n                    references: (0, reference_1.joinReferences)(instances[0].references, `@${instances[0].id}`),\n                });\n            }\n            for (let i = 0; i < instances.length; i++) {\n                const instance = instances[i];\n                const lastInstance = (0, lib_1.last)(invertedInstances);\n                if (lastInstance) {\n                    lastInstance.end = instance.start;\n                }\n                if (instance.end !== null) {\n                    invertedInstances.push({\n                        id: this.resolvedTimeline.getInstanceId(),\n                        start: instance.end,\n                        end: null,\n                        references: (0, reference_1.joinReferences)(instance.references, `@${instance.id}`),\n                        caps: instance.caps,\n                    });\n                }\n            }\n            return invertedInstances;\n        }\n        else {\n            return [\n                {\n                    id: this.resolvedTimeline.getInstanceId(),\n                    isFirst: true,\n                    start: 0,\n                    end: null,\n                    references: [],\n                },\n            ];\n        }\n    }\n    /**\n     * Converts a list of events into a list of instances.\n     * @param events The list of start- and end- events\n     * @param allowMerge If true, will merge instances that overlap into one.\n     * @param allowZeroGaps If true, allows zero-length gaps between instances. If false, will combine the two into one instance.\n     * @param omitOriginalStartEnd Of true, will not keep .originalStart and .originalEnd of the instances\n     */\n    convertEventsToInstances(events, allowMerge, allowZeroGaps = false, omitOriginalStartEnd = false) {\n        (0, event_1.sortEvents)(events);\n        const activeInstances = {};\n        let activeInstanceId = null;\n        let previousActive = false;\n        const negativeInstances = {};\n        let previousNegative = false;\n        let negativeInstanceId = null;\n        const returnInstances = [];\n        for (let i = 0; i < events.length; i++) {\n            const event = events[i];\n            const eventId = event.data.id ?? event.data.instance.id;\n            const lastInstance = returnInstances[returnInstances.length - 1];\n            if (event.value) {\n                // Start-event\n                activeInstances[eventId] = event;\n                delete negativeInstances[eventId];\n            }\n            else {\n                // End-event\n                delete activeInstances[eventId];\n                negativeInstances[eventId] = event;\n            }\n            if (Object.keys(activeInstances).length) {\n                // There is an active instance\n                if (!allowMerge && !allowZeroGaps && lastInstance && previousNegative) {\n                    // There is previously an inActive (negative) instance\n                    lastInstance.start = event.time;\n                }\n                else {\n                    const o = this.handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps);\n                    activeInstanceId = o.activeInstanceId;\n                    if (o.returnInstance) {\n                        let newInstance = o.returnInstance;\n                        if (omitOriginalStartEnd) {\n                            newInstance = { ...newInstance };\n                            newInstance.originalStart = undefined;\n                            newInstance.originalEnd = undefined;\n                        }\n                        returnInstances.push(newInstance);\n                    }\n                }\n                previousActive = true;\n                previousNegative = false;\n            }\n            else {\n                // No instances are active\n                if (lastInstance && previousActive) {\n                    lastInstance.end = event.time;\n                }\n                else if (Object.keys(negativeInstances).length && !event.data.notANegativeInstance) {\n                    // There is a negative instance running\n                    const o = this.handleActiveInstances(event, lastInstance, negativeInstanceId, eventId, negativeInstances, allowMerge, allowZeroGaps);\n                    negativeInstanceId = o.activeInstanceId;\n                    if (o.returnInstance) {\n                        const newInstance = {\n                            ...o.returnInstance,\n                            start: o.returnInstance.end ?? 0,\n                            end: o.returnInstance.start,\n                        };\n                        if (omitOriginalStartEnd) {\n                            newInstance.originalStart = undefined;\n                            newInstance.originalEnd = undefined;\n                        }\n                        returnInstances.push(newInstance);\n                    }\n                    previousNegative = true;\n                }\n                previousActive = false;\n            }\n        }\n        for (const instance of returnInstances) {\n            if (instance.end !== null && instance.end < instance.start) {\n                // Don't allow negative durations, set it to zero instead:\n                instance.end = instance.start;\n            }\n        }\n        return returnInstances;\n    }\n    handleActiveInstances(event, lastInstance, activeInstanceId, eventId, activeInstances, allowMerge, allowZeroGaps = false) {\n        let returnInstance = null;\n        if (!allowMerge &&\n            event.value &&\n            lastInstance &&\n            lastInstance.end === null &&\n            activeInstanceId !== null &&\n            activeInstanceId !== eventId) {\n            // Start a new instance:\n            lastInstance.end = event.time;\n            returnInstance = {\n                id: this.resolvedTimeline.getInstanceId(),\n                start: event.time,\n                end: null,\n                references: event.references,\n                originalEnd: event.data.instance.originalEnd,\n                originalStart: event.data.instance.originalStart,\n            };\n            activeInstanceId = eventId;\n        }\n        else if (!allowMerge && !event.value && lastInstance && activeInstanceId === eventId) {\n            // The active instance stopped playing, but another is still playing\n            const latestInstance = (0, lib_1.reduceObj)(activeInstances, (memo, instanceEvent, id) => {\n                if (memo === null || memo.event.time < instanceEvent.time) {\n                    return {\n                        event: instanceEvent,\n                        id: id,\n                    };\n                }\n                return memo;\n            }, null);\n            if (latestInstance) {\n                // Restart that instance now:\n                lastInstance.end = event.time;\n                returnInstance = {\n                    id: (0, instance_1.isInstanceId)(eventId)\n                        ? `${eventId}_${this.resolvedTimeline.getInstanceId()}`\n                        : `@${eventId}_${this.resolvedTimeline.getInstanceId()}`,\n                    start: event.time,\n                    end: null,\n                    references: latestInstance.event.references,\n                    originalEnd: event.data.instance.originalEnd,\n                    originalStart: event.data.instance.originalStart,\n                };\n                activeInstanceId = latestInstance.id;\n            }\n        }\n        else if (allowMerge && !allowZeroGaps && lastInstance && lastInstance.end === event.time) {\n            // The previously running ended just now\n            // resume previous instance:\n            lastInstance.end = null;\n            lastInstance.references = (0, reference_1.joinReferences)(lastInstance.references, event.references);\n            (0, cap_1.addCapsToResuming)(lastInstance, event.data.instance.caps);\n        }\n        else if (!lastInstance || lastInstance.end !== null) {\n            // There is no previously running instance\n            // Start a new instance:\n            returnInstance = {\n                id: (0, instance_1.isInstanceId)(eventId) ? eventId : `@${eventId}`,\n                start: event.time,\n                end: null,\n                references: event.references,\n                caps: event.data.instance.caps,\n                originalEnd: event.data.instance.originalEnd,\n                originalStart: event.data.instance.originalStart,\n            };\n            activeInstanceId = eventId;\n        }\n        else {\n            // There is already a running instance\n            lastInstance.references = (0, reference_1.joinReferences)(lastInstance.references, event.references);\n            (0, cap_1.addCapsToResuming)(lastInstance, event.data.instance.caps);\n        }\n        if (lastInstance?.caps && !lastInstance.caps.length)\n            delete lastInstance.caps;\n        if (returnInstance &&\n            lastInstance &&\n            lastInstance.start === lastInstance.end &&\n            lastInstance.end === returnInstance.start) {\n            // replace the previous zero-length with this one instead\n            lastInstance.id = returnInstance.id;\n            lastInstance.start = returnInstance.start;\n            lastInstance.end = returnInstance.end;\n            lastInstance.references = returnInstance.references;\n            lastInstance.caps = returnInstance.caps;\n            lastInstance.originalStart = returnInstance.originalStart;\n            lastInstance.originalEnd = returnInstance.originalEnd;\n            returnInstance = null;\n        }\n        return {\n            activeInstanceId,\n            returnInstance,\n        };\n    }\n    /**\n     * Clean up instances, join overlapping etc..\n     * @param instances\n     */\n    cleanInstances(instances, allowMerge, allowZeroGaps = false) {\n        // First, optimize for certain common situations:\n        if (instances.length === 0)\n            return [];\n        if (instances.length === 1)\n            return instances;\n        const events = [];\n        for (const instance of instances) {\n            events.push({\n                time: instance.start,\n                value: true,\n                data: { instance: instance },\n                references: instance.references,\n            });\n            if (instance.end !== null) {\n                events.push({\n                    time: instance.end,\n                    value: false,\n                    data: { instance: instance },\n                    references: instance.references,\n                });\n            }\n        }\n        return this.convertEventsToInstances(events, allowMerge, allowZeroGaps);\n    }\n    /**\n     * Cap instances so that they are within their parentInstances\n     * @param instances\n     * @param cappingInstances\n     */\n    capInstances(instances, cappingInstances, allowZeroGaps = true) {\n        if ((0, reference_1.isReference)(cappingInstances) || cappingInstances === null)\n            return instances;\n        let returnInstances = [];\n        for (let i = 0; i < instances.length; i++) {\n            const instanceOrg = instances[i];\n            const addedInstanceTimes = new Set();\n            for (let j = 0; j < cappingInstances.length; j++) {\n                const capInstance = cappingInstances[j];\n                // First, check if the instance crosses the parent at all:\n                if (instanceOrg.start <= (capInstance.end ?? Infinity) &&\n                    (instanceOrg.end ?? Infinity) >= capInstance.start) {\n                    const instance = this.capInstance(instanceOrg, capInstance);\n                    if (instance.start >= capInstance.start &&\n                        (instance.end ?? Infinity) <= (capInstance.end ?? Infinity)) {\n                        // The instance is within the parent\n                        if (instance.start === instance.end && addedInstanceTimes.has(instance.start)) {\n                            // Don't add zero-length instances if there are already is instances covering that time\n                        }\n                        else {\n                            instance.references = (0, reference_1.joinReferences)(instance.references, capInstance.references);\n                            returnInstances.push(instance);\n                            addedInstanceTimes.add(instance.start);\n                            if (instance.end)\n                                addedInstanceTimes.add(instance.end);\n                        }\n                    }\n                }\n            }\n        }\n        returnInstances.sort((a, b) => a.start - b.start);\n        // Ensure unique ids:\n        const ids = {};\n        for (const instance of returnInstances) {\n            // tslint:disable-next-line\n            if (ids[instance.id] !== undefined) {\n                instance.id = `${instance.id}${++ids[instance.id]}`;\n            }\n            else {\n                ids[instance.id] = 0;\n            }\n        }\n        // Clean up the instances, to remove duplicates\n        returnInstances = this.cleanInstances(returnInstances, true, allowZeroGaps);\n        return returnInstances;\n    }\n    capInstance(instanceOrg, capInstance) {\n        const instance = { ...instanceOrg };\n        // Cap start\n        if (instance.start < capInstance.start) {\n            this.setInstanceStartTime(instance, capInstance.start);\n        }\n        // Cap end\n        if ((instance.end ?? Infinity) > (capInstance.end ?? Infinity)) {\n            this.setInstanceEndTime(instance, capInstance.end);\n        }\n        return instance;\n    }\n    setInstanceEndTime(instance, endTime) {\n        instance.originalEnd = instance.originalEnd ?? instance.end;\n        instance.end = endTime;\n    }\n    setInstanceStartTime(instance, startTime) {\n        instance.originalStart = instance.originalStart ?? instance.start;\n        instance.start = startTime;\n    }\n    applyRepeatingInstances(instances, repeatTime0) {\n        if (repeatTime0 === null || !repeatTime0.value)\n            return instances;\n        const options = this.resolvedTimeline.options;\n        const repeatTime = repeatTime0.value;\n        const repeatedInstances = [];\n        for (const instance of instances) {\n            let startTime = Math.max(options.time - ((options.time - instance.start) % repeatTime), instance.start);\n            let endTime = instance.end === null ? null : instance.end + (startTime - instance.start);\n            const cap = (instance.caps\n                ? instance.caps.find((cap) => instance.references.indexOf(`@${cap.id}`) !== -1)\n                : null) ?? null;\n            const limit = options.limitCount ?? 2;\n            for (let i = 0; i < limit; i++) {\n                if (options.limitTime && startTime >= options.limitTime)\n                    break;\n                const cappedStartTime = cap ? Math.max(cap.start, startTime) : startTime;\n                const cappedEndTime = cap && cap.end !== null && endTime !== null ? Math.min(cap.end, endTime) : endTime;\n                if ((cappedEndTime ?? Infinity) > cappedStartTime) {\n                    repeatedInstances.push({\n                        id: this.resolvedTimeline.getInstanceId(),\n                        start: cappedStartTime,\n                        end: cappedEndTime,\n                        references: (0, reference_1.joinReferences)(instance.references, repeatTime0.references, `@${instance.id}`),\n                    });\n                }\n                startTime += repeatTime;\n                if (endTime !== null)\n                    endTime += repeatTime;\n            }\n        }\n        return this.cleanInstances(repeatedInstances, false);\n    }\n}\nexports.InstanceHandler = InstanceHandler;\n//# sourceMappingURL=InstanceHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LayerStateHandler = void 0;\nconst lib_1 = require(\"./lib/lib\");\nconst performance_1 = require(\"./lib/performance\");\n/**\n * LayerStateHandler instances are short-lived.\n * They are initialized, .resolveConflicts() is called and then discarded\n */\nclass LayerStateHandler {\n    constructor(resolvedTimeline, instance, layer) {\n        this.resolvedTimeline = resolvedTimeline;\n        this.instance = instance;\n        this.layer = layer;\n        this.pointsInTime = {};\n        this.objectsOnLayer = [];\n        this.objectIdsOnLayer = this.resolvedTimeline.getLayerObjects(layer);\n    }\n    debug(...args) {\n        if (this.resolvedTimeline.options.debug)\n            console.log(...args);\n    }\n    /** Resolve conflicts between objects on the layer. */\n    resolveConflicts() {\n        const toc = (0, performance_1.tic)('       resolveConflicts');\n        /*\n            This algoritm basically works like this:\n\n            1. Collect all instances start- and end-times as points-of-interest\n            2. Sweep through the points-of-interest and determine which instance is the \"winning one\" at every point in time\n        */\n        // Populate this.objectsOnLayer:\n        for (const objId of this.objectIdsOnLayer) {\n            this.objectsOnLayer.push(this.resolvedTimeline.getObject(objId));\n        }\n        // Fast-path: if there's only one object on the layer, it can't conflict with anything\n        if (this.objectsOnLayer.length === 1) {\n            for (const obj of this.objectsOnLayer) {\n                obj.resolved.resolvedConflicts = true;\n                for (const instance of obj.resolved.instances) {\n                    instance.originalStart = instance.originalStart ?? instance.start;\n                    instance.originalEnd = instance.originalEnd ?? instance.end;\n                }\n            }\n            return;\n        }\n        this.debug(`======= resolveConflicts \"${this.layer}\" (${this.objectsOnLayer.length} objects)`);\n        // Sort to make sure parent groups are evaluated before their children:\n        this.objectsOnLayer.sort(compareObjectsOnLayer);\n        // Step 1: Collect all points-of-interest (which points in time we want to evaluate)\n        // and which instances that are interesting\n        for (const obj of this.objectsOnLayer) {\n            // Notes:\n            // Since keyframes can't be placed on a layer, we assume that the object is not a keyframe\n            // We also assume that the object has a layer\n            for (const instance of obj.resolved.instances) {\n                const timeEvents = [];\n                timeEvents.push({ time: instance.start, enable: true });\n                if (instance.end)\n                    timeEvents.push({ time: instance.end, enable: false });\n                // Save a reference to this instance on all points in time that could affect it:\n                for (const timeEvent of timeEvents) {\n                    if (timeEvent.enable) {\n                        this.addPointInTime(timeEvent.time, 'start', obj, instance);\n                    }\n                    else {\n                        this.addPointInTime(timeEvent.time, 'end', obj, instance);\n                    }\n                }\n            }\n            obj.resolved.resolvedConflicts = true;\n            obj.resolved.instances.splice(0); // clear the instances, so new instances can be re-added later\n        }\n        // Step 2: Resolve the state for the points-of-interest\n        // This is done by sweeping the points-of-interest chronologically,\n        // determining the state for every point in time by adding & removing objects from aspiringInstances\n        // Then sorting it to determine who takes precedence\n        let currentState = undefined;\n        const activeObjIds = {};\n        /** The objects in aspiringInstances  */\n        let aspiringInstances = [];\n        const times = Object.keys(this.pointsInTime)\n            .map((time) => parseFloat(time))\n            // Sort chronologically:\n            .sort((a, b) => a - b);\n        // Iterate through all points-of-interest times:\n        for (const time of times) {\n            this.debug(`-------------- time: ${time}`);\n            /** A set of identifiers for which instance-events have been check at this point in time. Used to avoid looking at the same object twice. */\n            const checkedThisTime = new Set();\n            /** List of the instances to check at this point in time. */\n            const instancesToCheck = this.pointsInTime[time];\n            instancesToCheck.sort(compareInstancesToCheck);\n            for (let j = 0; j < instancesToCheck.length; j++) {\n                const o = instancesToCheck[j];\n                const obj = o.obj;\n                const instance = o.instance;\n                let toBeEnabled;\n                if (instance.start === time && instance.end === time) {\n                    // Handle zero-length instances:\n                    if (o.instanceEvent === 'start')\n                        toBeEnabled = true; // Start a zero-length instance\n                    else\n                        toBeEnabled = false; // End a zero-length instance\n                }\n                else {\n                    toBeEnabled = (instance.start || 0) <= time && (instance.end ?? Infinity) > time;\n                }\n                const identifier = `${obj.id}_${instance.id}_${o.instanceEvent}`;\n                if (!checkedThisTime.has(identifier)) {\n                    // Only check each object and event-type once for every point in time\n                    checkedThisTime.add(identifier);\n                    if (toBeEnabled) {\n                        // The instance wants to be enabled (is starting)\n                        // Add to aspiringInstances:\n                        aspiringInstances.push({ obj, instance });\n                    }\n                    else {\n                        // The instance doesn't want to be enabled (is ending)\n                        // Remove from aspiringInstances:\n                        aspiringInstances = removeFromAspiringInstances(aspiringInstances, obj.id);\n                    }\n                    // Sort the instances on layer to determine who is the active one:\n                    aspiringInstances.sort(compareAspiringInstances);\n                    // At this point, the first instance in aspiringInstances is the active one.\n                    const instanceOnTopOfLayer = aspiringInstances[0];\n                    // Update current state:\n                    const prevObjInstance = currentState;\n                    const replaceOld = instanceOnTopOfLayer &&\n                        (!prevObjInstance ||\n                            prevObjInstance.id !== instanceOnTopOfLayer.obj.id ||\n                            !prevObjInstance.instance.id.startsWith(`${instanceOnTopOfLayer.instance.id}`));\n                    const removeOld = !instanceOnTopOfLayer && prevObjInstance;\n                    if (replaceOld || removeOld) {\n                        if (prevObjInstance) {\n                            // Cap the old instance, so it'll end at this point in time:\n                            this.instance.setInstanceEndTime(prevObjInstance.instance, time);\n                            this.debug(`${prevObjInstance.id} stop`);\n                            // Update activeObjIds:\n                            delete activeObjIds[prevObjInstance.id];\n                        }\n                    }\n                    if (replaceOld) {\n                        // Set the new objectInstance to be the current one:\n                        const currentObj = instanceOnTopOfLayer.obj;\n                        this.debug(`${currentObj.id} play`);\n                        const newInstance = {\n                            ...instanceOnTopOfLayer.instance,\n                            // We're setting new start & end times so they match up with the state:\n                            start: time,\n                            end: null,\n                            fromInstanceId: instanceOnTopOfLayer.instance.id,\n                            originalEnd: instanceOnTopOfLayer.instance.originalEnd ?? instanceOnTopOfLayer.instance.end,\n                            originalStart: instanceOnTopOfLayer.instance.originalStart ?? instanceOnTopOfLayer.instance.start,\n                        };\n                        // Make the instance id unique:\n                        for (let i = 0; i < currentObj.resolved.instances.length; i++) {\n                            if (currentObj.resolved.instances[i].id === newInstance.id) {\n                                newInstance.id = `${newInstance.id}_$${currentObj.resolved.instances.length}`;\n                            }\n                        }\n                        currentObj.resolved.instances.push(newInstance);\n                        const newObjInstance = {\n                            ...currentObj,\n                            instance: newInstance,\n                        };\n                        // Save to current state:\n                        currentState = newObjInstance;\n                        // Update activeObjIds:\n                        activeObjIds[newObjInstance.id] = newObjInstance;\n                    }\n                    else if (removeOld) {\n                        // Remove from current state:\n                        currentState = undefined;\n                    }\n                }\n            }\n        }\n        // At this point, the instances of all objects are calculated,\n        // taking into account priorities, clashes etc.\n        // Cap children inside their parents:\n        // Functionally, this isn't needed since this is done in ResolvedTimelineHandler.resolveTimelineObj() anyway.\n        // However by capping children here some re-evaluating iterations can be avoided, so this increases performance.\n        {\n            const allChildren = this.objectsOnLayer\n                .filter((obj) => !!obj.resolved.parentId)\n                // Sort, so that the outermost are handled first:\n                .sort((a, b) => {\n                return a.resolved.levelDeep - b.resolved.levelDeep;\n            });\n            for (const obj of allChildren) {\n                if (obj.resolved.parentId) {\n                    const parent = this.resolvedTimeline.getObject(obj.resolved.parentId);\n                    if (parent) {\n                        obj.resolved.instances = this.instance.cleanInstances(this.instance.capInstances(obj.resolved.instances, parent.resolved.instances), false, false);\n                    }\n                }\n            }\n        }\n        this.debug('==== resolveConflicts done');\n        toc();\n    }\n    /** Add an instance and event to a certain point-in-time */\n    addPointInTime(time, instanceEvent, obj, instance) {\n        // Note on order: Ending events come before starting events\n        this.debug('addPointInTime', time, instanceEvent, instance);\n        if (!this.pointsInTime[time + ''])\n            this.pointsInTime[time + ''] = [];\n        this.pointsInTime[time + ''].push({ obj, instance, instanceEvent });\n    }\n}\nexports.LayerStateHandler = LayerStateHandler;\nfunction compareObjectsOnLayer(a, b) {\n    // Sort to make sure parent groups are evaluated before their children:\n    return a.resolved.levelDeep - b.resolved.levelDeep || (0, lib_1.compareStrings)(a.id, b.id);\n}\nfunction compareInstancesToCheck(a, b) {\n    // Note: we assume that there are no keyframes here. (if there where, they would be sorted first)\n    if (a.instance.id === b.instance.id && a.instance.start === b.instance.start && a.instance.end === b.instance.end) {\n        // A & B are the same instance, it is a zero-length instance!\n        // In this case, put the start before the end:\n        if (a.instanceEvent === 'start' && b.instanceEvent === 'end')\n            return -1;\n        if (a.instanceEvent === 'end' && b.instanceEvent === 'start')\n            return 1;\n    }\n    // Handle ending instances first:\n    if (a.instanceEvent === 'start' && b.instanceEvent === 'end')\n        return 1;\n    if (a.instanceEvent === 'end' && b.instanceEvent === 'start')\n        return -1;\n    if (a.instance.start === a.instance.end || b.instance.start === b.instance.end) {\n        // Put later-ending instances last (in the case of zero-length vs non-zero-length instance):\n        const difference = (a.instance.end ?? Infinity) - (b.instance.end ?? Infinity);\n        if (difference)\n            return difference;\n    }\n    if (a.obj.resolved && b.obj.resolved) {\n        // Deeper objects (children in groups) comes later, we want to check the parent groups first:\n        const difference = a.obj.resolved.levelDeep - b.obj.resolved.levelDeep;\n        if (difference)\n            return difference;\n    }\n    // Last resort, sort by id to make it deterministic:\n    return (0, lib_1.compareStrings)(a.obj.id, b.obj.id) || (0, lib_1.compareStrings)(a.instance.id, b.instance.id);\n}\nconst removeFromAspiringInstances = (aspiringInstances, objId) => {\n    const returnInstances = [];\n    for (let i = 0; i < aspiringInstances.length; i++) {\n        if (aspiringInstances[i].obj.id !== objId)\n            returnInstances.push(aspiringInstances[i]);\n    }\n    return returnInstances;\n};\nfunction compareAspiringInstances(a, b) {\n    // Determine who takes precedence:\n    return ((b.obj.priority || 0) - (a.obj.priority || 0) || // First, sort using priority\n        b.instance.start - a.instance.start || // Then, sort using the start time\n        (0, lib_1.compareStrings)(a.obj.id, b.obj.id) || // Last resort, sort by id to make it deterministic\n        (0, lib_1.compareStrings)(a.instance.id, b.instance.id));\n}\n//# sourceMappingURL=LayerStateHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReferenceHandler = void 0;\nconst lib_1 = require(\"./lib/lib\");\nconst cap_1 = require(\"./lib/cap\");\nconst event_1 = require(\"./lib/event\");\nconst reference_1 = require(\"./lib/reference\");\nconst expression_1 = require(\"./lib/expression\");\nclass ReferenceHandler {\n    constructor(resolvedTimeline, instance) {\n        this.resolvedTimeline = resolvedTimeline;\n        this.instance = instance;\n        this.operateApplyParentInstance = (a, b) => {\n            if (a === null || b === null)\n                return null;\n            return {\n                value: a.value + b.value,\n                references: (0, reference_1.joinReferences)(a.references, b.references),\n            };\n        };\n    }\n    /**\n     * Look up a reference on the timeline\n     * Return values:\n     * TimelineObjectInstance[]: Instances on the timeline where the reference expression is true\n     * ValueWithReference: A singular value which can be combined arithmetically with Instances\n     * null: Means \"something is invalid\", an null-value will always return null when combined with other values\n     *\n     * @param obj\n     * @param expr\n     * @param context\n     */\n    lookupExpression(obj, expr, context) {\n        if (expr === null)\n            return { result: null, allReferences: [] };\n        if (typeof expr === 'string' && (0, expression_1.isNumericExpr)(expr)) {\n            return {\n                result: {\n                    value: parseFloat(expr),\n                    references: [],\n                },\n                allReferences: [],\n            };\n        }\n        else if (typeof expr === 'number') {\n            return {\n                result: {\n                    value: expr,\n                    references: [],\n                },\n                allReferences: [],\n            };\n        }\n        else if (typeof expr === 'string') {\n            expr = expr.trim();\n            const exprLower = expr.toLowerCase();\n            if (exprLower === 'true') {\n                return {\n                    result: {\n                        value: 0,\n                        references: [],\n                    },\n                    allReferences: [],\n                };\n            }\n            else if (exprLower === 'false') {\n                return {\n                    result: null,\n                    allReferences: [],\n                };\n            }\n            // Look up string\n            let referencedObjs = [];\n            let ref = context;\n            let rest = '';\n            let objIdsToReference = [];\n            const allReferences = [];\n            let referenceIsOk = false;\n            // Match id, example: \"#objectId.start\"\n            const m = /^\\W*#([^.]+)(.*)/.exec(expr);\n            if (m) {\n                const id = m[1];\n                rest = m[2];\n                referenceIsOk = true;\n                objIdsToReference = [id];\n                allReferences.push(`#${id}`);\n            }\n            else {\n                // Match class, example: \".className.start\"\n                const m = /^\\W*\\.([^.]+)(.*)/.exec(expr);\n                if (m) {\n                    const className = m[1];\n                    rest = m[2];\n                    referenceIsOk = true;\n                    objIdsToReference = this.resolvedTimeline.getClassObjects(className) ?? [];\n                    allReferences.push(`.${className}`);\n                }\n                else {\n                    // Match layer, example: \"$layer\"\n                    const m = /^\\W*\\$([^.]+)(.*)/.exec(expr);\n                    if (m) {\n                        const layer = m[1];\n                        rest = m[2];\n                        referenceIsOk = true;\n                        objIdsToReference = this.resolvedTimeline.getLayerObjects(layer) ?? [];\n                        allReferences.push(`$${layer}`);\n                    }\n                }\n            }\n            for (let i = 0; i < objIdsToReference.length; i++) {\n                const refObjId = objIdsToReference[i];\n                if (refObjId === obj.id) {\n                    // Looks like the object is referencing itself!\n                    if (obj.resolved.resolving) {\n                        obj.resolved.isSelfReferencing = true;\n                    }\n                }\n                else {\n                    const refObj = this.resolvedTimeline.getObject(refObjId);\n                    if (refObj)\n                        referencedObjs.push(refObj);\n                }\n            }\n            if (!referenceIsOk) {\n                return { result: null, allReferences: [] };\n            }\n            if (obj.resolved.isSelfReferencing) {\n                // Exclude any self-referencing objects:\n                referencedObjs = referencedObjs.filter((refObj) => {\n                    return !refObj.resolved.isSelfReferencing;\n                });\n            }\n            if (referencedObjs.length) {\n                if (/start/.exec(rest))\n                    ref = 'start';\n                else if (/end/.exec(rest))\n                    ref = 'end';\n                else if (/duration/.exec(rest))\n                    ref = 'duration';\n                if (ref === 'duration') {\n                    // Duration refers to the first object on the resolved timeline\n                    return this.lookupReferencedObjsDuration(obj, referencedObjs, allReferences);\n                }\n                else if (ref === 'start') {\n                    return this.lookupReferencedObjs(obj, referencedObjs, allReferences, false, false);\n                }\n                else if (ref === 'end') {\n                    return this.lookupReferencedObjs(obj, referencedObjs, allReferences, true, true);\n                }\n                else {\n                    /* istanbul ignore next */\n                    (0, lib_1.assertNever)(ref);\n                }\n            }\n            return { result: [], allReferences: allReferences };\n        }\n        else if (!expr) {\n            return { result: null, allReferences: [] };\n        }\n        else {\n            // expr is an expressionObj\n            return this.lookupExpressionObj(obj, context, expr);\n        }\n    }\n    applyParentInstances(parentInstances, value) {\n        return this.operateOnArrays(parentInstances, value, this.operateApplyParentInstance);\n    }\n    /**\n     * Perform an action on 2 arrays. Behaves somewhat like the \".*\"-operator in Matlab\n     * @param array0\n     * @param array1\n     * @param operate\n     */\n    operateOnArrays(array0, array1, operate) {\n        if (array0 === null || array1 === null)\n            return null;\n        if ((0, reference_1.isReference)(array0) && (0, reference_1.isReference)(array1)) {\n            return operate(array0, array1);\n        }\n        const result = [];\n        const minLength = Math.min((0, lib_1.isArray)(array0) ? array0.length : Infinity, (0, lib_1.isArray)(array1) ? array1.length : Infinity);\n        for (let i = 0; i < minLength; i++) {\n            const a = (0, lib_1.isArray)(array0)\n                ? array0[i]\n                : { id: '@', start: array0.value, end: array0.value, references: array0.references };\n            const b = (0, lib_1.isArray)(array1)\n                ? array1[i]\n                : { id: '@', start: array1.value, end: array1.value, references: array1.references };\n            const start = a.isFirst\n                ? { value: a.start, references: a.references }\n                : b.isFirst\n                    ? { value: b.start, references: b.references }\n                    : operate({ value: a.start, references: (0, reference_1.joinReferences)(a.references, a.id === '@' ? [] : `@${a.id}`) }, { value: b.start, references: (0, reference_1.joinReferences)(b.references, b.id === '@' ? [] : `@${b.id}`) });\n            const end = a.isFirst\n                ? a.end !== null\n                    ? { value: a.end, references: a.references }\n                    : null\n                : b.isFirst\n                    ? b.end !== null\n                        ? { value: b.end, references: b.references }\n                        : null\n                    : operate(a.end !== null\n                        ? {\n                            value: a.end,\n                            references: (0, reference_1.joinReferences)(a.references, a.id === '@' ? [] : `@${a.id}`),\n                        }\n                        : null, b.end !== null\n                        ? {\n                            value: b.end,\n                            references: (0, reference_1.joinReferences)(b.references, b.id === '@' ? [] : `@${b.id}`),\n                        }\n                        : null);\n            if (start !== null) {\n                result.push({\n                    id: this.resolvedTimeline.getInstanceId(),\n                    start: start.value,\n                    end: end === null ? null : end.value,\n                    references: (0, reference_1.joinReferences)(start.references, end !== null ? end.references : []),\n                    caps: (0, cap_1.joinCaps)(a.caps, b.caps),\n                });\n            }\n        }\n        return this.instance.cleanInstances(result, false);\n    }\n    /**\n     * Look up the referenced objects (in the context of a duration-reference)\n     */\n    lookupReferencedObjsDuration(obj, referencedObjs, allReferences) {\n        const instanceDurations = [];\n        for (let i = 0; i < referencedObjs.length; i++) {\n            const referencedObj = referencedObjs[i];\n            // Ensure that the referenced object is resolved.\n            // Note: This is where referenced object(s) are recursively resolved\n            this.resolvedTimeline.resolveTimelineObj(referencedObj);\n            if (referencedObj.resolved.resolvedReferences) {\n                if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                    // If the querying object is self-referencing, exclude any other self-referencing objects,\n                    // ignore the object\n                }\n                else {\n                    const firstInstance = referencedObj.resolved.instances[0];\n                    if (firstInstance) {\n                        const duration = firstInstance.end !== null ? firstInstance.end - firstInstance.start : null;\n                        if (duration !== null) {\n                            instanceDurations.push({\n                                value: duration,\n                                references: (0, reference_1.joinReferences)([`#${referencedObj.id}`], firstInstance.references),\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        let firstDuration = null;\n        for (let i = 0; i < instanceDurations.length; i++) {\n            const d = instanceDurations[i];\n            if (firstDuration === null || d.value < firstDuration.value)\n                firstDuration = d;\n        }\n        return { result: firstDuration, allReferences: allReferences };\n    }\n    /**\n     * Look up the referenced objects\n     */\n    lookupReferencedObjs(obj, referencedObjs, allReferences, invert, ignoreFirstIfZero) {\n        let referencedInstances = [];\n        for (let i = 0; i < referencedObjs.length; i++) {\n            const referencedObj = referencedObjs[i];\n            // Ensure that the referenced object is resolved.\n            // Note: This is where referenced object(s) are recursively resolved\n            this.resolvedTimeline.resolveTimelineObj(referencedObj);\n            if (referencedObj.resolved.resolvedReferences) {\n                if (obj.resolved.isSelfReferencing && referencedObj.resolved.isSelfReferencing) {\n                    // If the querying object is self-referencing, exclude any other self-referencing objects,\n                    // ignore the object\n                }\n                else {\n                    referencedInstances = referencedInstances.concat(referencedObj.resolved.instances);\n                }\n            }\n        }\n        if (referencedInstances.length) {\n            if (invert) {\n                referencedInstances = this.instance.invertInstances(referencedInstances);\n            }\n            else {\n                referencedInstances = this.instance.cleanInstances(referencedInstances, true, true);\n            }\n            if (ignoreFirstIfZero) {\n                const first = referencedInstances[0];\n                if (first && first.start === 0) {\n                    referencedInstances.splice(0, 1);\n                }\n            }\n            return { result: referencedInstances, allReferences: allReferences };\n        }\n        else {\n            return { result: [], allReferences: allReferences };\n        }\n    }\n    /**\n     * Look up an ExpressionObj\n     */\n    lookupExpressionObj(obj, context, expr) {\n        const l = this.lookupExpression(obj, expr.l, context);\n        const r = this.lookupExpression(obj, expr.r, context);\n        const lookupExpr = {\n            l: l.result,\n            o: expr.o,\n            r: r.result,\n        };\n        const allReferences = l.allReferences.concat(r.allReferences);\n        if (lookupExpr.o === '!') {\n            // Invert, ie discard l, invert and return r:\n            if (lookupExpr.r && (0, lib_1.isArray)(lookupExpr.r)) {\n                return {\n                    result: this.instance.invertInstances(lookupExpr.r),\n                    allReferences: allReferences,\n                };\n            }\n            else {\n                // We can't invert a value\n                return {\n                    result: lookupExpr.r,\n                    allReferences: allReferences,\n                };\n            }\n        }\n        else if (lookupExpr.l === null || lookupExpr.r === null) {\n            return { result: null, allReferences: allReferences };\n        }\n        else if (lookupExpr.o === '&' || lookupExpr.o === '|') {\n            const combiner = new ReferenceAndOrCombiner(this.resolvedTimeline, lookupExpr.l, lookupExpr.r, lookupExpr.o);\n            const instances = combiner.calculateResult();\n            return { result: instances, allReferences: allReferences };\n        }\n        else {\n            const operate = Operators.get(lookupExpr.o);\n            const result = this.operateOnArrays(lookupExpr.l, lookupExpr.r, operate);\n            return { result: result, allReferences: allReferences };\n        }\n    }\n}\nexports.ReferenceHandler = ReferenceHandler;\n/** Helper class that deals with an And ('&') or an Or ('|') expression */\nclass ReferenceAndOrCombiner {\n    constructor(resolvedTimeline, leftOperand, rightOperand, operator) {\n        this.resolvedTimeline = resolvedTimeline;\n        this.leftOperand = leftOperand;\n        this.rightOperand = rightOperand;\n        this.events = [];\n        this.instances = [];\n        if (operator === '&') {\n            this.calcResult = (left, right) => !!(left && right);\n        }\n        else if (operator === '|') {\n            this.calcResult = (left, right) => !!(left || right);\n        }\n        else {\n            /* istanbul ignore next */\n            (0, lib_1.assertNever)(operator);\n            /* istanbul ignore next */\n            this.calcResult = () => false;\n        }\n        if ((0, lib_1.isArray)(leftOperand))\n            this._addInstanceEvents(leftOperand, true);\n        if ((0, lib_1.isArray)(rightOperand))\n            this._addInstanceEvents(rightOperand, false);\n        this.events = (0, event_1.sortEvents)(this.events);\n    }\n    _addInstanceEvents(instances, left) {\n        for (let i = 0; i < instances.length; i++) {\n            const instance = instances[i];\n            if (instance.start !== instance.end) {\n                // event doesn't actually exist...\n                this.events.push({\n                    left: left,\n                    time: instance.start,\n                    value: true,\n                    references: [],\n                    data: true,\n                    instance: instance,\n                });\n                if (instance.end !== null) {\n                    this.events.push({\n                        left: left,\n                        time: instance.end,\n                        value: false,\n                        references: [],\n                        data: false,\n                        instance: instance,\n                    });\n                }\n            }\n        }\n    }\n    calculateResult() {\n        let leftValue = (0, reference_1.isReference)(this.leftOperand) ? !!this.leftOperand.value : false;\n        let rightValue = (0, reference_1.isReference)(this.rightOperand) ? !!this.rightOperand.value : false;\n        let leftInstance = null;\n        let rightInstance = null;\n        let resultValue = this.calcResult(leftValue, rightValue);\n        this.updateInstance(0, resultValue, (0, reference_1.joinReferences)((0, reference_1.isReference)(this.leftOperand) ? this.leftOperand.references : [], (0, reference_1.isReference)(this.rightOperand) ? this.rightOperand.references : []), []);\n        for (let i = 0; i < this.events.length; i++) {\n            const e = this.events[i];\n            const next = this.events[i + 1];\n            if (e.left) {\n                leftValue = e.value;\n                leftInstance = e.instance;\n            }\n            else {\n                rightValue = e.value;\n                rightInstance = e.instance;\n            }\n            if (!next || next.time !== e.time) {\n                const newResultValue = this.calcResult(leftValue, rightValue);\n                const resultCaps = (leftInstance ? leftInstance.caps ?? [] : []).concat(rightInstance ? rightInstance.caps ?? [] : []);\n                if (newResultValue !== resultValue) {\n                    this.updateInstance(e.time, newResultValue, (0, reference_1.joinReferences)(leftInstance ? leftInstance.references : [], rightInstance ? rightInstance.references : []), resultCaps);\n                    resultValue = newResultValue;\n                }\n            }\n        }\n        return this.instances;\n    }\n    updateInstance(time, value, references, caps) {\n        if (value) {\n            this.instances.push({\n                id: this.resolvedTimeline.getInstanceId(),\n                start: time,\n                end: null,\n                references: references,\n                caps: caps,\n            });\n        }\n        else {\n            const lastInstance = (0, lib_1.last)(this.instances);\n            if (lastInstance) {\n                lastInstance.end = time;\n                // don't update reference on end\n            }\n        }\n    }\n}\n/** Helper class for various operators */\nclass Operators {\n    static get(operator) {\n        switch (operator) {\n            case '+':\n                return Operators.Add;\n            case '-':\n                return Operators.Subtract;\n            case '*':\n                return Operators.Multiply;\n            case '/':\n                return Operators.Divide;\n            case '%':\n                return Operators.Modulo;\n            default: {\n                (0, lib_1.assertNever)(operator);\n                return Operators.Null;\n            }\n        }\n    }\n}\nOperators.Add = (a, b) => {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value + b.value,\n        references: (0, reference_1.joinReferences)(a.references, b.references),\n    };\n};\nOperators.Subtract = (a, b) => {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value - b.value,\n        references: (0, reference_1.joinReferences)(a.references, b.references),\n    };\n};\nOperators.Multiply = (a, b) => {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value * b.value,\n        references: (0, reference_1.joinReferences)(a.references, b.references),\n    };\n};\nOperators.Divide = (a, b) => {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value / b.value,\n        references: (0, reference_1.joinReferences)(a.references, b.references),\n    };\n};\nOperators.Modulo = (a, b) => {\n    if (a === null || b === null)\n        return null;\n    return {\n        value: a.value % b.value,\n        references: (0, reference_1.joinReferences)(a.references, b.references),\n    };\n};\nOperators.Null = () => {\n    return null;\n};\n//# sourceMappingURL=ReferenceHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResolvedTimelineHandler = void 0;\nconst ExpressionHandler_1 = require(\"./ExpressionHandler\");\nconst ReferenceHandler_1 = require(\"./ReferenceHandler\");\nconst lib_1 = require(\"./lib/lib\");\nconst InstanceHandler_1 = require(\"./InstanceHandler\");\nconst reference_1 = require(\"./lib/reference\");\nconst event_1 = require(\"./lib/event\");\nconst instance_1 = require(\"./lib/instance\");\nconst timeline_1 = require(\"./lib/timeline\");\nconst LayerStateHandler_1 = require(\"./LayerStateHandler\");\nconst expression_1 = require(\"./lib/expression\");\nconst performance_1 = require(\"./lib/performance\");\nconst CacheHandler_1 = require(\"./CacheHandler\");\n/**\n * A ResolvedTimelineHandler instance is short-lived and used to resolve a timeline.\n * Intended usage:\n * 1. const resolver = new ResolvedTimelineHandler(options)\n * 2. timelineObjects.forEach(obj => resolver.addTimelineObject(obj))\n * 3. resolver.resolveAllTimelineObjs()\n */\nclass ResolvedTimelineHandler {\n    constructor(options) {\n        this.options = options;\n        /** Maps object id to object */\n        this.objectsMap = new Map();\n        /** Maps className to a list of object ids  */\n        this.classesMap = new Map();\n        /** Maps layer to a list of object ids  */\n        this.layersMap = new Map();\n        /**\n         * Maps an array of object ids to an object id (objects that directly reference an reference).\n         */\n        this.directReferenceMap = new Map();\n        /** How many objects that was actually resolved (is affected when using cache) */\n        this.statisticResolvingObjectCount = 0;\n        /** How many times an object where resolved. (is affected when using cache) */\n        this.statisticResolvingCount = 0;\n        /**\n         * A Map of strings (instance hashes) that is used to determine if an objects instances have changed.\n         * Maps objectId -> instancesHash\n         */\n        this.resolvedObjInstancesHash = new Map();\n        /**\n         * List of explanations fow why an object changed during a resolve iteration.\n         * Used for debugging and Errors\n         */\n        this.changedObjIdsExplanations = [];\n        /**\n         * A Map that contains the objects that needs to resolve again.\n         * Object are added into this after this.resolveConflictsForLayer()\n         */\n        this.objectsToReResolve = new Map();\n        /** Counter that increases during resolving, for every object that might need re-resolving*/\n        this.objectResolveCount = 0;\n        /** Error message, is set when an error is encountered and this.options.dontThrowOnError is set */\n        this._resolveError = undefined;\n        this._idCount = 0;\n        this.expression = new ExpressionHandler_1.ExpressionHandler(false, this.options.skipValidation);\n        this.instance = new InstanceHandler_1.InstanceHandler(this);\n        this.reference = new ReferenceHandler_1.ReferenceHandler(this, this.instance);\n        this.debug = this.options.debug ?? false;\n    }\n    get resolveError() {\n        return this._resolveError;\n    }\n    /** Populate ResolvedTimelineHandler with a timeline-object. */\n    addTimelineObject(obj) {\n        this._addTimelineObject(obj, 0, undefined, false);\n    }\n    /** Resolve the timeline. */\n    resolveAllTimelineObjs() {\n        const toc = (0, performance_1.tic)('  resolveAllTimelineObjs');\n        this.debugTrace('=================================== resolveAllTimelineObjs');\n        // Step 0: Preparations:\n        /** Number of objects in timeline */\n        const objectCount = this.objectsMap.size;\n        /** Max allowed number of iterations over objects */\n        const objectResolveCountMax = objectCount * (this.options.conflictMaxDepth ?? 5);\n        /*\n            The resolving algorithm basically works like this:\n\n            1a: Resolve all objects\n            1b: Resolve conflicts for all layers\n                Also determine which objects depend on changed objects due to conflicts\n\n            2: Loop, until there are no more changed objects:\n                2a: Resolve objects that depend on changed objects\n                2b: Resolve conflicts for affected layers in 2a\n                    Also determine which objects depend on changed objects due to conflicts\n        */\n        // Step 1a: Resolve all objects:\n        for (const obj of this.objectsMap.values()) {\n            this.resolveTimelineObj(obj);\n            // Populate this.resolvedObjInstancesHash now, so that only changes to the timeline instances\n            // in this.resolveConflictsForObjs() will be detected later:\n            this.resolvedObjInstancesHash.set(obj.id, (0, instance_1.getInstancesHash)(obj.resolved.instances));\n        }\n        if (this._resolveError)\n            return; // Abort on error\n        // Step 1b: Resolve conflicts for all objects:\n        this.resolveConflictsForObjs(null);\n        if (this._resolveError)\n            return; // Abort on error\n        // Step 2: re-resolve all changed objects, until no more changes are detected:\n        while (this.objectsToReResolve.size > 0) {\n            if (this.objectResolveCount >= objectResolveCountMax) {\n                const error = new Error(`Maximum conflict iteration reached (${this.objectResolveCount}). This is due to a circular dependency in the timeline. Latest changes:\\n${this.changedObjIdsExplanations.join('Next iteration -------------------------\\n')}`);\n                if (this.options.dontThrowOnError) {\n                    this._resolveError = error;\n                    return;\n                }\n                else {\n                    throw error;\n                }\n            }\n            /* istanbul ignore if */\n            if (this.debug) {\n                this.debugTrace(`---------------------------------`);\n                this.debugTrace(`objectsToReResolve: [${Array.from(this.objectsToReResolve.entries())}]`);\n                this.debugTrace(`directReferences: [${Array.from(this.directReferenceMap.entries()).map(([key, value]) => `${key}: [${value}]`)}]`);\n            }\n            // Collect and reset all objects that depend on previously changed objects\n            const conflictObjectsToResolve = [];\n            for (const obj of this.objectsToReResolve.values()) {\n                this.objectResolveCount++;\n                // Force a new resolve, since the referenced objects might have changed (due to conflicts):\n                let needsConflictResolve = false;\n                if (!obj.resolved.resolvedReferences) {\n                    this.resolveTimelineObj(obj);\n                    needsConflictResolve = true;\n                }\n                if (!obj.resolved.resolvedConflicts) {\n                    needsConflictResolve = true;\n                }\n                if (needsConflictResolve) {\n                    conflictObjectsToResolve.push(obj);\n                }\n            }\n            if (this._resolveError)\n                return; // Abort on error\n            // Resolve conflicts for objects that depend on previously changed objects:\n            this.resolveConflictsForObjs(conflictObjectsToResolve);\n        }\n        toc();\n    }\n    /**\n     * Resolve a timeline-object.\n     * The Resolve algorithm works like this:\n     * 1. Go through the .enable expression(s) and look up all referenced objects.\n     * \t  1.5 For each referenced object, recursively resolve it first if not already resolved.\n     * 2. Collect the resolved instances and calculate the resulting list of resulting instances.\n     */\n    resolveTimelineObj(obj) {\n        if (obj.resolved.resolving) {\n            // Circular dependency\n            const error = Error(`Circular dependency when trying to resolve \"${obj.id}\"`);\n            if (this.options.dontThrowOnError) {\n                this._resolveError = error;\n                obj.resolved.firstResolved = true;\n                obj.resolved.resolvedReferences = true;\n                obj.resolved.resolving = false;\n                obj.resolved.instances = [];\n                return;\n            }\n            else {\n                throw error;\n            }\n        }\n        if (obj.resolved.resolvedReferences)\n            return; // already resolved\n        const toc = (0, performance_1.tic)('     resolveTimelineObj');\n        obj.resolved.resolving = true;\n        this.statisticResolvingCount++;\n        if (!obj.resolved.firstResolved) {\n            this.statisticResolvingObjectCount++;\n        }\n        this.debugTrace(`============ resolving \"${obj.id}\"`);\n        const directReferences = [];\n        let resultingInstances = [];\n        if (obj.disabled) {\n            resultingInstances = [];\n        }\n        else {\n            // Loop up references to the parent:\n            let parentInstances = null;\n            let hasParent = false;\n            let parentRef = undefined;\n            if (obj.resolved.parentId) {\n                hasParent = true;\n                parentRef = `#${obj.resolved.parentId}`;\n                const parentLookup = this.reference.lookupExpression(obj, this.expression.interpretExpression(parentRef), 'start');\n                // pushToArray(directReferences, parentLookup.allReferences)\n                parentInstances = parentLookup.result; // a start-reference will always return an array, or null\n                if (parentInstances !== null) {\n                    // Ensure that the parentInstances references the parent:\n                    for (const parentInstance of parentInstances) {\n                        parentInstance.references = (0, reference_1.joinReferences)(parentInstance.references, parentRef);\n                    }\n                }\n            }\n            const enables = (0, lib_1.ensureArray)(obj.enable);\n            for (let i = 0; i < enables.length; i++) {\n                const enable = enables[i];\n                // Resolve the the enable.repeating expression:\n                const lookupRepeating = enable.repeating !== undefined\n                    ? this.lookupExpression(obj, directReferences, enable.repeating, 'duration')\n                    : { result: null };\n                let lookedupRepeating;\n                if (lookupRepeating.result === null) {\n                    // Do nothing\n                    lookedupRepeating = null;\n                }\n                else if ((0, lib_1.isArray)(lookupRepeating.result)) {\n                    if (lookupRepeating.result.length === 0) {\n                        lookedupRepeating = null;\n                    }\n                    else if (lookupRepeating.result.length === 1) {\n                        lookedupRepeating = (0, lib_1.literal)({\n                            value: lookupRepeating.result[0].start,\n                            references: lookupRepeating.result[0].references,\n                        });\n                    }\n                    else {\n                        // The lookup for repeating returned multiple instances.\n                        // Not supported at the moment, perhaps this could be supported in the future.\n                        /* istanbul ignore next */\n                        throw new Error(`lookupExpression should never return an array for .duration lookup`);\n                    }\n                }\n                else {\n                    lookedupRepeating = lookupRepeating.result;\n                }\n                /** Array of instances this enable-expression resulted in */\n                let enableInstances;\n                if (enable.while !== undefined) {\n                    const whileExpr = \n                    // Handle special case \"1\", 1:\n                    enable.while === '1' || enable.while === 1\n                        ? 'true'\n                        : // Handle special case \"0\", 0:\n                            enable.while === '0' || enable.while === 0\n                                ? 'false'\n                                : enable.while;\n                    // Note: a lookup for 'while' works the same as for 'start'\n                    const lookupWhile = this.lookupExpression(obj, directReferences, whileExpr, 'start');\n                    if (lookupWhile.result === null) {\n                        // Do nothing\n                        enableInstances = [];\n                    }\n                    else if ((0, lib_1.isArray)(lookupWhile.result)) {\n                        enableInstances = lookupWhile.result;\n                    }\n                    else if (lookupWhile.result !== null) {\n                        enableInstances = [\n                            {\n                                id: this.getInstanceId(),\n                                start: lookupWhile.result.value,\n                                end: null,\n                                references: lookupWhile.result.references,\n                            },\n                        ];\n                    }\n                    else {\n                        enableInstances = [];\n                    }\n                }\n                else if (enable.start !== undefined) {\n                    const lookupStart = this.lookupExpression(obj, directReferences, enable.start, 'start');\n                    const lookedupStarts = lookupStart.refersToParent\n                        ? this.reference.applyParentInstances(parentInstances, lookupStart.result)\n                        : lookupStart.result;\n                    const events = [];\n                    // const endEvents: EventForInstance[] = []\n                    let iStart = 0;\n                    let iEnd = 0;\n                    if (lookedupStarts === null) {\n                        // Do nothing\n                    }\n                    else if ((0, lib_1.isArray)(lookedupStarts)) {\n                        // Use the start-times of the instances and add them to the list of events:\n                        // (The end-times are irrelevant)\n                        for (let i = 0; i < lookedupStarts.length; i++) {\n                            const instance = lookedupStarts[i];\n                            const eventId = `${obj.id}_${iStart++}`;\n                            events.push({\n                                time: instance.start,\n                                value: true,\n                                data: { instance: instance, id: eventId },\n                                references: instance.references,\n                            });\n                        }\n                    }\n                    else {\n                        events.push({\n                            time: lookedupStarts.value,\n                            value: true,\n                            data: {\n                                instance: {\n                                    id: this.getInstanceId(),\n                                    start: lookedupStarts.value,\n                                    end: null,\n                                    references: lookedupStarts.references,\n                                },\n                                id: `${obj.id}_${iStart++}`,\n                            },\n                            references: lookedupStarts.references,\n                        });\n                    }\n                    if (enable.end !== undefined) {\n                        const lookupEnd = this.lookupExpression(obj, directReferences, enable.end, 'end');\n                        /** Contains an inverted list of instances. Therefore .start means an end */\n                        const lookedupEnds = !lookupEnd\n                            ? null\n                            : lookupEnd.refersToParent\n                                ? this.reference.applyParentInstances(parentInstances, lookupEnd.result)\n                                : lookupEnd.result;\n                        if (lookedupEnds === null) {\n                            // Do nothing\n                        }\n                        else if ((0, lib_1.isArray)(lookedupEnds)) {\n                            // Use the start-times of the instances and add them (as end-events) to the list:\n                            // (The end-times are irrelevant)\n                            for (let i = 0; i < lookedupEnds.length; i++) {\n                                const instance = lookedupEnds[i];\n                                events.push({\n                                    time: instance.start,\n                                    value: false,\n                                    data: { instance: instance, id: `${obj.id}_${iEnd++}` },\n                                    references: instance.references,\n                                });\n                            }\n                        }\n                        else if (lookedupEnds) {\n                            events.push({\n                                time: lookedupEnds.value,\n                                value: false,\n                                data: {\n                                    instance: {\n                                        id: this.getInstanceId(),\n                                        start: lookedupEnds.value,\n                                        end: null,\n                                        references: lookedupEnds.references,\n                                    },\n                                    id: `${obj.id}_${iEnd++}`,\n                                },\n                                references: lookedupEnds.references,\n                            });\n                        }\n                    }\n                    else if (enable.duration !== undefined) {\n                        const lookupDuration = this.lookupExpression(obj, directReferences, enable.duration, 'duration');\n                        let lookedupDuration = lookupDuration.result;\n                        if (lookedupDuration === null) {\n                            // Do nothing\n                        }\n                        else if ((0, lib_1.isArray)(lookedupDuration)) {\n                            if (lookedupDuration.length === 1) {\n                                lookedupDuration = (0, lib_1.literal)({\n                                    value: lookedupDuration[0].start,\n                                    references: lookedupDuration[0].references,\n                                });\n                            }\n                            else if (lookedupDuration.length === 0) {\n                                lookedupDuration = null;\n                            }\n                            else {\n                                // Lookup rendeded multiple durations.\n                                // This is unsupported at the moment, but could possibly be added in the future.\n                                /* istanbul ignore next */\n                                throw new Error(`lookedupDuration should never return an array for .duration lookup`);\n                            }\n                        }\n                        if (lookedupDuration !== null) {\n                            if (lookedupRepeating !== null && lookedupDuration.value > lookedupRepeating.value) {\n                                // Cap duration to repeating duration\n                                lookedupDuration.value = lookedupRepeating.value;\n                            }\n                            // Go through all pre-existing start-events, and add end-events for each of them.\n                            for (let i = 0; i < events.length; i++) {\n                                const startEvent = events[i];\n                                if (startEvent.value) {\n                                    // Is a start-event\n                                    const time = startEvent.time + lookedupDuration.value;\n                                    const references = (0, reference_1.joinReferences)(startEvent.references, lookedupDuration.references);\n                                    events.push({\n                                        time: time,\n                                        value: false,\n                                        data: {\n                                            id: startEvent.data.id,\n                                            instance: {\n                                                id: startEvent.data.instance.id,\n                                                start: time,\n                                                end: null,\n                                                references: references,\n                                            },\n                                        },\n                                        references: references,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                    enableInstances = this.instance.convertEventsToInstances(events, false, false, \n                    // Omit the referenced originalStart/End when using enable.start:\n                    true);\n                    // Cap those instances to the parent instances:\n                    if (parentRef && parentInstances !== null) {\n                        const parentInstanceMap = new Map();\n                        for (const instance of parentInstances) {\n                            parentInstanceMap.set(instance.id, instance);\n                        }\n                        const cappedEnableInstances = [];\n                        for (const instance of enableInstances) {\n                            let matchedParentInstance = undefined;\n                            // Go through the references in reverse, because sometimes there are multiple matches, and the last one is probably the one we want to use.\n                            for (let i = instance.references.length - 1; i >= 0; i--) {\n                                const ref = instance.references[i];\n                                if ((0, reference_1.isInstanceReference)(ref)) {\n                                    matchedParentInstance = parentInstanceMap.get((0, reference_1.getRefInstanceId)(ref));\n                                    if (matchedParentInstance)\n                                        break;\n                                }\n                            }\n                            if (matchedParentInstance) {\n                                const cappedInstance = this.instance.capInstance(instance, matchedParentInstance);\n                                if (!cappedInstance.caps)\n                                    cappedInstance.caps = [];\n                                cappedInstance.caps.push((0, lib_1.literal)({\n                                    id: matchedParentInstance.id,\n                                    start: matchedParentInstance.start,\n                                    end: matchedParentInstance.end,\n                                }));\n                                cappedEnableInstances.push(cappedInstance);\n                            }\n                            else {\n                                cappedEnableInstances.push(instance);\n                            }\n                        }\n                        enableInstances = cappedEnableInstances;\n                    }\n                }\n                else {\n                    enableInstances = [];\n                }\n                enableInstances = this.instance.applyRepeatingInstances(enableInstances, lookedupRepeating);\n                // Add the instances resulting from this enable-expression to the list:\n                (0, lib_1.pushToArray)(resultingInstances, enableInstances);\n            }\n            // Cap the instances to the parent instances:\n            if (hasParent) {\n                resultingInstances = this.capInstancesToParentInstances({\n                    instances: resultingInstances,\n                    parentInstances,\n                });\n            }\n        }\n        // Make the instance ids unique:\n        const idSet = new Set();\n        for (const instance of resultingInstances) {\n            if (idSet.has(instance.id)) {\n                instance.id = `${instance.id}_${this.getInstanceId()}`;\n            }\n            idSet.add(instance.id);\n        }\n        if (obj.seamless && resultingInstances.length > 1) {\n            resultingInstances = this.instance.cleanInstances(resultingInstances, true, false);\n        }\n        if (obj.resolved.parentId) {\n            directReferences.push(`#${obj.resolved.parentId}`);\n        }\n        if (!obj.resolved.firstResolved) {\n            // This only needs to be done upon first resolve:\n            this.updateDirectReferenceMap(obj, directReferences);\n        }\n        obj.resolved.firstResolved = true;\n        obj.resolved.resolvedReferences = true;\n        obj.resolved.resolving = false;\n        obj.resolved.instances = resultingInstances;\n        if (this.debug) {\n            this.debugTrace(`directReferences \"${obj.id}\": ${JSON.stringify(directReferences)}`);\n            this.debugTrace(`resolved \"${obj.id}\": ${JSON.stringify(obj.resolved.instances)}`);\n        }\n        // Finally:\n        obj.resolved.resolving = false;\n        toc();\n    }\n    getStatistics() {\n        const toc = (0, performance_1.tic)('  getStatistics');\n        if (this.options.skipStatistics) {\n            return {\n                totalCount: 0,\n                resolvedInstanceCount: 0,\n                resolvedObjectCount: 0,\n                resolvedGroupCount: 0,\n                resolvedKeyframeCount: 0,\n                resolvingObjectCount: 0,\n                resolvingCount: 0,\n            };\n        }\n        const statistics = {\n            totalCount: 0,\n            resolvedInstanceCount: 0,\n            resolvedObjectCount: 0,\n            resolvedGroupCount: 0,\n            resolvedKeyframeCount: 0,\n            resolvingObjectCount: this.statisticResolvingObjectCount,\n            resolvingCount: this.statisticResolvingCount,\n        };\n        for (const obj of this.objectsMap.values()) {\n            statistics.totalCount += 1;\n            if (obj.isGroup) {\n                statistics.resolvedGroupCount += 1;\n            }\n            if (obj.resolved.isKeyframe) {\n                statistics.resolvedKeyframeCount += 1;\n            }\n            else {\n                statistics.resolvedObjectCount += 1;\n            }\n            statistics.resolvedInstanceCount += obj.resolved.instances.length;\n        }\n        toc();\n        return statistics;\n    }\n    initializeCache(cacheObj) {\n        this.cache = new CacheHandler_1.CacheHandler(cacheObj, this);\n        return this.cache;\n    }\n    /**\n     * Returns an object.\n     * type-wise, assumes you know what object you're looking for\n     */\n    getObject(objId) {\n        return this.objectsMap.get(objId);\n    }\n    /**\n     * Returns object ids on a layer\n     * type-wise, assumes you know what layer you're looking for\n     */\n    getLayerObjects(layer) {\n        return this.layersMap.get(layer);\n    }\n    /**\n     * Returns object ids on a layer\n     * type-wise, assumes you know what className you're looking for\n     */\n    getClassObjects(className) {\n        return this.classesMap.get(className);\n    }\n    capInstancesToParentInstances(arg) {\n        if (!arg.parentInstances)\n            return [];\n        const events = [];\n        for (const instance of arg.instances) {\n            events.push({\n                time: instance.start,\n                value: true,\n                references: instance.references,\n                data: { instance, isParent: false },\n            });\n            if (instance.end !== null) {\n                events.push({\n                    time: instance.end,\n                    value: false,\n                    references: instance.references,\n                    data: { instance, isParent: false },\n                });\n            }\n        }\n        for (const instance of arg.parentInstances) {\n            events.push({\n                time: instance.start,\n                value: true,\n                references: instance.references,\n                data: { instance, isParent: true },\n            });\n            if (instance.end !== null) {\n                events.push({\n                    time: instance.end,\n                    value: false,\n                    references: instance.references,\n                    data: { instance, isParent: true },\n                });\n            }\n        }\n        (0, event_1.sortEvents)(events, compareEvents);\n        const parentActiveInstances = [];\n        const childActiveInstances = [];\n        let currentActive = undefined;\n        const cappedInstances = [];\n        function finalizeCurrentActive() {\n            if (currentActive) {\n                cappedInstances.push(currentActive.instance);\n                currentActive = undefined;\n            }\n        }\n        for (const event of events) {\n            if (event.data.isParent) {\n                // Parent instance\n                if (event.value) {\n                    parentActiveInstances.push(event.data.instance);\n                }\n                else {\n                    (0, instance_1.spliceInstances)(parentActiveInstances, (i) => (i === event.data.instance ? undefined : i));\n                }\n            }\n            else {\n                // Child instance\n                if (event.value) {\n                    childActiveInstances.push(event.data.instance);\n                }\n                else {\n                    (0, instance_1.spliceInstances)(childActiveInstances, (i) => (i === event.data.instance ? undefined : i));\n                }\n            }\n            const childInstance = childActiveInstances[childActiveInstances.length - 1];\n            const parentInstance = parentActiveInstances[parentActiveInstances.length - 1];\n            /** If there is an active child instance */\n            const toBeEnabled = Boolean(childInstance && parentInstance);\n            if (toBeEnabled) {\n                if (currentActive) {\n                    if (\n                    // Check if instance is still the same:\n                    childInstance.id !== currentActive.instance.id ||\n                        (parentInstance !== currentActive.parent &&\n                            // Check if parent still is active:\n                            !parentActiveInstances.includes(currentActive.parent))) {\n                        // parent isn't active anymore, stop and start a new instance:\n                        // Stop instance:\n                        currentActive.instance.end = event.time;\n                        currentActive.instance.originalEnd = currentActive.instance.originalEnd ?? event.time;\n                        currentActive.instance.references = (0, reference_1.joinReferences)(currentActive.instance.references, event.data.instance.references);\n                        finalizeCurrentActive();\n                    }\n                    else {\n                        // Continue an active instance\n                        if (currentActive.instance.id !== childInstance.id) {\n                            currentActive.instance.references = (0, reference_1.joinReferences)(currentActive.instance.references, childInstance.references);\n                        }\n                    }\n                }\n                if (!currentActive) {\n                    // Start a new instance:\n                    currentActive = {\n                        instance: {\n                            ...childInstance,\n                            start: event.time,\n                            end: null,\n                            // originalStart: childInstance.originalStart ?? event.time,\n                            // originalEnd: childInstance.originalEnd ?? null, // set later\n                            originalStart: childInstance.originalStart ?? childInstance.start,\n                            originalEnd: childInstance.originalEnd ?? childInstance.end ?? null,\n                            references: (0, reference_1.joinReferences)(childInstance.references, ...parentActiveInstances.map((i) => i.references)),\n                        },\n                        parent: parentInstance,\n                    };\n                }\n            }\n            else {\n                if (currentActive) {\n                    // Stop instance:\n                    currentActive.instance.end = event.time;\n                    currentActive.instance.originalEnd = currentActive.instance.originalEnd ?? event.time;\n                    currentActive.instance.references = (0, reference_1.joinReferences)(currentActive.instance.references, event.data.instance.references);\n                    finalizeCurrentActive();\n                }\n            }\n        }\n        finalizeCurrentActive();\n        return cappedInstances;\n    }\n    updateDirectReferenceMap(obj, directReferences) {\n        obj.resolved.directReferences = directReferences;\n        for (const ref of directReferences) {\n            const objectsThisIsReferencing = [];\n            if ((0, reference_1.isObjectReference)(ref)) {\n                const objId = (0, reference_1.getRefObjectId)(ref);\n                objectsThisIsReferencing.push(objId);\n            }\n            else if ((0, reference_1.isClassReference)(ref)) {\n                const className = (0, reference_1.getRefClass)(ref);\n                for (const objId of this.getClassObjects(className) ?? []) {\n                    objectsThisIsReferencing.push(objId);\n                }\n            }\n            else if ((0, reference_1.isLayerReference)(ref)) {\n                const layer = (0, reference_1.getRefLayer)(ref);\n                for (const objId of this.getLayerObjects(layer) ?? []) {\n                    objectsThisIsReferencing.push(objId);\n                }\n            }\n            else if (\n            /* istanbul ignore next */\n            (0, reference_1.isInstanceReference)(ref)) {\n                // do nothing\n            }\n            else {\n                /* istanbul ignore next */\n                (0, lib_1.assertNever)(ref);\n            }\n            for (const refObjId of objectsThisIsReferencing) {\n                let refs = this.directReferenceMap.get(refObjId);\n                if (!refs) {\n                    refs = [];\n                    this.directReferenceMap.set(refObjId, refs);\n                }\n                refs.push(obj.id);\n            }\n        }\n    }\n    getObjectsLayers(objs) {\n        const layers = new Set();\n        for (const obj of objs) {\n            if ((0, timeline_1.objHasLayer)(obj)) {\n                layers.add(`${obj.layer}`);\n            }\n        }\n        return Array.from(layers.values());\n    }\n    /** Returns a list of all object's layers */\n    getAllObjectLayers() {\n        if (!this.allObjectLayersCache) {\n            // Cache this, since this won't change:\n            this.allObjectLayersCache = this.getObjectsLayers(this.objectsMap.values());\n        }\n        return this.allObjectLayersCache;\n    }\n    /** Look up an expression, update references and return it. */\n    lookupExpression(obj, directReferences, expr, context) {\n        const simplifiedExpression = this.expression.simplifyExpression(expr);\n        const lookupResult = this.reference.lookupExpression(obj, simplifiedExpression, context);\n        (0, lib_1.pushToArray)(directReferences, lookupResult.allReferences);\n        // If expression is a constant, it is assumed to be a time relative to its parent:\n        const refersToParent = obj.resolved.parentId && (0, expression_1.isConstantExpr)(simplifiedExpression);\n        return {\n            allReferences: lookupResult.allReferences,\n            result: lookupResult.result,\n            refersToParent,\n        };\n    }\n    _addTimelineObject(obj, \n    /** A number that increases the more levels inside of a group the objects is. 0 = no parent */\n    levelDeep, \n    /** ID of the parent object */\n    parentId, isKeyframe) {\n        const toc = (0, performance_1.tic)('  addTimelineObject');\n        // Is it already added?\n        if (!this.options.skipValidation) {\n            if (this.objectsMap.has(obj.id)) {\n                /* istanbul ignore next */\n                throw Error(`All timelineObjects must be unique! (duplicate: \"${obj.id}\")`);\n            }\n        }\n        // Add the object:\n        {\n            const o = {\n                ...obj,\n                resolved: {\n                    firstResolved: false,\n                    resolvedReferences: false,\n                    resolvedConflicts: false,\n                    resolving: false,\n                    instances: [],\n                    levelDeep: levelDeep,\n                    isSelfReferencing: false,\n                    directReferences: [],\n                    parentId: parentId,\n                    isKeyframe: isKeyframe,\n                },\n            };\n            this.objectsMap.set(obj.id, o);\n            if (obj.classes) {\n                for (let i = 0; i < obj.classes.length; i++) {\n                    const className = obj.classes[i];\n                    if (className) {\n                        let classList = this.classesMap.get(className);\n                        if (!classList) {\n                            classList = [];\n                            this.classesMap.set(className, classList);\n                        }\n                        classList.push(obj.id);\n                    }\n                }\n            }\n            if ((0, timeline_1.objHasLayer)(obj)) {\n                const layer = `${obj.layer}`;\n                let layerList = this.layersMap.get(layer);\n                if (!layerList) {\n                    layerList = [];\n                    this.layersMap.set(layer, layerList);\n                }\n                layerList.push(obj.id);\n            }\n        }\n        // Go through children and keyframes:\n        {\n            // Add children:\n            if (obj.isGroup && obj.children) {\n                for (let i = 0; i < obj.children.length; i++) {\n                    const child = obj.children[i];\n                    this._addTimelineObject(child, levelDeep + 1, obj.id, false);\n                }\n            }\n            // Add keyframes:\n            if (obj.keyframes) {\n                for (let i = 0; i < obj.keyframes.length; i++) {\n                    const keyframe = obj.keyframes[i];\n                    const kf2 = {\n                        ...keyframe,\n                        layer: '',\n                    };\n                    this._addTimelineObject(kf2, levelDeep + 1, obj.id, true);\n                }\n            }\n        }\n        toc();\n    }\n    /**\n     * Resolve conflicts for all layers of the provided objects\n     */\n    resolveConflictsForObjs(\n    /** null means all layers */\n    objs) {\n        const toc = (0, performance_1.tic)('     resolveConflictsForObjs');\n        // These need to be cleared,\n        // as they are populated during the this.updateObjectsToReResolve() below:\n        this.changedObjIdsExplanations = [];\n        this.objectsToReResolve.clear();\n        /** List of layers to resolve conflicts on */\n        let layers;\n        if (objs === null) {\n            layers = this.getAllObjectLayers();\n        }\n        else {\n            layers = this.getObjectsLayers(objs);\n        }\n        for (const layer of layers) {\n            const maybeChangedObjs = this.resolveConflictsForLayer(layer);\n            // run this.updateObjectsToReResolve() here (as opposed to outside the loop),\n            // to allow for a fast-path in resolveConflictsForLayer that skips resolving that layer if it contains\n            // objects that depend on already changed objects.\n            this.updateObjectsToReResolve(maybeChangedObjs);\n        }\n        toc();\n    }\n    /**\n     * Resolve conflicts for a layer\n     * @returns A list of objects on that layer\n     */\n    resolveConflictsForLayer(layer) {\n        const handler = new LayerStateHandler_1.LayerStateHandler(this, this.instance, layer);\n        // Fast path: If an object on this layer depends on an already changed object we should skip this layer, this iteration.\n        // Because the objects will likely change during the next resolve-iteration anyway.\n        for (const objId of handler.objectIdsOnLayer) {\n            if (this.objectsToReResolve.has(objId)) {\n                this.debugTrace(`optimization: Skipping \"${layer}\" since \"${objId}\" changed`);\n                return [];\n            }\n        }\n        handler.resolveConflicts();\n        return handler.objectsOnLayer;\n    }\n    /** Returns the next unique instance id */\n    getInstanceId() {\n        return `@${(this._idCount++).toString(36)}`;\n    }\n    updateObjectsToReResolve(maybeChangedObjs) {\n        const toc = (0, performance_1.tic)('     updateObjectsToReResolve');\n        const changedObjs = new Set();\n        for (const obj of maybeChangedObjs) {\n            // Check if the instances have changed:\n            const instancesHash = (0, instance_1.getInstancesHash)(obj.resolved.instances);\n            const prevHash = this.resolvedObjInstancesHash.get(obj.id) ?? 'not-found';\n            if (instancesHash !== prevHash) {\n                this.changedObjIdsExplanations.push(`\"${obj.id}\" changed from: \\n   ${prevHash}\\n   , to \\n   ${instancesHash}\\n`);\n                if (this.changedObjIdsExplanations.length > 2)\n                    this.changedObjIdsExplanations.shift();\n                this.debugTrace(`changed: ${obj.id}: \"${prevHash}\" -> \"${instancesHash}\"`);\n                changedObjs.add(obj.id);\n                this.resolvedObjInstancesHash.set(obj.id, instancesHash);\n            }\n        }\n        for (const changedObjId of changedObjs.values()) {\n            // Find all objects that depend on this:\n            const directReferences = this.directReferenceMap.get(changedObjId) ?? [];\n            for (const objId of directReferences) {\n                const obj = this.getObject(objId);\n                obj.resolved.resolvedReferences = false;\n                // Note: obj.resolved.resolvedConflicts will be set to false later when resolving references\n                this.objectsToReResolve.set(obj.id, obj);\n            }\n        }\n        toc();\n    }\n    debugTrace(...args) {\n        if (this.debug)\n            console.log(...args);\n    }\n}\nexports.ResolvedTimelineHandler = ResolvedTimelineHandler;\nfunction compareEvents(a, b) {\n    // start event be first:\n    const aValue = a.value;\n    const bValue = b.value;\n    if (aValue && !bValue)\n        return -1;\n    if (!aValue && bValue)\n        return 1;\n    const aIsParent = a.data.isParent;\n    const bIsParent = b.data.isParent;\n    if (aValue) {\n        // start: parents first:\n        if (aIsParent && !bIsParent)\n            return -1;\n        if (!aIsParent && bIsParent)\n            return 1;\n    }\n    else {\n        // end: parents last:\n        if (aIsParent && !bIsParent)\n            return 1;\n        if (!aIsParent && bIsParent)\n            return -1;\n    }\n    // parents first:\n    // if (a.data.isParent && !b.data.isParent) return -1\n    // if (!a.data.isParent && b.data.isParent) return 1\n    return 0;\n}\n//# sourceMappingURL=ResolvedTimelineHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResolverHandler = void 0;\nconst ResolvedTimelineHandler_1 = require(\"./ResolvedTimelineHandler\");\nconst resolvedTimeline_1 = require(\"../api/resolvedTimeline\");\nconst lib_1 = require(\"./lib/lib\");\nconst performance_1 = require(\"./lib/performance\");\nconst timeline_1 = require(\"./lib/timeline\");\nconst TimelineValidator_1 = require(\"./TimelineValidator\");\n/**\n * Note: A Resolver instance is short-lived and used to resolve a timeline.\n * Intended usage:\n * 1. const resolver = new Resolver(options)\n * 2. resolver.run(timeline)\n */\nclass ResolverHandler {\n    constructor(options) {\n        this.options = options;\n        this.hasRun = false;\n        this.nextEvents = [];\n        const toc = (0, performance_1.tic)('new Resolver');\n        this.resolvedTimeline = new ResolvedTimelineHandler_1.ResolvedTimelineHandler(this.options);\n        this.validator = new TimelineValidator_1.TimelineValidator();\n        toc();\n    }\n    /**\n     * Resolves a timeline, i.e. resolves the references between objects\n     * This method can only be run once per Resolver instance.\n     */\n    resolveTimeline(timeline) {\n        const toc = (0, performance_1.tic)('resolveTimeline');\n        /* istanbul ignore if */\n        if (this.hasRun)\n            throw new Error(`Resolver.resolveTimeline can only run once per instance!\nUsage:\nconst resolver = new Resolver(options);\nresolver.run(timeline);`);\n        this.hasRun = true;\n        // Step 0: Validate the timeline:\n        if (!this.options.skipValidation) {\n            this.validator.validateTimeline(timeline, false);\n        }\n        // Step 1: Populate ResolvedTimeline with the timeline:\n        for (const obj of timeline) {\n            this.resolvedTimeline.addTimelineObject(obj);\n        }\n        // Step 2: Use cache:\n        let cacheHandler;\n        if (this.options.cache) {\n            cacheHandler = this.resolvedTimeline.initializeCache(this.options.cache);\n            cacheHandler.determineChangedObjects();\n        }\n        // Step 3: Go through and resolve all objects:\n        this.resolvedTimeline.resolveAllTimelineObjs();\n        // Step 4: Populate nextEvents:\n        this.updateNextEvents();\n        // Step 5: persist cache\n        if (cacheHandler) {\n            cacheHandler.persistData();\n        }\n        const resolvedTimeline = (0, lib_1.literal)({\n            objects: (0, lib_1.mapToObject)(this.resolvedTimeline.objectsMap),\n            classes: (0, lib_1.mapToObject)(this.resolvedTimeline.classesMap),\n            layers: (0, lib_1.mapToObject)(this.resolvedTimeline.layersMap),\n            nextEvents: this.nextEvents,\n            statistics: this.resolvedTimeline.getStatistics(),\n            error: this.resolvedTimeline.resolveError,\n        });\n        toc();\n        return resolvedTimeline;\n    }\n    /** Update this.nextEvents */\n    updateNextEvents() {\n        const toc = (0, performance_1.tic)('  updateNextEvents');\n        this.nextEvents = [];\n        const allObjects = [];\n        const allKeyframes = [];\n        for (const obj of this.resolvedTimeline.objectsMap.values()) {\n            if (obj.resolved.isKeyframe) {\n                allKeyframes.push(obj);\n            }\n            else {\n                allObjects.push(obj);\n            }\n        }\n        /** Used to fast-track in cases where there are no keyframes */\n        const hasKeyframes = allKeyframes.length > 0;\n        const objectInstanceStartTimes = new Set();\n        const objectInstanceEndTimes = new Set();\n        // Go through keyframes last:\n        for (const obj of [...allObjects, ...allKeyframes]) {\n            if (!obj.resolved.isKeyframe) {\n                if (!(0, timeline_1.objHasLayer)(obj))\n                    continue; // transparent objects are omitted in NextEvents\n            }\n            else if (obj.resolved.parentId !== undefined) {\n                const parentObj = this.resolvedTimeline.getObject(obj.resolved.parentId);\n                if (parentObj) {\n                    /* istanbul ignore if */\n                    if (!(0, timeline_1.objHasLayer)(parentObj))\n                        continue; // Keyframes of transparent objects are omitted in NextEvents\n                }\n            }\n            for (let i = 0; i < obj.resolved.instances.length; i++) {\n                const instance = obj.resolved.instances[i];\n                if (instance.start > this.options.time && instance.start < (this.options.limitTime ?? Infinity)) {\n                    let useThis = true;\n                    if (hasKeyframes) {\n                        if (!obj.resolved.isKeyframe) {\n                            objectInstanceStartTimes.add(`${obj.id}_${instance.start}`);\n                        }\n                        else {\n                            // No need to put keyframe event if its parent starts at the same time:\n                            if (objectInstanceStartTimes.has(`${obj.resolved.parentId}_${instance.start}`)) {\n                                useThis = false;\n                            }\n                        }\n                    }\n                    if (useThis) {\n                        this.nextEvents.push({\n                            objId: obj.id,\n                            type: obj.resolved.isKeyframe ? resolvedTimeline_1.EventType.KEYFRAME : resolvedTimeline_1.EventType.START,\n                            time: instance.start,\n                        });\n                    }\n                }\n                if (instance.end !== null &&\n                    instance.end > this.options.time &&\n                    instance.end < (this.options.limitTime ?? Infinity)) {\n                    let useThis = true;\n                    if (hasKeyframes) {\n                        if (!obj.resolved.isKeyframe) {\n                            objectInstanceEndTimes.add(`${obj.id}_${instance.end}`);\n                        }\n                        else {\n                            // No need to put keyframe event if its parent ends at the same time:\n                            if (objectInstanceEndTimes.has(`${obj.resolved.parentId}_${instance.end}`)) {\n                                useThis = false;\n                            }\n                        }\n                    }\n                    if (useThis) {\n                        this.nextEvents.push({\n                            objId: obj.id,\n                            type: obj.resolved.isKeyframe ? resolvedTimeline_1.EventType.KEYFRAME : resolvedTimeline_1.EventType.END,\n                            time: instance.end,\n                        });\n                    }\n                }\n            }\n        }\n        this.nextEvents.sort(compareNextEvents);\n        toc();\n    }\n}\nexports.ResolverHandler = ResolverHandler;\nfunction compareNextEvents(a, b) {\n    return a.time - b.time || b.type - a.type || (0, lib_1.compareStrings)(a.objId, b.objId);\n}\n//# sourceMappingURL=ResolverHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StateHandler = void 0;\nconst instance_1 = require(\"./lib/instance\");\nconst lib_1 = require(\"./lib/lib\");\nconst performance_1 = require(\"./lib/performance\");\nconst timeline_1 = require(\"./lib/timeline\");\nclass StateHandler {\n    getState(resolvedTimeline, time, eventLimit = 0) {\n        const toc = (0, performance_1.tic)('getState');\n        const state = {\n            time: time,\n            layers: {},\n            nextEvents: resolvedTimeline.nextEvents.filter((e) => e.time > time),\n        };\n        if (eventLimit)\n            state.nextEvents = state.nextEvents.slice(0, eventLimit);\n        for (const obj of Object.values(resolvedTimeline.objects)) {\n            if (!(0, timeline_1.objHasLayer)(obj))\n                continue;\n            // Note: We can assume that it is not a keyframe here, because keyframes don't have layers\n            for (const instance of obj.resolved.instances) {\n                if ((0, instance_1.instanceIsActive)(instance, time)) {\n                    let contentIsOriginal = true;\n                    const objInstance = {\n                        ...obj,\n                        instance,\n                    };\n                    /* istanbul ignore if */\n                    if (state.layers[`${obj.layer}`]) {\n                        // There is already an object on this layer!\n                        console.error(state.layers[`${obj.layer}`]);\n                        console.error(objInstance);\n                        throw new Error(`Internal Error: There is already an object on layer \"${obj.layer}\"!`);\n                    }\n                    state.layers[`${obj.layer}`] = objInstance;\n                    // Now, apply keyframes:\n                    const objectKeyframes = obj.keyframes\n                        ? obj.keyframes.map((kf) => resolvedTimeline.objects[kf.id])\n                        : [];\n                    for (const keyframe of this.getActiveKeyframeInstances(objectKeyframes, time)) {\n                        if (contentIsOriginal) {\n                            // We don't want to modify the original content, so we deep-clone it before modifying it:\n                            objInstance.content = (0, lib_1.clone)(obj.content);\n                            contentIsOriginal = false;\n                        }\n                        StateHandler.applyKeyframeContent(objInstance.content, keyframe.content);\n                    }\n                }\n            }\n        }\n        toc();\n        return state;\n    }\n    /**\n     * Apply keyframe content onto its parent content.\n     * The keyframe content is deeply-applied onto the parent content.\n     */\n    static applyKeyframeContent(parentContent, keyframeContent) {\n        const toc = (0, performance_1.tic)('  applyKeyframeContent');\n        for (const [attr, value] of Object.entries(keyframeContent)) {\n            if ((0, lib_1.isObject)(value)) {\n                if ((0, lib_1.isArray)(value)) {\n                    // Value is an array\n                    if (!Array.isArray(parentContent[attr]))\n                        parentContent[attr] = [];\n                    this.applyKeyframeContent(parentContent[attr], value);\n                    parentContent[attr].splice(value.length, Infinity);\n                }\n                else {\n                    // Value is an object\n                    if (!(0, lib_1.isObject)(parentContent[attr]) || Array.isArray(parentContent[attr]))\n                        parentContent[attr] = {};\n                    this.applyKeyframeContent(parentContent[attr], value);\n                }\n            }\n            else {\n                parentContent[attr] = value;\n            }\n        }\n        toc();\n    }\n    getActiveKeyframeInstances(keyframes, time) {\n        const keyframeInstances = [];\n        for (const keyframe of keyframes) {\n            for (const instance of keyframe.resolved.instances) {\n                if ((0, instance_1.instanceIsActive)(instance, time)) {\n                    keyframeInstances.push({\n                        ...keyframe,\n                        instance,\n                    });\n                }\n            }\n        }\n        keyframeInstances.sort((a, b) => {\n            // Highest priority is applied last:\n            const aPriority = a.priority ?? 0;\n            const bPriority = b.priority ?? 0;\n            if (aPriority < bPriority)\n                return -1;\n            if (aPriority > bPriority)\n                return 1;\n            // Last start time is applied last:\n            if (a.instance.start < b.instance.start)\n                return -1;\n            if (a.instance.start > b.instance.start)\n                return 1;\n            /* istanbul ignore next */\n            return 0;\n        });\n        return keyframeInstances;\n    }\n}\nexports.StateHandler = StateHandler;\n//# sourceMappingURL=StateHandler.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TimelineValidator = void 0;\nconst ExpressionHandler_1 = require(\"./ExpressionHandler\");\nconst lib_1 = require(\"./lib/lib\");\nconst performance_1 = require(\"./lib/performance\");\n/** These characters are reserved and cannot be used in ids, etc */\nconst RESERVED_CHARACTERS = /[#.$]/g;\n/** These characters are reserved for possible future use and cannot be used in ids, etc */\nconst FUTURE_RESERVED_CHARACTERS = /[=?@{}[\\]^]/g;\n/**\n * Note: A TimelineValidator instance is short-lived and used to validate a timeline.\n * Intended usage:\n * 1. const validator = new TimelineValidator()\n * 2. validator.validateTimeline(timeline)\n * or:\n * 1. const validator = new TimelineValidator()\n * 2. validator.validateObject(obj)\n * or:\n * 1. const validator = new TimelineValidator()\n * 2. validator.validateKeyframe(obj)\n */\nclass TimelineValidator {\n    constructor() {\n        this.uniqueIds = {};\n    }\n    /** Validates all objects in the timeline. Throws an error if something's wrong. */\n    validateTimeline(\n    /** The timeline to validate */\n    timeline, \n    /** Set to true to enable some optional strict rules. Set this to true to increase future compatibility. */\n    strict) {\n        const toc = (0, performance_1.tic)('  validateTimeline');\n        for (let i = 0; i < timeline.length; i++) {\n            const obj = timeline[i];\n            this.validateObject(obj, strict);\n        }\n        toc();\n    }\n    /** Validates a simgle Timeline-object. Throws an error if something's wrong. */\n    validateObject(\n    /** The object to validate */\n    obj, \n    /** Set to true to enable some optional strict rules. Set this to true to increase future compatibility. */\n    strict) {\n        if (!obj)\n            throw new Error(`Object is undefined`);\n        if (typeof obj !== 'object')\n            throw new Error(`Object is not an object`);\n        try {\n            this.validateId(obj, strict);\n            this.validateLayer(obj, strict);\n            this.validateContent(obj);\n            this.validateEnable(obj, strict);\n            if (obj.keyframes) {\n                for (let i = 0; i < obj.keyframes.length; i++) {\n                    const keyframe = obj.keyframes[i];\n                    try {\n                        this.validateKeyframe(keyframe, strict);\n                    }\n                    catch (e) {\n                        throw new Error(`Keyframe[${i}]: ${e}`);\n                    }\n                }\n            }\n            this.validateClasses(obj, strict);\n            if (obj.children && !obj.isGroup)\n                throw new Error(`Attribute \"children\" is set but \"isGroup\" is not`);\n            if (obj.isGroup && !obj.children)\n                throw new Error(`Attribute \"isGroup\" is set but \"children\" missing`);\n            if (obj.children) {\n                for (let i = 0; i < obj.children.length; i++) {\n                    const child = obj.children[i];\n                    try {\n                        this.validateObject(child, strict);\n                    }\n                    catch (e) {\n                        throw new Error(`Child[${i}]: ${e}`);\n                    }\n                }\n            }\n            if (obj.priority !== undefined && typeof obj.priority !== 'number')\n                throw new Error(`Attribute \"priority\" is not a number`);\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                const err2 = new Error(`Object \"${obj.id}\": ${err.message}`);\n                err2.stack = err.stack;\n                throw err;\n            }\n            else\n                throw err;\n        }\n    }\n    /** Validates a simgle Timeline-object. Throws an error if something's wrong. */\n    validateKeyframe(\n    /** The object to validate */\n    keyframe, \n    /** Set to true to enable some optional strict rules. Set this to true to increase future compatibility */\n    strict) {\n        if (!keyframe)\n            throw new Error(`Keyframe is undefined`);\n        if (typeof keyframe !== 'object')\n            throw new Error(`Keyframe is not an object`);\n        try {\n            this.validateId(keyframe, strict);\n            this.validateContent(keyframe);\n            this.validateEnable(keyframe, strict);\n            this.validateClasses(keyframe, strict);\n        }\n        catch (err) {\n            if (err instanceof Error) {\n                const err2 = new Error(`Keyframe \"${keyframe.id}\": ${err.message}`);\n                err2.stack = err.stack;\n                throw err;\n            }\n            else\n                throw err;\n        }\n    }\n    validateId(obj, strict) {\n        if (!obj.id)\n            throw new Error(`Object missing \"id\" attribute`);\n        if (typeof obj.id !== 'string')\n            throw new Error(`Object \"id\" attribute is not a string: \"${obj.id}\"`);\n        try {\n            TimelineValidator.validateReferenceString(obj.id, strict);\n        }\n        catch (err) {\n            throw new Error(`Object \"id\" attribute: ${err}`);\n        }\n        if (this.uniqueIds[obj.id])\n            throw new Error(`id \"${obj.id}\" is not unique`);\n        this.uniqueIds[obj.id] = true;\n    }\n    validateLayer(obj, strict) {\n        if (obj.layer === undefined)\n            throw new Error(`\"layer\" attribute is undefined. (If an object is to have no layer, set this to an empty string.)`);\n        try {\n            TimelineValidator.validateReferenceString(`${obj.layer}`, strict);\n        }\n        catch (err) {\n            throw new Error(`\"layer\" attribute: ${err}`);\n        }\n    }\n    validateContent(obj) {\n        if (!obj.content)\n            throw new Error(`\"content\" attribute must be set`);\n    }\n    validateEnable(obj, strict) {\n        if (!obj.enable)\n            throw new Error(`\"enable\" attribute must be set`);\n        const enables = (0, lib_1.ensureArray)(obj.enable);\n        for (let i = 0; i < enables.length; i++) {\n            const enable = enables[i];\n            if (enable.start !== undefined) {\n                if (strict && enable.while !== undefined)\n                    throw new Error(`\"enable.start\" and \"enable.while\" cannot be combined`);\n                if (strict && enable.end !== undefined && enable.duration !== undefined)\n                    throw new Error(`\"enable.end\" and \"enable.duration\" cannot be combined`);\n            }\n            else if (enable.while !== undefined) {\n                if (strict && enable.end !== undefined)\n                    throw new Error(`\"enable.while\" and \"enable.end\" cannot be combined`);\n                if (strict && enable.duration !== undefined)\n                    throw new Error(`\"enable.while\" and \"enable.duration\" cannot be combined`);\n            }\n            else\n                throw new Error(`\"enable.start\" or \"enable.while\" must be set`);\n        }\n    }\n    validateClasses(obj, strict) {\n        if (obj.classes) {\n            for (let i = 0; i < obj.classes.length; i++) {\n                const className = obj.classes[i];\n                if (className && typeof className !== 'string')\n                    throw new Error(`\"classes[${i}]\" is not a string`);\n                try {\n                    TimelineValidator.validateReferenceString(className, strict);\n                }\n                catch (err) {\n                    throw new Error(` \"classes[${i}]\": ${err}`);\n                }\n            }\n        }\n    }\n    /**\n     * Validates a string that is used in Timeline as a reference (an id, a class or layer)\n     * @param str The string to validate\n     * @param strict Set to true to enable some strict rules (rules that can possibly be ignored)\n     */\n    static validateReferenceString(str, strict) {\n        if (!str)\n            return;\n        const matchesOperators = ExpressionHandler_1.REGEXP_OPERATORS.test(str);\n        const matchesReserved = RESERVED_CHARACTERS.test(str);\n        const matchesFutureReserved = strict && FUTURE_RESERVED_CHARACTERS.test(str);\n        if (matchesOperators || matchesReserved || matchesFutureReserved) {\n            const matchOperators = str.match(ExpressionHandler_1.REGEXP_OPERATORS) ?? [];\n            const matchReserved = str.match(RESERVED_CHARACTERS) ?? [];\n            const matchFutureReserved = (strict && str.match(FUTURE_RESERVED_CHARACTERS)) || [];\n            throw new Error(`The string \"${str}\" contains characters which aren't allowed in Timeline: ${[\n                matchOperators.length > 0 && `${matchOperators.map((o) => `\"${o}\"`).join(', ')} (is an operator)`,\n                matchReserved.length > 0 &&\n                    `${matchReserved.map((o) => `\"${o}\"`).join(', ')} (is a reserved character)`,\n                matchFutureReserved.length > 0 &&\n                    `${matchFutureReserved\n                        .map((o) => `\"${o}\"`)\n                        .join(', ')} (is a strict reserved character and might be used in the future)`,\n            ]\n                .filter(Boolean)\n                .join(', ')}`);\n        }\n    }\n}\nexports.TimelineValidator = TimelineValidator;\n//# sourceMappingURL=TimelineValidator.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Cache = void 0;\nclass Cache {\n    constructor(autoCleanup = false) {\n        this.autoCleanup = autoCleanup;\n        this.cache = new Map();\n        this.clearTimeout = undefined;\n        this.timeToCueNewCleanup = false;\n        if (this.autoCleanup)\n            this.timeToCueNewCleanup = true;\n    }\n    /** Cache the result of function for a limited time */\n    cacheResult(key, fcn, limitTime) {\n        const cache = this.cache.get(key);\n        if (!cache || cache.ttl < Date.now()) {\n            const value = fcn();\n            this.cache.set(key, {\n                ttl: Date.now() + limitTime,\n                value: value,\n            });\n            if (this.timeToCueNewCleanup) {\n                this.timeToCueNewCleanup = false;\n                /* istanbul ignore next */\n                this.clearTimeout = setTimeout(() => {\n                    this.clearTimeout = undefined;\n                    this.timeToCueNewCleanup = true;\n                    this.cleanUp();\n                }, limitTime + 100);\n            }\n            return value;\n        }\n        else {\n            return cache.value;\n        }\n    }\n    /* istanbul ignore next */\n    cleanUp() {\n        const now = Date.now();\n        for (const [key, value] of this.cache.entries()) {\n            if (value.ttl < now)\n                this.cache.delete(key);\n        }\n    }\n    clear() {\n        this.cache.clear();\n        if (this.clearTimeout) {\n            clearTimeout(this.clearTimeout);\n            this.clearTimeout = undefined;\n            this.timeToCueNewCleanup = true;\n        }\n    }\n}\nexports.Cache = Cache;\n//# sourceMappingURL=cache.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addCapsToResuming = exports.joinCaps = void 0;\nfunction joinCaps(...caps) {\n    const capMap = {};\n    for (let i = 0; i < caps.length; i++) {\n        const caps2 = caps[i];\n        if (caps2) {\n            for (let j = 0; j < caps2.length; j++) {\n                const cap2 = caps2[j];\n                capMap[cap2.id] = cap2;\n            }\n        }\n    }\n    return Object.values(capMap);\n}\nexports.joinCaps = joinCaps;\nfunction addCapsToResuming(instance, ...caps) {\n    const capsToAdd = [];\n    const joinedCaps = joinCaps(...caps);\n    for (let i = 0; i < joinedCaps.length; i++) {\n        const cap = joinedCaps[i];\n        if (cap.end !== null && instance.end !== null && cap.end > instance.end) {\n            capsToAdd.push({\n                id: cap.id,\n                start: 0,\n                end: cap.end,\n            });\n        }\n    }\n    instance.caps = joinCaps(instance.caps, capsToAdd);\n}\nexports.addCapsToResuming = addCapsToResuming;\n//# sourceMappingURL=cap.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.sortEvents = void 0;\nfunction sortEvents(events, additionalSortFcnBefore) {\n    return events.sort((a, b) => {\n        if (a.time > b.time)\n            return 1;\n        if (a.time < b.time)\n            return -1;\n        const result = additionalSortFcnBefore ? additionalSortFcnBefore(a, b) : 0;\n        if (result !== 0)\n            return result;\n        const aId = a.data && (a.data.id || a.data.instance?.id);\n        const bId = b.data && (b.data.id || b.data.instance?.id);\n        if (aId && bId && aId === bId) {\n            // If the events refer to the same instance id, let the start event be first,\n            // to handle zero-length instances.\n            if (a.value && !b.value)\n                return -1;\n            if (!a.value && b.value)\n                return 1;\n        }\n        else {\n            // ends events first:\n            if (a.value && !b.value)\n                return 1;\n            if (!a.value && b.value)\n                return -1;\n        }\n        return 0;\n    });\n}\nexports.sortEvents = sortEvents;\n//# sourceMappingURL=event.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isNumericExpr = exports.isConstantExpr = void 0;\n/** Returns true if an expression is a constant (ie doesn't reference something else) */\nfunction isConstantExpr(str) {\n    if (isNumericExpr(str))\n        return true;\n    if (typeof str === 'string') {\n        const lStr = str.toLowerCase();\n        if (lStr === 'true')\n            return true;\n        if (lStr === 'false')\n            return true;\n    }\n    return false;\n}\nexports.isConstantExpr = isConstantExpr;\nfunction isNumericExpr(str) {\n    if (str === null)\n        return false;\n    if (typeof str === 'number')\n        return true;\n    if (typeof str === 'string')\n        return !!/^[-+]?[0-9.]+$/.exec(str) && !isNaN(parseFloat(str));\n    return false;\n}\nexports.isNumericExpr = isNumericExpr;\n//# sourceMappingURL=expression.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getInstanceHash = exports.getInstancesHash = exports.baseInstance = exports.baseInstances = exports.spliceInstances = exports.getInstanceIntersection = exports.instanceIsActive = exports.isInstanceId = void 0;\nconst lib_1 = require(\"./lib\");\nfunction isInstanceId(str) {\n    return str.startsWith('@');\n}\nexports.isInstanceId = isInstanceId;\nfunction instanceIsActive(instance, time) {\n    return instance.start <= time && (instance.end ?? Infinity) > time;\n}\nexports.instanceIsActive = instanceIsActive;\n/**\n * Returns the intersection of two instances.\n * Example: for (10-20) and (15-30), the intersection is (15-20).\n */\nfunction getInstanceIntersection(a, b) {\n    if (a.start < (b.end ?? Infinity) && (a.end ?? Infinity) > b.start) {\n        const start = Math.max(a.start, b.start);\n        const end = Math.min(a.end ?? Infinity, b.end ?? Infinity);\n        return {\n            start,\n            end: end === Infinity ? null : end,\n        };\n    }\n    return null;\n}\nexports.getInstanceIntersection = getInstanceIntersection;\n/**\n * Convenience function to splice an array of instances\n * @param instances The array of instances to splice\n * @param fcn Operator function.\n *   Is called for each instance in the array,\n *   and should return an instance (or an array of instances) to insert in place of the original instance,\n *   or undefined to remove the instance.\n *   (To leave the instance unchanged, return the original instance)\n */\nfunction spliceInstances(instances, fcn) {\n    for (let i = 0; i < instances.length; i++) {\n        const fcnResult = fcn(instances[i]);\n        const insertInstances = fcnResult === undefined ? [] : (0, lib_1.ensureArray)(fcnResult);\n        if (insertInstances.length === 0) {\n            instances.splice(i, 1);\n            i--;\n        }\n        else {\n            if (insertInstances[0] === instances[i])\n                continue;\n            // replace:\n            instances.splice(i, 1, ...insertInstances);\n            i += insertInstances.length - 1;\n        }\n    }\n}\nexports.spliceInstances = spliceInstances;\nfunction baseInstances(instances) {\n    return instances.map((instance) => baseInstance(instance));\n}\nexports.baseInstances = baseInstances;\nfunction baseInstance(instance) {\n    return {\n        start: instance.start,\n        end: instance.end,\n    };\n}\nexports.baseInstance = baseInstance;\n/** Returns a string hash that changes whenever any instance has changed in a significant way */\nfunction getInstancesHash(instances) {\n    const strs = [];\n    for (const instance of instances) {\n        strs.push(getInstanceHash(instance));\n    }\n    return strs.join(',');\n}\nexports.getInstancesHash = getInstancesHash;\n/** Returns a string hash that changes whenever an instance has changed in a significant way */\nfunction getInstanceHash(instance) {\n    const orgStart = instance.originalStart ?? instance.start;\n    const orgEnd = instance.originalEnd ?? instance.end;\n    return `${instance.start}_${instance.end ?? 'null'}(${orgStart}_${orgEnd ?? 'null'})`;\n}\nexports.getInstanceHash = getInstanceHash;\n//# sourceMappingURL=instance.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compareStrings = exports.mapToObject = exports.assertNever = exports.isArray = exports.ensureArray = exports.isEmpty = exports.sortBy = exports.omit = exports.uniq = exports.clone = exports.pushToArray = exports.reduceObj = exports.isObject = exports.last = exports.compact = exports.literal = void 0;\nfunction literal(o) {\n    return o;\n}\nexports.literal = literal;\nfunction compact(arr) {\n    const returnValues = [];\n    for (let i = 0; i < arr.length; i++) {\n        const v = arr[i];\n        if (!!v || (v !== undefined && v !== null && v !== ''))\n            returnValues.push(v);\n    }\n    return returnValues;\n}\nexports.compact = compact;\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nexports.last = last;\n/** Returns true if argument is an object (or an array, but NOT null) */\nfunction isObject(o) {\n    return o !== null && typeof o === 'object';\n}\nexports.isObject = isObject;\nfunction reduceObj(objs, fcn, initialValue) {\n    return Object.entries(objs).reduce((memo, [key, value], index) => {\n        return fcn(memo, value, key, index);\n    }, initialValue);\n}\nexports.reduceObj = reduceObj;\n/**\n * Concatenate two arrays of values.\n * This is a convenience function used to ensure that the two arrays are of the same type.\n * @param arr0 The array of values to push into\n * @param arr1 An array of values to push into arr0\n */\nfunction pushToArray(arr0, arr1) {\n    for (const item of arr1) {\n        arr0.push(item);\n    }\n}\nexports.pushToArray = pushToArray;\nfunction clone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.clone = clone;\nfunction uniq(arr) {\n    return Array.from(new Set(arr));\n}\nexports.uniq = uniq;\nfunction omit(obj, ...keys) {\n    const result = {};\n    for (const [key, value] of Object.entries(obj)) {\n        if (keys.some((k) => (Array.isArray(k) ? k.includes(key) : k === key)))\n            continue;\n        result[key] = value;\n    }\n    return result;\n}\nexports.omit = omit;\nfunction sortBy(arr, fcn) {\n    const sortArray = arr.map((item) => ({ item, value: fcn(item) }));\n    sortArray.sort((a, b) => {\n        if (a.value < b.value)\n            return -1;\n        if (a.value > b.value)\n            return 1;\n        return 0;\n    });\n    return sortArray.map((item) => item.item);\n}\nexports.sortBy = sortBy;\nfunction isEmpty(obj) {\n    return Object.keys(obj).length === 0;\n}\nexports.isEmpty = isEmpty;\nfunction ensureArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\nexports.ensureArray = ensureArray;\n/**\n * Slightly faster than Array.isArray().\n * Note: Ensure that the value provided is not null!\n */\nfunction isArray(arg) {\n    // Fast-path optimization: checking for .length is faster than Array.isArray()\n    return arg.length !== undefined && Array.isArray(arg);\n}\nexports.isArray = isArray;\n/**\n * Helper function to simply assert that the value is of the type never.\n * Usage: at the end of if/else or switch, to ensure that there is no fallthrough.\n */\nfunction assertNever(_value) {\n    // does nothing\n}\nexports.assertNever = assertNever;\nfunction mapToObject(map) {\n    const o = {};\n    for (const [key, value] of map.entries()) {\n        o[key] = value;\n    }\n    return o;\n}\nexports.mapToObject = mapToObject;\nfunction compareStrings(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n}\nexports.compareStrings = compareStrings;\n//# sourceMappingURL=lib.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ticTocPrint = exports.tic = exports.activatePerformanceDebugging = void 0;\nconst perf_hooks_1 = require(\"perf_hooks\");\nlet durations = {};\nlet callCounts = {};\nlet firstStartTime = 0;\nlet active = false;\nfunction activatePerformanceDebugging(activate) {\n    active = activate;\n}\nexports.activatePerformanceDebugging = activatePerformanceDebugging;\nfunction noop() {\n    // nothing\n}\n/**\n * Used to measure performance.\n * Starts a measurement, returns a function that should be called when the measurement is done.\n */\nfunction tic(id) {\n    if (!active)\n        return noop;\n    if (!firstStartTime)\n        firstStartTime = perf_hooks_1.performance.now();\n    if (!durations[id])\n        durations[id] = 0;\n    if (!callCounts[id])\n        callCounts[id] = 0;\n    const startTime = perf_hooks_1.performance.now();\n    return () => {\n        const duration = perf_hooks_1.performance.now() - startTime;\n        durations[id] = durations[id] + duration;\n        callCounts[id]++;\n    };\n}\nexports.tic = tic;\nfunction ticTocPrint() {\n    if (!active)\n        return;\n    const totalDuration = perf_hooks_1.performance.now() - firstStartTime;\n    const maxKeyLength = Math.max(...Object.keys(durations).map((k) => k.length));\n    console.log('ticTocPrint\\n' +\n        padStr(`Total duration `, maxKeyLength + 2) +\n        `${Math.floor(totalDuration)}\\n` +\n        Object.entries(durations)\n            .map((d) => {\n            let str = padStr(`${d[0]} `, maxKeyLength + 2);\n            str += padStr(`${Math.floor(d[1] * 10) / 10}`, 8);\n            str += padStr(`${Math.floor((d[1] / totalDuration) * 1000) / 10}%`, 7);\n            str += `${callCounts[d[0]]}`;\n            return str;\n        })\n            .join('\\n'));\n    durations = {};\n    callCounts = {};\n}\nexports.ticTocPrint = ticTocPrint;\nfunction padStr(str, length) {\n    while (str.length < length)\n        str += ' ';\n    return str;\n}\n//# sourceMappingURL=performance.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isReference = exports.joinReferences = exports.getRefInstanceId = exports.isInstanceReference = exports.getRefLayer = exports.isLayerReference = exports.getRefClass = exports.isClassReference = exports.getRefObjectId = exports.isObjectReference = void 0;\nconst lib_1 = require(\"./lib\");\nconst performance_1 = require(\"./performance\");\n/*\n * References are strings that are added to instances,\n * to indicate what objects, layers or classes they are derived from.\n */\nfunction isObjectReference(ref) {\n    return ref.startsWith('#');\n}\nexports.isObjectReference = isObjectReference;\nfunction getRefObjectId(ref) {\n    return ref.slice(1);\n}\nexports.getRefObjectId = getRefObjectId;\nfunction isClassReference(ref) {\n    return ref.startsWith('.');\n}\nexports.isClassReference = isClassReference;\nfunction getRefClass(ref) {\n    return ref.slice(1);\n}\nexports.getRefClass = getRefClass;\nfunction isLayerReference(ref) {\n    return ref.startsWith('$');\n}\nexports.isLayerReference = isLayerReference;\nfunction getRefLayer(ref) {\n    return ref.slice(1);\n}\nexports.getRefLayer = getRefLayer;\nfunction isInstanceReference(ref) {\n    return ref.startsWith('@');\n}\nexports.isInstanceReference = isInstanceReference;\nfunction getRefInstanceId(ref) {\n    return ref.slice(1);\n}\nexports.getRefInstanceId = getRefInstanceId;\n/** Add / join references Arrays. Returns a sorted list of unique references */\nfunction joinReferences(references, ...addReferences) {\n    const toc = (0, performance_1.tic)('     joinReferences');\n    // Fast path: When nothing is added, return the original references:\n    if (addReferences.length === 1 && typeof addReferences[0] !== 'string' && addReferences[0].length === 0) {\n        return [...references];\n    }\n    let fastPath = false;\n    let resultingRefs = [];\n    // Fast path: When a single ref is added\n    if (addReferences.length === 1 && typeof addReferences[0] === 'string') {\n        if (references.includes(addReferences[0])) {\n            // The value already exists, return the original references:\n            return [...references];\n        }\n        else {\n            // just quickly add the reference and jump forward to sorting of resultingRefs:\n            resultingRefs = [...references];\n            resultingRefs.push(addReferences[0]);\n            fastPath = true;\n        }\n    }\n    if (!fastPath) {\n        const refSet = new Set();\n        for (const ref of references) {\n            if (!refSet.has(ref)) {\n                refSet.add(ref);\n                resultingRefs.push(ref);\n            }\n        }\n        for (const addReference of addReferences) {\n            if (typeof addReference === 'string') {\n                if (!refSet.has(addReference)) {\n                    refSet.add(addReference);\n                    resultingRefs.push(addReference);\n                }\n            }\n            else {\n                for (const ref of addReference) {\n                    if (!refSet.has(ref)) {\n                        refSet.add(ref);\n                        resultingRefs.push(ref);\n                    }\n                }\n            }\n        }\n    }\n    resultingRefs.sort(lib_1.compareStrings);\n    toc();\n    return resultingRefs;\n}\nexports.joinReferences = joinReferences;\nfunction isReference(ref) {\n    return ref !== null && typeof ref.value === 'number';\n}\nexports.isReference = isReference;\n//# sourceMappingURL=reference.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objHasLayer = void 0;\n/**\n * Returns true if object has a layer.\n * Note: Objects without a layer are called \"transparent objects\",\n * and won't be present in the resolved state.\n */\nfunction objHasLayer(obj) {\n    return obj.layer !== undefined && obj.layer !== '' && obj.layer !== null;\n}\nexports.objHasLayer = objHasLayer;\n//# sourceMappingURL=timeline.js.map","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global global, define, Symbol, Reflect, Promise, SuppressedError */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __esDecorate;\r\nvar __runInitializers;\r\nvar __propKey;\r\nvar __setFunctionName;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __spreadArray;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __classPrivateFieldIn;\r\nvar __createBinding;\r\nvar __addDisposableResource;\r\nvar __disposeResources;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n        function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n        var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n        var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n        var _, done = false;\r\n        for (var i = decorators.length - 1; i >= 0; i--) {\r\n            var context = {};\r\n            for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n            for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n            context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n            var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n            if (kind === \"accessor\") {\r\n                if (result === void 0) continue;\r\n                if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n                if (_ = accept(result.get)) descriptor.get = _;\r\n                if (_ = accept(result.set)) descriptor.set = _;\r\n                if (_ = accept(result.init)) initializers.unshift(_);\r\n            }\r\n            else if (_ = accept(result)) {\r\n                if (kind === \"field\") initializers.unshift(_);\r\n                else descriptor[key] = _;\r\n            }\r\n        }\r\n        if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n        done = true;\r\n    };\r\n\r\n    __runInitializers = function (thisArg, initializers, value) {\r\n        var useValue = arguments.length > 2;\r\n        for (var i = 0; i < initializers.length; i++) {\r\n            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n        }\r\n        return useValue ? value : void 0;\r\n    };\r\n\r\n    __propKey = function (x) {\r\n        return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n    };\r\n\r\n    __setFunctionName = function (f, name, prefix) {\r\n        if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n        return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function(m, o) {\r\n        for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n    };\r\n\r\n    __createBinding = Object.create ? (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        var desc = Object.getOwnPropertyDescriptor(m, k);\r\n        if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n            desc = { enumerable: true, get: function() { return m[k]; } };\r\n        }\r\n        Object.defineProperty(o, k2, desc);\r\n    }) : (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    });\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __spreadArray = function (to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || Array.prototype.slice.call(from));\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    var __setModuleDefault = Object.create ? (function(o, v) {\r\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n    }) : function(o, v) {\r\n        o[\"default\"] = v;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n        __setModuleDefault(result, mod);\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n    };\r\n\r\n    __classPrivateFieldIn = function (state, receiver) {\r\n        if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n        return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n    };\r\n\r\n    __addDisposableResource = function (env, value, async) {\r\n        if (value !== null && value !== void 0) {\r\n            if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n            var dispose;\r\n            if (async) {\r\n                if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n                dispose = value[Symbol.asyncDispose];\r\n            }\r\n            if (dispose === void 0) {\r\n                if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n                dispose = value[Symbol.dispose];\r\n            }\r\n            if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n            env.stack.push({ value: value, dispose: dispose, async: async });\r\n        }\r\n        else if (async) {\r\n            env.stack.push({ async: true });\r\n        }\r\n        return value;\r\n    };\r\n\r\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n        var e = new Error(message);\r\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n    };\r\n\r\n    __disposeResources = function (env) {\r\n        function fail(e) {\r\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n            env.hasError = true;\r\n        }\r\n        function next() {\r\n            while (env.stack.length) {\r\n                var rec = env.stack.pop();\r\n                try {\r\n                    var result = rec.dispose && rec.dispose.call(rec.value);\r\n                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                catch (e) {\r\n                    fail(e);\r\n                }\r\n            }\r\n            if (env.hasError) throw env.error;\r\n        }\r\n        return next();\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__esDecorate\", __esDecorate);\r\n    exporter(\"__runInitializers\", __runInitializers);\r\n    exporter(\"__propKey\", __propKey);\r\n    exporter(\"__setFunctionName\", __setFunctionName);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__spreadArray\", __spreadArray);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n    exporter(\"__classPrivateFieldIn\", __classPrivateFieldIn);\r\n    exporter(\"__addDisposableResource\", __addDisposableResource);\r\n    exporter(\"__disposeResources\", __disposeResources);\r\n});\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __createBinding = function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n        result[\"default\"] = mod;\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, privateMap) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to get private field on non-instance\");\r\n        }\r\n        return privateMap.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, privateMap, value) {\r\n        if (!privateMap.has(receiver)) {\r\n            throw new TypeError(\"attempted to set private field on non-instance\");\r\n        }\r\n        privateMap.set(receiver, value);\r\n        return value;\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n"],"preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9saWIvdGltZWxpbmVWaXN1YWxpemVyLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5pc2VxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvYXBpL2V4cHJlc3Npb24uanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9hcGkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9hcGkvcmVzb2x2ZWRUaW1lbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L2FwaS9yZXNvbHZlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L2FwaS9zdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L2FwaS90aW1lbGluZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L2FwaS90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvQ2FjaGVIYW5kbGVyLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvRXhwcmVzc2lvbkhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9JbnN0YW5jZUhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9MYXllclN0YXRlSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL1JlZmVyZW5jZUhhbmRsZXIuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9SZXNvbHZlZFRpbWVsaW5lSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL1Jlc29sdmVySGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL1N0YXRlSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL1RpbWVsaW5lVmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvbGliL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvbGliL2NhcC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2xpYi9ldmVudC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2xpYi9leHByZXNzaW9uLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvbGliL2luc3RhbmNlLmpzIiwibm9kZV9tb2R1bGVzL3N1cGVyZmx5LXRpbWVsaW5lL2Rpc3QvcmVzb2x2ZXIvbGliL2xpYi5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2xpYi9wZXJmb3JtYW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcmZseS10aW1lbGluZS9kaXN0L3Jlc29sdmVyL2xpYi9yZWZlcmVuY2UuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvZGlzdC9yZXNvbHZlci9saWIvdGltZWxpbmUuanMiLCJub2RlX21vZHVsZXMvc3VwZXJmbHktdGltZWxpbmUvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIiwibm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaENBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4ekRBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ242QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9saWIvdGltZWxpbmVWaXN1YWxpemVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UaW1lbGluZVZpc3VhbGl6ZXIgPSB2b2lkIDA7XG5jb25zdCBpc0VxdWFsID0gcmVxdWlyZShcImxvZGFzaC5pc2VxdWFsXCIpO1xuY29uc3Qgc3VwZXJmbHlfdGltZWxpbmVfMSA9IHJlcXVpcmUoXCJzdXBlcmZseS10aW1lbGluZVwiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbi8qKiBTdGVwIHNpemUvIHRpbWUgc3RlcC4gKi9cbmNvbnN0IERFRkFVTFRfU1RFUF9TSVpFID0gMTtcbi8qKiBXaWR0aCBvZiBsYWJlbCBjb2x1bW4uICovXG5jb25zdCBMQUJFTF9XSURUSF9PRl9USU1FTElORSA9IDAuMjU7XG4vKiogRGVmYXVsdCB6b29tICovXG5jb25zdCBERUZBVUxUX1pPT01fVkFMVUUgPSAxMDA7XG4vKiogRmFjdG9yIHRvIHpvb20gYnkgKi9cbmNvbnN0IFpPT01fRkFDVE9SID0gMS4wMDE7XG4vKiogRmFjdG9yIHRvIHBhbiBieSAocGFuID0gUEFOX0ZBQ1RPUiAqIFNURVBfU0laRSkgKi9cbmNvbnN0IFBBTl9GQUNUT1IgPSAxMDtcbi8qKiBNYXhpbXVtIGxheWVyIGhlaWdodCAqL1xuY29uc3QgTUFYX0xBWUVSX0hFSUdIVCA9IDYwO1xuLyoqIEFtb3VudCB0byBtb3ZlIHBsYXloZWFkIHBlciBzZWNvbmQuICovXG5jb25zdCBERUZBVUxUX1BMQVlIRUFEX1NQRUVEID0gMTtcbi8qKiBCRUdJTiBTVFlMSU5HIFZBTFVFUyAqL1xuLyoqIFRpbWVsaW5lIGJhY2tncm91bmQgY29sb3IuICovXG5jb25zdCBDT0xPUl9CQUNLR1JPVU5EID0gJyMzMzMzMzMnO1xuLyoqIExheWVyIGxhYmVsIGJhY2tncm91bmQgY29sb3IuICovXG5jb25zdCBDT0xPUl9MQUJFTF9CQUNLR1JPVU5EID0gJyM2NjY2NjYnO1xuLyoqIENvbG9yIG9mIHRoZSBydWxlciBsaW5lcyAqL1xuY29uc3QgUlVMRVJfTElORV9DT0xPUiA9ICcjOTk5OTk5Jztcbi8qKiBXaWR0aCBvZiB0aGUgcnVsZXIgbGluZXMgKi9cbmNvbnN0IFJVTEVSX0xJTkVfV0lEVEggPSAxO1xuLyoqIFBsYXloZWFkIGNvbG9yLiAqL1xuY29uc3QgQ09MT1JfUExBWUhFQUQgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuLyoqIFBsYXloZWFkIHRoaWNrbmVzcy4gKi9cbmNvbnN0IFRISUNLTkVTU19QTEFZSEVBRCA9IDU7XG4vKiogQ29sb3Igb2YgbGluZSBzZXBhcmF0aW5nIHRpbWVsaW5lIHJvd3MuICovXG5jb25zdCBDT0xPUl9MSU5FID0gJ2JsYWNrJztcbi8qKiBIZWlnaHQgb2YgbGluZSBzZXBhcmF0aW5nIHJvd3MuICovXG5jb25zdCBUSElDS05FU1NfTElORSA9IDE7XG4vKiogVGV4dCBwcm9wZXJ0aWVzLiAqL1xuY29uc3QgVEVYVF9GT05UX0ZBTUlMWSA9ICdDYWxpYnJpJztcbmNvbnN0IFRFWFRfRk9OVF9TSVpFID0gMTY7XG5jb25zdCBURVhUX0NPTE9SID0gJ3doaXRlJztcbi8qKiBUaW1lbGluZSBvYmplY3QgcHJvcGVydGllcy4gKi9cbmNvbnN0IENPTE9SX1RJTUVMSU5FX09CSkVDVF9GSUxMID0gJ3JnYigyMiwgMTAyLCAyNDcsIDAuNzUpJztcbmNvbnN0IENPTE9SX1RJTUVMSU5FX09CSkVDVF9CT1JERVIgPSAncmdiYSgyMzIsIDI0MCwgMjU1LCAwLjg1KSc7XG5jb25zdCBUSElDS05FU1NfVElNRUxJTkVfT0JKRUNUX0JPUkRFUiA9IDE7XG4vKiogVGltZWxpbmUgb2JqZWN0IGhlaWdodCBhcyBhIHByb3BvcnRpb24gb2YgdGhlIHJvdyBoZWlnaHQuICovXG5jb25zdCBUSU1FTElORV9PQkpFQ1RfSEVJR0hUID0gMTtcbi8qKiBFTkQgU1RZTElORyBWQUxVRVMgKi9cbi8qKiBCRUdJTiBDT05TVEFOVFMgRk9SIFNUQVRFIE1BTkFHRU1FTlQgKi9cbmNvbnN0IE1PVVNFSU4gPSAwO1xuY29uc3QgTU9VU0VPVVQgPSAxO1xuY2xhc3MgVGltZWxpbmVWaXN1YWxpemVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzSWQgVGhlIElEIG9mIHRoZSBjYW52YXMgb2JqZWN0IHRvIGRyYXcgd2l0aGluLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNhbnZhc0lkLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gU3RlcCBzaXplLlxuICAgICAgICB0aGlzLnN0ZXBTaXplID0gREVGQVVMVF9TVEVQX1NJWkU7XG4gICAgICAgIC8qKiBAcHJpdmF0ZSBAcmVhZG9ubHkgUHJvcG9ydGlvbiBvZiB0aGUgY2FudmFzIHRvIGJlIHVzZWQgZm9yIHRoZSBsYXllciBsYWJlbHMgY29sdW1uLiAqL1xuICAgICAgICB0aGlzLl9sYXllckxhYmVsV2lkdGhQcm9wb3J0aW9uT2ZDYW52YXMgPSBMQUJFTF9XSURUSF9PRl9USU1FTElORTtcbiAgICAgICAgLyoqIExheWVycyBvbiB0aW1lbGluZS4gKi9cbiAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbHMgPSB7fTtcbiAgICAgICAgLyoqIFN0YXRlIG9mIHRoZSB0aW1lbGluZS4gKi9cbiAgICAgICAgdGhpcy5fdGltZWxpbmVTdGF0ZSA9IHt9O1xuICAgICAgICAvKiogTWFwIG9mIG9iamVjdHMgZm9yIGRldGVybWluaW5nIGhvdmVyZWQgb2JqZWN0ICovXG4gICAgICAgIHRoaXMuX2hvdmVyZWRPYmplY3RNYXAgPSB7fTtcbiAgICAgICAgLyoqIFN0YXJ0IHRpbWUgb2YgdGhlIGN1cnJlbnQgdmlldy4gRGVmaW5lcyB0aGUgb2JqZWN0cyB3aXRoaW4gdmlldyBvbiB0aGUgdGltZWxpbmUgW3RpbWVdICovXG4gICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSAwO1xuICAgICAgICAvKiogUmFuZ2Ugb2YgdGhlIGN1cnJlbnQgdmlldyBbdGltZV0gKi9cbiAgICAgICAgLy8gcHJpdmF0ZSBfdmlld1RpbWVSYW5nZTogbnVtYmVyID0gMVxuICAgICAgICAvLyBwcml2YXRlIF9kcmF3VGltZUVuZDogbnVtYmVyXG4gICAgICAgIC8qKiBTdG9yZSB3aGV0aGVyIHRoZSBtb3VzZSBpcyBoZWxkIGRvd24sIGZvciBzY3JvbGxpbmcuICovXG4gICAgICAgIHRoaXMuX21vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCB6b29tIGFtb3VudC4gKi9cbiAgICAgICAgdGhpcy5fdGltZWxpbmVab29tID0gREVGQVVMVF9aT09NX1ZBTFVFO1xuICAgICAgICAvKiogV2hldGhlciBvciBub3QgdGhlIHBsYXloZWFkIHNob3VsZCBtb3ZlLiAqL1xuICAgICAgICB0aGlzLl9wbGF5SGVhZFBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqIFNwZWVkIG9mIHRoZSBwbGF5aGVhZCBbdW5pdHMgLyBzZWNvbmRdICovXG4gICAgICAgIHRoaXMuX3BsYXlTcGVlZCA9IERFRkFVTFRfUExBWUhFQURfU1BFRUQ7XG4gICAgICAgIC8qKiBUaGUgY3VycmVudCB0aW1lIHBvc2l0aW9uIG9mIHRoZSBwbGF5aGVhZC4gKi9cbiAgICAgICAgdGhpcy5fcGxheUhlYWRUaW1lID0gMDtcbiAgICAgICAgLyoqIFRoZSBsYXN0IHRpbWUgdXBkYXRlRHJhdygpIGRpZCBhIGRyYXcuICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA9IDA7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBtb3VzZSBsYXN0IG1vdmVkIG92ZXIgYW4gb2JqZWN0IG9yIG91dC4gKi9cbiAgICAgICAgdGhpcy5fbGFzdEhvdmVyQWN0aW9uID0gTU9VU0VPVVQ7XG4gICAgICAgIC8qKiBOYW1lIG9mIG9iamVjdCB0aGF0IHdhcyBsYXN0IGhvdmVyZWQgb3Zlci4gKi9cbiAgICAgICAgdGhpcy5fbGFzdEhvdmVyZWRIYXNoID0gJyc7XG4gICAgICAgIC8qKiBJZiB0aGUgdmlzdWFsaXplciBhdXRvbWF0aWNhbGx5IHNob3VsZCByZS1yZXNvbHZlIHRoZSB0aW1lbGluZSB3aGVuIG5hdmlnYXRpbmcgdGhlIHZpZXdwb3J0ICovXG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8gPSBmYWxzZTtcbiAgICAgICAgLyoqIEF0IHdoYXQgdGltZSB0aGUgdGltZWxpbmUgd2FzIHJlc29sdmVkIFt0aW1lXSAqL1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVTdGFydCA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUVuZCA9IDA7XG4gICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVpvb20gPSAxO1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudCA9IDEwMDtcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QgPSAxO1xuICAgICAgICAvKiogSG93IG11Y2ggZXh0cmEgKG91dHNpZGUgdGhlIGN1cnJlbnQgdmlld3BvcnQpIHRoZSB0aW1lbGluZSBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gW3JhdGlvXSAqL1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVFeHBhbmQgPSAzO1xuICAgICAgICB0aGlzLmxhdGVzdFVwZGF0ZVRpbWUgPSAwO1xuICAgICAgICB0aGlzLnJlcmVzb2x2ZVRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLl9tZXJnZUl0ZXJhdG9yID0gMDtcbiAgICAgICAgLy8gSW5pdGlhbGlzZSBvdGhlciB2YWx1ZXMuXG4gICAgICAgIHRoaXMuX2NhbnZhc0lkID0gY2FudmFzSWQ7XG4gICAgICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgICAgICB0aGlzLl9kcmF3UGxheWhlYWQgPSAhIW9wdGlvbnMuZHJhd1BsYXloZWFkO1xuICAgICAgICAvLyBDYWxjdWxhdGUgd2lkdGggb2YgbGFiZWwgY29sdW1uLlxuICAgICAgICB0aGlzLl9sYXllckxhYmVsV2lkdGggPSB0aGlzLl9jYW52YXNXaWR0aCAqIHRoaXMuX2xheWVyTGFiZWxXaWR0aFByb3BvcnRpb25PZkNhbnZhcztcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRpbWVsaW5lIHdpZHRoIGFuZCBzdGFydCBwb2ludC5cbiAgICAgICAgdGhpcy5fdmlld0RyYXdYID0gdGhpcy5fbGF5ZXJMYWJlbFdpZHRoO1xuICAgICAgICB0aGlzLl92aWV3RHJhd1dpZHRoID0gdGhpcy5fY2FudmFzV2lkdGggLSB0aGlzLl9sYXllckxhYmVsV2lkdGg7XG4gICAgICAgIC8vIERyYXcgYmFja2dyb3VuZC5cbiAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICAvLyBEcmF3IHBsYXloZWFkLlxuICAgICAgICB0aGlzLmRyYXdQbGF5aGVhZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZURyYXcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZXMgdGhlIGNhbnZhcyBhbmQgcmVnaXN0ZXJzIGNhbnZhcyBldmVudHMuXG4gICAgICovXG4gICAgaW5pdENhbnZhcygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIG5ldyBjYW52YXMgb2JqZWN0LlxuICAgICAgICB0aGlzLl9jYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLl9jYW52YXNJZCk7XG4gICAgICAgIGlmICghdGhpcy5fY2FudmFzQ29udGFpbmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW52YXMgXCIke3RoaXMuX2NhbnZhc0lkfVwiIG5vdCBmb3VuZGApO1xuICAgICAgICAvLyBHZXQgcmVuZGVyaW5nIGNvbnRleHQuXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAvLyBSZWdpc3RlciBjYW52YXMgaW50ZXJhY3Rpb24gZXZlbnQgaGFuZGxlcnMuXG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZXZlbnQpID0+IHRoaXMuY2FudmFzTW91c2VEb3duKGV2ZW50KSk7XG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc01vdXNlVXAoZXZlbnQpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChldmVudCkgPT4gdGhpcy5jYW52YXNNb3VzZU1vdmUoZXZlbnQpKTtcbiAgICAgICAgdGhpcy5fY2FudmFzQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgKGV2ZW50KSA9PiB0aGlzLmNhbnZhc1Njcm9sbFdoZWVsKGV2ZW50KSk7XG4gICAgICAgIC8vIEdldCB3aWR0aCBhbmQgaGVpZ2h0IG9mIGNhbnZhcy5cbiAgICAgICAgdGhpcy5fY2FudmFzV2lkdGggPSB0aGlzLl9jYW52YXNDb250YWluZXIud2lkdGg7XG4gICAgICAgIHRoaXMuX2NhbnZhc0hlaWdodCA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci5oZWlnaHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRpbWVsaW5lLCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gYWN0aW9ucyBhcmUgYWRkZWQvcmVtb3ZlZCBmcm9tIGEgdGltZWxpbmVcbiAgICAgKiBidXQgdGhlIHNhbWUgdGltZWxpbmUgaXMgYmVpbmcgZHJhd24uXG4gICAgICogQHBhcmFtIHtUaW1lbGluZU9iamVjdFtdfSB0aW1lbGluZSBUaW1lbGluZSB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7UmVzb2x2ZU9wdGlvbnN9IG9wdGlvbnMgUmVzb2x2ZSBvcHRpb25zLlxuICAgICAqL1xuICAgIHVwZGF0ZVRpbWVsaW5lKHRpbWVsaW5lLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIElmIG9wdGlvbnMgaGF2ZSBub3QgYmVlbiBzcGVjaWZpZWQgc2V0IHRpbWUgdG8gMC5cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgICAgIGxpbWl0Q291bnQ6IDEwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0VGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICAgICAgdGhpcy5sYXRlc3RPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRpb25zLmxpbWl0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlQXV0byA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9uczIgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUF1dG8pIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGltZWxpbmVSZXNvbHZlV2luZG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkVGltZWxpbmUgPT09IHVuZGVmaW5lZCkgeyAvLyBJZiBmaXJzdCB0aW1lIHRoaXMgcnVuc1xuICAgICAgICAgICAgLy8gU2V0IHRpbWVsaW5lIHN0YXJ0IGFuZCBlbmQgdGltZXMuXG4gICAgICAgICAgICBpZiAob3B0aW9uczIudGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld1N0YXJ0VGltZSA9IG9wdGlvbnMyLnRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNb3ZlIHBsYXloZWFkIHRvIHN0YXJ0IHRpbWUuXG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgPSB0aGlzLl92aWV3U3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVsaW5lKHRydWUpO1xuICAgIH1cbiAgICBfdXBkYXRlVGltZWxpbmUoZnJvbU5ld1RpbWVsaW5lID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uczIgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxhdGVzdE9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5fdGltZWxpbmVSZXNvbHZlQXV0bykge1xuICAgICAgICAgICAgb3B0aW9uczIudGltZSA9IHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVN0YXJ0O1xuICAgICAgICAgICAgb3B0aW9uczIubGltaXRUaW1lID0gdGhpcy5fdGltZWxpbmVSZXNvbHZlRW5kO1xuICAgICAgICAgICAgb3B0aW9uczIubGltaXRDb3VudCA9IE1hdGguY2VpbCh0aGlzLl90aW1lbGluZVJlc29sdmVDb3VudCAqIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUNvdW50QWRqdXN0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgcGxheWhlYWQgaXMgYmVpbmcgZHJhd24sIHRoZSByZXNvbHZlIHRpbWUgc2hvdWxkIGJlIGF0IHRoZSBwbGF5aGVhZCB0aW1lLlxuICAgICAgICBpZiAodGhpcy5fZHJhd1BsYXloZWFkICYmIHRoaXMuX3BsYXlIZWFkVGltZSA+IG9wdGlvbnMyLnRpbWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMyLnRpbWUgPSB0aGlzLl9wbGF5SGVhZFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGltZWxpbmUuXG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzb2x2ZSA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkVGltZWxpbmUgPSAoMCwgc3VwZXJmbHlfdGltZWxpbmVfMS5yZXNvbHZlVGltZWxpbmUpKHRoaXMubGF0ZXN0VGltZWxpbmUsIG9wdGlvbnMyKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkVGltZWxpbmUgPT09IHVuZGVmaW5lZCkgeyAvLyBJZiBmaXJzdCB0aW1lIHRoaXMgcnVuc1xuICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd1BsYXloZWFkKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgY3VycmVudCB0aW1lbGluZTpcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRUaW1lbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNZXJnZSB0aGUgdGltZWxpbmVzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlZFRpbWVsaW5lID0gdGhpcy5tZXJnZVRpbWVsaW5lT2JqZWN0cyh0aGlzLl9yZXNvbHZlZFRpbWVsaW5lLCByZXNvbHZlZFRpbWVsaW5lLCBmcm9tTmV3VGltZWxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB3ZSBvbmx5IHNlZSBvbmUgdGltZWxpbmUgYXQgYSB0aW1lLlxuICAgICAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgcHJldmlvdXMgdGltZWxpbmU6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGxheWVycy5cbiAgICAgICAgdGhpcy51cGRhdGVMYXllckxhYmVscygpO1xuICAgICAgICB0aGlzLmxhdGVzdFVwZGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRSZXNvbHZlO1xuICAgICAgICAvLyBSZWRyYXcgdGhlIHRpbWVsaW5lLlxuICAgICAgICB0aGlzLnJlZHJhd1RpbWVsaW5lKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0VXBkYXRlVGltZSA9IERhdGUubm93KCkgLSBzdGFydFJlc29sdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZpZXdwb3J0IHRvIGEgcG9zaXRpb24sIHpvb20sIGFuZCBwbGF5YmFjayBzcGVlZC5cbiAgICAgKiBQbGF5YmFjayBzcGVlZCBjdXJyZW50bHkgbm90IGltcGxlbWVudGVkLlxuICAgICAqIEBwYXJhbSB2aWV3UG9ydCBPYmplY3QgdG8gdXBkYXRlIHZpZXdwb3J0IHdpdGguXG4gICAgICovXG4gICAgc2V0Vmlld1BvcnQodmlld1BvcnQpIHtcbiAgICAgICAgLy8gV2hldGhlciB0aGUgdmlld3BvcnQgaGFzIGNoYW5nZWQuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHpvb20gaGFzIGJlZW4gc3BlY2lmaWVkLlxuICAgICAgICBpZiAodmlld1BvcnQuem9vbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBab29tIHRvIHNwZWNpZmllZCB6b29tLlxuICAgICAgICAgICAgdGhpcy5fdGltZWxpbmVab29tID0gdmlld1BvcnQuem9vbTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRpbWVzdGFtcCBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gICAgICAgIGlmICh2aWV3UG9ydC50aW1lc3RhbXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IHN0YXJ0IHRpbWUgdG8gc3BlY2lmaWVkIHRpbWUuXG4gICAgICAgICAgICBpZiAodmlld1BvcnQudGltZXN0YW1wID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgPSB2aWV3UG9ydC50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXdQb3J0LnBsYXlWaWV3UG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wbGF5Vmlld1BvcnQgPSB2aWV3UG9ydC5wbGF5Vmlld1BvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHBsYXliYWNrIHNwZWVkIGhhcyBiZWVuIHNldCwgc2V0IHRoZSBuZXcgcGxheWJhY2sgc3BlZWQuXG4gICAgICAgIGlmICh2aWV3UG9ydC5wbGF5U3BlZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRWaWV3UG9ydDogdmlld1BvcnQucGxheVNwZWVkIHdhcyBzZXQsIGJ1dCBkcmF3UGxheWhlYWQgd2FzIG5vdCBzZXQgaW4gY29uc3RydWN0b3InKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXlTcGVlZCA9IHZpZXdQb3J0LnBsYXlTcGVlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgcGxheWhlYWQgcGxheWluZy8gbm90IHBsYXlpbmcuXG4gICAgICAgIGlmICh2aWV3UG9ydC5wbGF5UGxheWhlYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3UGxheWhlYWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRWaWV3UG9ydDogdmlld1BvcnQucGxheVBsYXloZWFkIHdhcyBzZXQsIGJ1dCBkcmF3UGxheWhlYWQgd2FzIG5vdCBzZXQgaW4gY29uc3RydWN0b3InKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYXlIZWFkUGxheWluZyA9IHZpZXdQb3J0LnBsYXlQbGF5aGVhZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlld1BvcnQucGxheWhlYWRUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZHJhd1BsYXloZWFkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0Vmlld1BvcnQ6IHZpZXdQb3J0LnBsYXloZWFkVGltZSB3YXMgc2V0LCBidXQgZHJhd1BsYXloZWFkIHdhcyBub3Qgc2V0IGluIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgPSBNYXRoLm1heCgwLCB2aWV3UG9ydC5wbGF5aGVhZFRpbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXlIZWFkVGltZSA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID0gdGhpcy5fcGxheUhlYWRUaW1lO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lIGlmIGFueXRoaW5nIGhhcyBjaGFuZ2VkLlxuICAgICAgICBpZiAoY2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lbGluZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2Vzc29yIGZvciBwb2xsaW5nIHRoZSBjdXJyZW50bHkgaG92ZXJlZCBvdmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXRIb3ZlcmVkT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faG92ZXJlZE92ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGhlaWdodCB0byBnaXZlIHRvIGVhY2ggcm93IHRvIGZpdCBhbGwgbGF5ZXJzIG9uIHNjcmVlbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBsYXllcnMgTWFwIG9mIGxheWVycyB0byB1c2UuXG4gICAgICogQHJldHVybnMgSGVpZ2h0IG9mIHJvd3MuXG4gICAgICovXG4gICAgY2FsY3VsYXRlUm93SGVpZ2h0KGxheWVycykge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTUFYX0xBWUVSX0hFSUdIVCwgdGhpcy5fY2FudmFzSGVpZ2h0IC8gT2JqZWN0LmtleXMobGF5ZXJzKS5sZW5ndGgpO1xuICAgIH1cbiAgICB1cGRhdGVMYXllckxhYmVscygpIHtcbiAgICAgICAgLy8gU3RvcmUgbGF5ZXJzIHRvIGRyYXcuXG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmdldExheWVyc1RvRHJhdygpO1xuICAgICAgICBpZiAoIWlzRXF1YWwodGhpcy5fbGF5ZXJMYWJlbHMsIG8ubGF5ZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJMYWJlbHMgPSBvLmxheWVycztcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByb3cgaGVpZ2h0LlxuICAgICAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGVSb3dIZWlnaHQodGhpcy5fbGF5ZXJMYWJlbHMpO1xuICAgICAgICAgICAgLy8gU2V0IHRpbWVsaW5lIG9iamVjdCBoZWlnaHQuXG4gICAgICAgICAgICB0aGlzLl90aW1lbGluZU9iamVjdEhlaWdodCA9IHRoaXMuX3Jvd0hlaWdodCAqIFRJTUVMSU5FX09CSkVDVF9IRUlHSFQ7XG4gICAgICAgICAgICB0aGlzLl9udW1iZXJPZkxheWVycyA9IE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTGFiZWxzKS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl9yb3dzVG90YWxIZWlnaHQgPSB0aGlzLl9yb3dIZWlnaHQgKiB0aGlzLl9udW1iZXJPZkxheWVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMYXllcnMoKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2xheWVyTGFiZWxzKTtcbiAgICAgICAgbGF5ZXJzLnNvcnQoKGEsIGIpID0+IGFbMV0gLSBiWzFdKTtcbiAgICAgICAgcmV0dXJuIGxheWVycy5tYXAobCA9PiBsWzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGxheWVyIGxhYmVscyB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGRyYXdMYXllckxhYmVscygpIHtcbiAgICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBsYXllcnMuXG4gICAgICAgIGZvciAobGV0IGxheWVyTmFtZSBvZiB0aGlzLmdldExheWVycygpKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFN0eWxlID0gQ09MT1JfTEFCRUxfQkFDS0dST1VORDtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCgwLCByb3cgKiB0aGlzLl9yb3dIZWlnaHQsIHRoaXMuX2xheWVyTGFiZWxXaWR0aCwgdGhpcy5fcm93SGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBURVhUX0NPTE9SO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZvbnQgPSBURVhUX0ZPTlRfU0laRS50b1N0cmluZygpICsgJ3B4ICcgKyBURVhUX0ZPTlRfRkFNSUxZO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxUZXh0KGxheWVyTmFtZSwgMCwgKHJvdyAqIHRoaXMuX3Jvd0hlaWdodCkgKyAodGhpcy5fcm93SGVpZ2h0IC8gMiksIHRoaXMuX2xheWVyTGFiZWxXaWR0aCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9MSU5FO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdCh0aGlzLl9sYXllckxhYmVsV2lkdGgsIHJvdyAqIHRoaXMuX3Jvd0hlaWdodCwgdGhpcy5fdmlld0RyYXdXaWR0aCwgVEhJQ0tORVNTX0xJTkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIHRpbWVsaW5lIGJhY2tncm91bmQuXG4gICAgICovXG4gICAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9CQUNLR1JPVU5EO1xuICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFJlY3QoMCwgMCwgdGhpcy5fY2FudmFzV2lkdGgsIHRoaXMuX2NhbnZhc0hlaWdodCk7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmRSdWxlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3IGEgcnVsZXIgb24gdG9wIG9mIGJhY2tncm91bmRcbiAgICAgKi9cbiAgICBkcmF3QmFja2dyb3VuZFJ1bGVyKCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMudmlld1JhbmdlO1xuICAgICAgICBjb25zdCBlbmRUaW1lID0gdGhpcy52aWV3RW5kVGltZTtcbiAgICAgICAgY29uc3QgY2lyY2FOdW1iZXJPZkxpbmVzID0gNTtcbiAgICAgICAgY29uc3Qgcm91bmRlciA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nMTAocmFuZ2UgLyBjaXJjYU51bWJlck9mTGluZXMpKSk7IC8vIFdoYXQgdG8gcm91bmQgdGhlIHJ1bGVyIHRvXG4gICAgICAgIGNvbnN0IHJvdW5kZXJOZXh0ID0gcm91bmRlciAqIDEwO1xuICAgICAgICBjb25zdCBudW1iZXJPZkxpbmVzID0gTWF0aC5mbG9vcihyYW5nZSAvIHJvdW5kZXIpO1xuICAgICAgICBjb25zdCBydWxlckRpZmYgPSByb3VuZGVyO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBNYXRoLmZsb29yKHRoaXMuX3ZpZXdTdGFydFRpbWUgLyByb3VuZGVyKSAqIHJvdW5kZXI7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSAoTWF0aC5taW4oMSwgY2lyY2FOdW1iZXJPZkxpbmVzIC8gbnVtYmVyT2ZMaW5lcykpO1xuICAgICAgICBpZiAocnVsZXJEaWZmKSB7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3Ryb2tlU3R5bGUgPSBSVUxFUl9MSU5FX0NPTE9SO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmxpbmVXaWR0aCA9IFJVTEVSX0xJTkVfV0lEVEg7XG4gICAgICAgICAgICBmb3IgKGxldCBydWxlclRpbWUgPSBzdGFydFRpbWU7IHJ1bGVyVGltZSA8IGVuZFRpbWU7IHJ1bGVyVGltZSArPSBydWxlckRpZmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgbGV0IHggPSB0aGlzLnRpbWVUb1hDb29yZChydWxlclRpbWUpO1xuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZVRvTmV4dCA9IChydWxlclRpbWUgLyByb3VuZGVyTmV4dCkgJSAxO1xuICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvTmV4dCA+IDAuNSlcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VUb05leHQgLT0gMTtcbiAgICAgICAgICAgICAgICBkaXN0YW5jZVRvTmV4dCA9IE1hdGguYWJzKGRpc3RhbmNlVG9OZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VUb05leHQgPCAwLjAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGEgc2lnbmlmaWNhbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZ2xvYmFsQWxwaGEgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPj0gdGhpcy5fdmlld0RyYXdYKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5tb3ZlVG8oeCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5saW5lVG8oeCwgdGhpcy5fY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLmdsb2JhbEFscGhhID0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgcGxheWhlYWQgaW5pdGlhbGx5LlxuICAgICAqL1xuICAgIGRyYXdQbGF5aGVhZCgpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBsYXloZWFkIHNob3VsZCBiZSBkcmF3LlxuICAgICAgICBpZiAodGhpcy5fZHJhd1BsYXloZWFkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc3RpbWVJblZpZXcodGhpcy5fcGxheUhlYWRUaW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsU3R5bGUgPSBDT0xPUl9QTEFZSEVBRDtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFJlY3QodGhpcy50aW1lVG9YQ29vcmQodGhpcy5fcGxheUhlYWRUaW1lKSwgMCwgVEhJQ0tORVNTX1BMQVlIRUFELCB0aGlzLl9jYW52YXNIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxheWVycyB0byBkcmF3IGZyb20gdGhlIHRpbWVsaW5lLlxuICAgICAqL1xuICAgIGdldExheWVyc1RvRHJhdygpIHtcbiAgICAgICAgdGhpcy5faG92ZXJlZE9iamVjdE1hcCA9IHt9O1xuICAgICAgICBjb25zdCBsYXllcnNBcnJheSA9IHRoaXMuX3Jlc29sdmVkVGltZWxpbmUgPyBPYmplY3Qua2V5cyh0aGlzLl9yZXNvbHZlZFRpbWVsaW5lLmxheWVycykgOiBbXTtcbiAgICAgICAgbGF5ZXJzQXJyYXkuc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0ge307XG4gICAgICAgIGxheWVyc0FycmF5LmZvckVhY2goKGxheWVyTmFtZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGxheWVyc1tsYXllck5hbWVdID0gaW5kZXg7XG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW2xheWVyTmFtZV0gPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXllcnM6IGxheWVycyxcbiAgICAgICAgICAgIGxheWVyc0FycmF5OiBsYXllcnNBcnJheVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRyYXdzIHRoZSB0aW1lbGluZSB0byB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIHJlZHJhd1RpbWVsaW5lKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhc1dpZHRoLCB0aGlzLl9jYW52YXNIZWlnaHQpO1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0xheWVyTGFiZWxzKCk7XG4gICAgICAgIC8vIFJlY29tcHV0ZSBvYmplY3RzIHBvc2l0aW9uc1xuICAgICAgICB0aGlzLl90aW1lbGluZVN0YXRlID0gdGhpcy5nZXRUaW1lbGluZURyYXdTdGF0ZSh0aGlzLl9yZXNvbHZlZFRpbWVsaW5lKTtcbiAgICAgICAgLy8gRHJhdyB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgICAgdGhpcy5kcmF3VGltZWxpbmVTdGF0ZSh0aGlzLl90aW1lbGluZVN0YXRlKTtcbiAgICAgICAgdGhpcy5kcmF3UGxheWhlYWQoKTtcbiAgICAgICAgdGhpcy5jaGVja0F1dG9tYXRpY1JlcmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHRpbWVsaW5lIHN0YXRlIHRvIHRoZSBjYW52YXMuXG4gICAgICogQHBhcmFtIHtUaW1lbGluZURyYXdTdGF0ZX0gY3VycmVudERyYXdTdGF0ZSBTdGF0ZSB0byBkcmF3LlxuICAgICAqL1xuICAgIGRyYXdUaW1lbGluZVN0YXRlKGN1cnJlbnREcmF3U3RhdGUpIHtcbiAgICAgICAgZm9yIChsZXQgZWxlbWVudCBpbiBjdXJyZW50RHJhd1N0YXRlKSB7XG4gICAgICAgICAgICBjb25zdCBkcmF3U3RhdGUgPSBjdXJyZW50RHJhd1N0YXRlW2VsZW1lbnRdO1xuICAgICAgICAgICAgaWYgKGRyYXdTdGF0ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLmZpbGxTdHlsZSA9IENPTE9SX1RJTUVMSU5FX09CSkVDVF9GSUxMO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsUmVjdChkcmF3U3RhdGUubGVmdCwgZHJhd1N0YXRlLnRvcCwgZHJhd1N0YXRlLndpZHRoLCBkcmF3U3RhdGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuc3Ryb2tlU3R5bGUgPSBDT0xPUl9USU1FTElORV9PQkpFQ1RfQk9SREVSO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5saW5lV2lkdGggPSBUSElDS05FU1NfVElNRUxJTkVfT0JKRUNUX0JPUkRFUjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuc3Ryb2tlUmVjdChkcmF3U3RhdGUubGVmdCwgZHJhd1N0YXRlLnRvcCwgZHJhd1N0YXRlLndpZHRoLCBkcmF3U3RhdGUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZmlsbFN0eWxlID0gVEVYVF9DT0xPUjtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuZm9udCA9IFRFWFRfRk9OVF9TSVpFLnRvU3RyaW5nKCkgKyAncHggJyArIFRFWFRfRk9OVF9GQU1JTFk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FudmFzLnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5maWxsVGV4dChkcmF3U3RhdGUudGl0bGUsIGRyYXdTdGF0ZS5sZWZ0LCBkcmF3U3RhdGUudG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkcmF3IHN0YXRlcyBmb3IgYWxsIHRpbWVsaW5lIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtSZXNvbHZlZFRpbWVsaW5lfSB0aW1lbGluZSBUaW1lbGluZSB0byBkcmF3LlxuICAgICAqIEByZXR1cm5zIHtUaW1lbGluZURyYXdTdGF0ZX0gU3RhdGUgb2YgdGltZS1iYXNlZCBvYmplY3RzLlxuICAgICAqL1xuICAgIGdldFRpbWVsaW5lRHJhd1N0YXRlKHRpbWVsaW5lKSB7XG4gICAgICAgIGxldCBjdXJyZW50RHJhd1N0YXRlID0ge307XG4gICAgICAgIGlmICh0aW1lbGluZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgb2JqSWQgaW4gdGltZWxpbmUub2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGxldCB0aW1lbGluZU9iaiA9IHRpbWVsaW5lLm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IF9pID0gMDsgX2kgPCB0aW1lbGluZU9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnN0YW5jZU9iaiA9IHRpbWVsaW5lT2JqLnJlc29sdmVkLmluc3RhbmNlc1tfaV07XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gJ3RpbWVsaW5lT2JqZWN0OicgKyBvYmpJZCArICc6JyArIGluc3RhbmNlT2JqLmlkO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RHJhd1N0YXRlW25hbWVdID0gdGhpcy5jcmVhdGVTdGF0ZUZvck9iamVjdCh0aW1lbGluZU9iaiwgaW5zdGFuY2VPYmouc3RhcnQsIGluc3RhbmNlT2JqLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RHJhd1N0YXRlW25hbWVdLnZpc2libGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faG92ZXJlZE9iamVjdE1hcFt0aW1lbGluZU9iai5sYXllciArICcnXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT2JqZWN0TWFwW3RpbWVsaW5lT2JqLmxheWVyICsgJyddLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0WDogY3VycmVudERyYXdTdGF0ZVtuYW1lXS5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFg6IGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ubGVmdCArIGN1cnJlbnREcmF3U3RhdGVbbmFtZV0ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0UmVmSWQ6IG9iaklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlSWQ6IGluc3RhbmNlT2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0aW1lbGluZU9iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnREcmF3U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkcmF3IHN0YXRlIGZvciBhIHRpbWVsaW5lIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXIgT2JqZWN0J3MgbGF5ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IHRpbWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgdGltZS5cbiAgICAgKiBAcmV0dXJucyB7RHJhd1N0YXRlfSBTdGF0ZSBvZiB0aGUgb2JqZWN0IHRvIGRyYXcuXG4gICAgICovXG4gICAgY3JlYXRlU3RhdGVGb3JPYmplY3Qob2JqLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIERlZmF1bHQgc3RhdGUgKGhpZGRlbikuXG4gICAgICAgIGxldCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgdGl0bGU6ICdOL0EnXG4gICAgICAgIH07XG4gICAgICAgIC8vIFN0YXRlIHNob3VsZCBiZSBkZWZhdWx0IGlmIHRoZSBvYmplY3QgaXMgbm90IGJlaW5nIHNob3duLlxuICAgICAgICBpZiAodGhpcy5zaG93T25UaW1lbGluZShzdGFydCwgZW5kKSkge1xuICAgICAgICAgICAgLy8gR2V0IG9iamVjdCBkaW1lbnNpb25zIGFuZCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGxldCBvYmplY3RXaWR0aCA9IHRoaXMuZ2V0T2JqZWN0V2lkdGgoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICBsZXQgeENvb3JkID0gdGhpcy5jYXBYY29vcmRUb1ZpZXcodGhpcy50aW1lVG9YQ29vcmQoc3RhcnQpKTtcbiAgICAgICAgICAgIGxldCBvYmplY3RUb3AgPSB0aGlzLmdldE9iamVjdE9mZnNldEZyb21Ub3Aob2JqLmxheWVyICsgJycpO1xuICAgICAgICAgICAgLy8gU2V0IHN0YXRlIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBzdGF0ZS5oZWlnaHQgPSB0aGlzLl90aW1lbGluZU9iamVjdEhlaWdodDtcbiAgICAgICAgICAgIHN0YXRlLmxlZnQgPSB4Q29vcmQ7XG4gICAgICAgICAgICBzdGF0ZS50b3AgPSBvYmplY3RUb3A7XG4gICAgICAgICAgICBzdGF0ZS53aWR0aCA9IG9iamVjdFdpZHRoO1xuICAgICAgICAgICAgc3RhdGUudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICBzdGF0ZS50aXRsZSA9IG9iai5pZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG9mZnNldCwgaW4gcGl4ZWxzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB0aW1lbGluZSBmb3IgYW4gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBzdGFydCB0aW1lIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge251bWJlcn0gT2Zmc2V0IGluIHBpeGVscy5cbiAgICAgKi9cbiAgICAvLyBwcml2YXRlIGdldE9iamVjdE9mZnNldEZyb21UaW1lbGluZVN0YXJ0IChzdGFydDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAvLyBcdC8vIENhbGN1bGF0ZSBvZmZzZXQuXG4gICAgLy8gXHRsZXQgb2Zmc2V0ID0gKHN0YXJ0IC0gdGhpcy5fdmlld1N0YXJ0VGltZSkgKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWVcbiAgICAvLyBcdC8vIE9mZnNldCBjYW5ub3QgYmUgdG8gdGhlIGxlZnQgb2YgdGhlIHRpbWVsaW5lIHN0YXJ0IHBvc2l0aW9uLlxuICAgIC8vIFx0aWYgKG9mZnNldCA8IDApIHtcbiAgICAvLyBcdFx0b2Zmc2V0ID0gMFxuICAgIC8vIFx0fVxuICAgIC8vIFx0cmV0dXJuIG9mZnNldFxuICAgIC8vIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB3aWR0aCwgaW4gcGl4ZWxzLCBvZiBhbiBvYmplY3QgYmFzZWQgb24gaXRzIGR1cmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCB0aW1lIG9mIHRoZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgdGltZSBvZiB0aGUgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBnZXRPYmplY3RXaWR0aChzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgaWYgKCFlbmRUaW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhc1dpZHRoO1xuICAgICAgICAvLyBJZiB0aGUgc3RhcnQgdGltZSBpcyBsZXNzIHRoYW4gdGhlIHRpbWVsaW5lIHN0YXJ0LCBzZXQgdG8gdGltZWxpbmUgc3RhcnQuXG4gICAgICAgIGlmIChzdGFydFRpbWUgPCB0aGlzLl92aWV3U3RhcnRUaW1lKSB7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSB0aGlzLl92aWV3U3RhcnRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGN1bGF0ZSBkdXJhdGlvbiBvZiB0aGUgb2JqZWN0IHJlbWFpbmluZyBvbiB0aGUgdGltZWxpbmUuXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gICAgICAgIC8vIFJldHVybiBlbmQgcG9pbnQgcG9zaXRpb24gaW4gcGl4ZWxzLlxuICAgICAgICByZXR1cm4gZHVyYXRpb24gKiB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0byBzaG93IGFuIG9iamVjdCBvbiB0aGUgdGltZWxpbmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IE9iamVjdCBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgT2JqZWN0IGVuZCB0aW1lLlxuICAgICAqIEByZXR1cm5zIHt0cnVlfSBpZiBvYmplY3Qgc2hvdWxkIGJlIHNob3duIG9uIHRoZSB0aW1lbGluZS5cbiAgICAgKi9cbiAgICBzaG93T25UaW1lbGluZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBpc0FmdGVyID0gc3RhcnQgPj0gdGhpcy52aWV3RW5kVGltZTtcbiAgICAgICAgbGV0IGlzQmVmb3JlID0gKGVuZCB8fCBJbmZpbml0eSkgPD0gdGhpcy5fdmlld1N0YXJ0VGltZTtcbiAgICAgICAgcmV0dXJuICFpc0FmdGVyICYmICFpc0JlZm9yZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHBvc2l0aW9uIG9mIG9iamVjdCBpbnN0YW5jZSBmcm9tIHRvcCBvZiB0aW1lbGluZSBhY2NvcmRpbmcgdG8gaXRzIGxheWVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllciBPYmplY3QncyBsYXllci5cbiAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiByZWxhdGl2ZSB0byB0b3Agb2YgY2FudmFzIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBnZXRPYmplY3RPZmZzZXRGcm9tVG9wKGxheWVyTmFtZSkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXTtcbiAgICAgICAgcmV0dXJuIHRvcCAqIHRoaXMuX3Jvd0hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHBsYXloZWFkLiBDYWxsZWQgcGVyaW9kaWNhbGx5LlxuICAgICAqL1xuICAgIHVwZGF0ZURyYXcoKSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIC8vIEhvdyBsb25nIHRpbWUgc2luY2UgbGFzdCB1cGRhdGU6XG4gICAgICAgIGNvbnN0IGR0ID0gKHRoaXMuX3VwZGF0ZURyYXdMYXN0VGltZSA+IDAgP1xuICAgICAgICAgICAgbm93IC0gdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lIDpcbiAgICAgICAgICAgIDEpIC8gMTAwMDtcbiAgICAgICAgdGhpcy5fdXBkYXRlRHJhd0xhc3RUaW1lID0gbm93O1xuICAgICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aGlzLl9wbGF5U3BlZWQgKiBkdDtcbiAgICAgICAgLy8gQ2hlY2sgcGxheWhlYWQgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgICBsZXQgbmVlZFJlZHJhdyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcGxheUhlYWRQbGF5aW5nICYmIHRoaXMuX2RyYXdQbGF5aGVhZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BsYXlWaWV3UG9ydCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXN0aW1lSW5WaWV3KHRoaXMuX3BsYXlIZWFkVGltZSkgLy8gT25seSBwbGF5IGlmIHBsYXloZWFkIGlzIGluIHZpZXdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdTdGFydFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW92ZSBwbGF5aGVhZCBmb3J3YXJkXG4gICAgICAgICAgICB0aGlzLl9wbGF5SGVhZFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgICAgICAgbmVlZFJlZHJhdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRSZWRyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxsIHRoaXMgZnVuY3Rpb24gb24gbmV4dCBmcmFtZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlRHJhdygpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBtb3VzZSBkb3duIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW52YXNNb3VzZURvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gU3RvcmUgbW91c2UgaXMgZG93bi5cbiAgICAgICAgdGhpcy5fbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgLy8gU3RvcmUgWCBwb3NpdGlvbiBvZiBtb3VzZSBvbiBjbGljay5cbiAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIHVwIGV2ZW50LlxuICAgICAqIEBwYXJhbSBldmVudCBNb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW52YXNNb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIC8vIE1vdXNlIG5vIGxvbmdlciBkb3duLlxuICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBmYWxzZTtcbiAgICAgICAgLy8gUmVzZXQgc2Nyb2xsIGRpcmVjdGlvbi5cbiAgICAgICAgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9IDA7XG4gICAgICAgIC8vIFByZXZlbnQgZXZlbnQuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG1vdXNlIG1vdmVtZW50IG9uIGNhbnZhcy5cbiAgICAgKiBAcGFyYW0gZXZlbnQgTW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgY2FudmFzTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAgIC8vIElmIG1vdXNlIGlzIGRvd24uXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZURvd24pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBiZWdpbm5pbmcgc2Nyb2xsaW5nLCB3ZSBjYW4gbW92ZSBmcmVlbHkuXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBjdXJyZW50IG1vdXNlIFguXG4gICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZSBpbiBYLlxuICAgICAgICAgICAgICAgIGxldCBkZWx0YVggPSBldmVudC5jbGllbnRYIC0gdGhpcy5fbW91c2VMYXN0WDtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBzY3JvbGxpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChkZWx0YVggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gbmV3IFggcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNTY3JvbGxCeURlbHRhWCgtZGVsdGFYKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIGxldCBkaXJlY3Rpb24gPSB0aGlzLl9tb3VzZUxhc3RYIC0gZXZlbnQuY2xpZW50WDtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2luZyBkaXJlY3Rpb24sIHN0b3JlIG5ldyBkaXJlY3Rpb24gYnV0IGRvbid0IHNjcm9sbC5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uIDwgMCAmJiB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlTGFzdFggPSBldmVudC5jbGllbnRYO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsRGlyZWN0aW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA+IDAgJiYgdGhpcy5fbGFzdFNjcm9sbERpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTY3JvbGxEaXJlY3Rpb24gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNoYW5nZSBpbiBYLlxuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX21vdXNlTGFzdFg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGxhc3QgWCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW91c2VMYXN0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgYnkgY2hhbmdlIGluIFguXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoLWRlbHRhWCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVkcmF3IHRpbWVsaW5lLlxuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lbGluZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2hldGhlciBhbiBvYmplY3QgaXMgdW5kZXIgdGhlIGN1cnNvci5cbiAgICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgb2JqZWN0IHRoYXQgaXMgY3VycmVudGx5IGhvdmVyZWQgb3Zlci5cbiAgICAgICAgICAgIGxldCBtb3VzZVBvcyA9IHRoaXMuZ2V0TW91c2VQb3ModGhpcy5fY2FudmFzQ29udGFpbmVyLCBldmVudCk7XG4gICAgICAgICAgICBpZiAobW91c2VQb3MueCA+IHRoaXMuX3ZpZXdEcmF3WCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZVBvcy55IDwgdGhpcy5fcm93c1RvdGFsSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZFJvdyA9IE1hdGguZmxvb3IoKG1vdXNlUG9zLnkgLyB0aGlzLl9yb3dzVG90YWxIZWlnaHQpICogdGhpcy5fbnVtYmVyT2ZMYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2xheWVyTGFiZWxzKS5mb3JFYWNoKGxheWVyTmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJMYWJlbHNbbGF5ZXJOYW1lXSA9PT0gc2VsZWN0ZWRSb3cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIgPSBsYXllck5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaG92ZXJNYXBEYXRhID0gKGxheWVyID8gdGhpcy5faG92ZXJlZE9iamVjdE1hcFtsYXllcl0gOiBbXSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGhvdmVyTWFwRGF0YS5mb3JFYWNoKG9iamVjdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnN0YXJ0WCA8PSBtb3VzZVBvcy54ICYmIG9iamVjdC5lbmRYID49IG1vdXNlUG9zLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaG92ZXJIYXNoID0gb2JqZWN0LnR5cGUgKyBvYmplY3Qub2JqZWN0UmVmSWQgKyBvYmplY3QuaW5zdGFuY2VJZDsgLy8gaGFzaC1pc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdEhvdmVyZWRIYXNoICE9PSBob3Zlckhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG9iamVjdCBtZXRhZGF0YSBmcm9tIHRoZSBvYmplY3QgbmFtZSBvZiB0aGUgaG92ZXJlZCBvYmplY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBob3ZlcmluZyBvdmVyIGEgdGltZWxpbmUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0LnR5cGUgPT09ICd0aW1lbGluZU9iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZWxpbmUgb2JqZWN0IGFuZCB0aGUgaW5zdGFuY2UgYmVpbmcgaG92ZXJlZCBvdmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkVGltZWxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGltZWxpbmVPYmplY3QgPSB0aGlzLl9yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNbb2JqZWN0Lm9iamVjdFJlZklkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zdGFuY2UgPSB0aW1lbGluZU9iamVjdC5yZXNvbHZlZC5pbnN0YW5jZXMuZmluZChpbnN0YW5jZSA9PiBpbnN0YW5jZS5pZCA9PT0gb2JqZWN0Lmluc3RhbmNlSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgaG92ZXIgaW5mby5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhvdmVySW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdDogdGltZWxpbmVPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyOiB7IHhQb3N0aW9uOiBtb3VzZVBvcy54LCB5UG9zaXRpb246IG1vdXNlUG9zLnkgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZXQgY3VycmVudGx5IGhvdmVyZWQgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ob3ZlcmVkT3ZlciA9IGhvdmVySW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCd0aW1lbGluZTpob3ZlcicsIHsgZGV0YWlsOiB0aGlzLl9ob3ZlcmVkT3ZlciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcmUgbGFzdCBpdGVtcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0SG92ZXJBY3Rpb24gPSBNT1VTRUlOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlcmVkSGFzaCA9IGhvdmVySGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW1pdCB1bmRlZmluZWQgd2hlbiBtb3VzZSBvdXQuXG4gICAgICAgICAgICBpZiAoIWZvdW5kICYmIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9PT0gTU9VU0VJTikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgndGltZWxpbmU6aG92ZXInLCB7IGRldGFpbDogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RIb3ZlckFjdGlvbiA9IE1PVVNFT1VUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2Nyb2xsIHdoZWVsIGV2ZW50cyBvbiB0aGUgY2FudmFzLlxuICAgICAqIEBwYXJhbSBldmVudCBTY3JvbGwgZXZlbnQuXG4gICAgICovXG4gICAgY2FudmFzU2Nyb2xsV2hlZWwoZXZlbnQpIHtcbiAgICAgICAgLy8gR2V0IG1vdXNlIHBvaW50ZXIgY29vcmRpbmF0ZXMgb24gY2FudmFzLlxuICAgICAgICBsZXQgY2FudmFzQ29vcmQgPSB0aGlzLmdldE1vdXNlUG9zKHRoaXMuX2NhbnZhc0NvbnRhaW5lciwgZXZlbnQpO1xuICAgICAgICAvLyBEb24ndCBzY3JvbGwgaWYgbW91c2UgaXMgbm90IG92ZXIgdGltZWxpbmUuXG4gICAgICAgIGlmIChjYW52YXNDb29yZC54IDw9IHRoaXMuX3ZpZXdEcmF3WCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIC8vIENUUkwgKyBzY3JvbGwgdG8gem9vbS5cbiAgICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kZWx0YVkpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gTWF0aC5wb3coWk9PTV9GQUNUT1IsIC1ldmVudC5kZWx0YVkpO1xuICAgICAgICAgICAgICAgIHRoaXMuem9vbVVuZGVyQ3Vyc29yKGNhbnZhc0Nvb3JkLngsIHpvb21GYWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmRlbHRhWCAhPT0gMCkgeyAvLyBTY3JvbGwgb24geC1heGlzXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFBhbi5cbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoKGV2ZW50LmRlbHRhWCAqIChQQU5fRkFDVE9SICogdGhpcy5zdGVwU2l6ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5kZWx0YVkgIT09IDAgJiYgZXZlbnQuYWx0S2V5ID09PSB0cnVlKSB7IC8vIEFsc28gc2Nyb2xsIG9uIGFsdC1rZXkgKyBzY3JvbGwgeS1heGlzXG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFBhbi5cbiAgICAgICAgICAgIHRoaXMuY2FudmFzU2Nyb2xsQnlEZWx0YVgoKGV2ZW50LmRlbHRhWSAqIChQQU5fRkFDVE9SICogdGhpcy5zdGVwU2l6ZSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGV2ZW50LlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIFJlZHJhdyB0aW1lbGluZS5cbiAgICAgICAgICAgIHRoaXMucmVkcmF3VGltZWxpbmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgYWNyb3NzIHRoZSBjYW52YXMgYnkgYSBzcGVjaWZpZWQgWCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFYIFZhbHVlIHRvIG1vdmUgYnkuXG4gICAgICovXG4gICAgY2FudmFzU2Nyb2xsQnlEZWx0YVgoZGVsdGFYKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc3RhcnRpbmcgdGltZS5cbiAgICAgICAgbGV0IHRhcmdldFN0YXJ0ID0gdGhpcy5fdmlld1N0YXJ0VGltZSArIChkZWx0YVggLyB0aGlzLnBpeGVsc1dpZHRoUGVyVW5pdFRpbWUpO1xuICAgICAgICAvLyBTdGFydGluZyB0aW1lIGNhbm5vdCBiZSA8IDAuXG4gICAgICAgIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICAgICAgICAgIHRhcmdldFN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPcHRpbWlzYXRpb24sIGRvbid0IHJlZHJhdyBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgICAgICBpZiAodGFyZ2V0U3RhcnQgPT09IHRoaXMuX3ZpZXdTdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92aWV3U3RhcnRUaW1lID0gdGFyZ2V0U3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFpvb21zIGludG8vb3V0IG9mIHRpbWVsaW5lLCBrZWVwaW5nIHRoZSB0aW1lIHVuZGVyIHRoZSBjdXJzb3IgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIGN1cnNvclggUG9zaXRpb24gb2YgbW91c2UgY3Vyc29yLlxuICAgICAqL1xuICAgIHpvb21VbmRlckN1cnNvcihjdXJzb3JYLCB6b29tRmFjdG9yKSB7XG4gICAgICAgIC8vIFBvaW50IGluIHRpbWUgb2YgdGhlIGN1cnNvclxuICAgICAgICBsZXQgY3Vyc29yVGltZSA9IHRoaXMueENvb3JkVG9UaW1lKGN1cnNvclgpO1xuICAgICAgICAvLyBSYXRpbyAoaW4gdmlldyByYW5nZSkgb2YgdGhlIGN1cnNvclxuICAgICAgICBsZXQgY3Vyc29yUmF0aW8gPSB0aGlzLnRpbWVUb1JhdGlvKGN1cnNvclRpbWUpO1xuICAgICAgICAvLyBDaGFuZ2Ugem9vbTpcbiAgICAgICAgdGhpcy5fdGltZWxpbmVab29tID0gdGhpcy5fdGltZWxpbmVab29tICogem9vbUZhY3RvcjtcbiAgICAgICAgLy8gTGltaXQgd2l0aGluIGN1cnJlbnQgdmlld1xuICAgICAgICBjdXJzb3JSYXRpbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIGN1cnNvclJhdGlvKSk7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBzdGFydFxuICAgICAgICBsZXQgdGFyZ2V0U3RhcnQgPSBjdXJzb3JUaW1lIC0gKGN1cnNvclJhdGlvICogdGhpcy52aWV3UmFuZ2UpO1xuICAgICAgICAvLyBTdGFydCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcbiAgICAgICAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgdGFyZ2V0U3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBkcmF3IHRpbWVcbiAgICAgICAgdGhpcy5fdmlld1N0YXJ0VGltZSA9IHRhcmdldFN0YXJ0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBtb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgdG9wLWxlZnQgb2YgdGhlIGNhbnZhcyBbcGl4ZWxzXVxuICAgICAqIEBwYXJhbSBjYW52YXNcbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICogQHJldHVybnMge3g6IG51bWJlciwgeTogbnVtYmVyfSBQb3NpdGlvbi5cbiAgICAgKi9cbiAgICBnZXRNb3VzZVBvcyhjYW52YXMsIGV2dCkge1xuICAgICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogZXZ0LmNsaWVudFggLSByZWN0LmxlZnQsXG4gICAgICAgICAgICB5OiBldnQuY2xpZW50WSAtIHJlY3QudG9wXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaW1zIGEgdGltZWxpbmUgc28gdGhhdCBvYmplY3RzIG9ubHkgZXhpc3Qgd2l0aGluIGEgc3BlY2lmaWVkIHRpbWUgcGVyaW9kLlxuICAgICAqIEBwYXJhbSB0aW1lbGluZSBUaW1lbGluZSB0byB0cmltLlxuICAgICAqIEBwYXJhbSB0cmltIFRpbWVzIHRvIHRyaW0gYmV0d2Vlbi5cbiAgICAgKi9cbiAgICB0cmltVGltZWxpbmUodGltZWxpbmUsIHRyaW0pIHtcbiAgICAgICAgLy8gVGhlIG5ldyByZXNvbHZlZCBvYmplY3RzLlxuICAgICAgICBsZXQgbmV3T2JqZWN0cyA9IHt9O1xuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggcmVzb2x2ZWQgb2JqZWN0cy5cbiAgICAgICAgT2JqZWN0LmtleXModGltZWxpbmUub2JqZWN0cykuZm9yRWFjaCgob2JqSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRpbWVsaW5lLm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0aW5nSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFdoZXRoZXIgdG8gaW5zZXJ0IHRoaXMgb2JqZWN0IGludG8gdGhlIG5ldyB0aW1lbGluZS5cbiAgICAgICAgICAgICAgICBsZXQgdXNlSW5zdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSBPYmplY3QuYXNzaWduKHt9LCBpbnN0YW5jZSk7IC8vIGNsb25lXG4gICAgICAgICAgICAgICAgLy8gSWYgdHJpbW1pbmcgdGhlIHN0YXJ0IHRpbWUuXG4gICAgICAgICAgICAgICAgaWYgKHRyaW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBlbmRzIGFmdGVyIHRoZSB0cmltIHN0YXJ0IHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoaW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSA+IHRyaW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUluc3RhbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdJbnN0YW5jZS5zdGFydCA8IHRyaW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5zdGFydCA9IHRyaW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdHJpbW1pbmcgdGhlIGVuZCB0aW1lLlxuICAgICAgICAgICAgICAgIGlmICh0cmltLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHN0YXJ0cyBiZWZvcmUgdGhlIHRyaW0gZW5kIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCA8IHRyaW0uZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG5ld0luc3RhbmNlLmVuZCB8fCBJbmZpbml0eSkgPiB0cmltLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlLmVuZCA9IHRyaW0uZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdHJpbS5zdGFydCAmJiAhdHJpbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlSW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodXNlSW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2Uuc3RhcnQgPCAobmV3SW5zdGFuY2UuZW5kIHx8IEluZmluaXR5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdJbnN0YW5jZXMucHVzaChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpc24ndCBhIHJlc29sdmVkIG9iamVjdCBmb3IgdGhlIG5ldyBpbnN0YW5jZSwgY3JlYXRlIGl0LlxuICAgICAgICAgICAgaWYgKCFuZXdPYmplY3RzW29iaklkXSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXdPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG9iai5jb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBlbmFibGU6IG9iai5lbmFibGUsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBvYmouaWQsXG4gICAgICAgICAgICAgICAgICAgIGxheWVyOiBvYmoubGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9iai5yZXNvbHZlZCksIHsgaW5zdGFuY2VzOiBbXSB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0c1tvYmpJZF0gPSBuZXdPYmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmplY3RzW29iaklkXS5yZXNvbHZlZC5pbnN0YW5jZXMgPSByZXN1bHRpbmdJbnN0YW5jZXM7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xhc3NlczogdGltZWxpbmUuY2xhc3NlcyxcbiAgICAgICAgICAgIGxheWVyczogdGltZWxpbmUubGF5ZXJzLFxuICAgICAgICAgICAgb2JqZWN0czogbmV3T2JqZWN0cyxcbiAgICAgICAgICAgIHN0YXRpc3RpY3M6IHRpbWVsaW5lLnN0YXRpc3RpY3MsXG4gICAgICAgICAgICBuZXh0RXZlbnRzOiB0aW1lbGluZS5uZXh0RXZlbnRzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0d28gdGltZWxpbmVzIGJ5IG1lcmdpbmcgaW5zdGFuY2VzIG9mIG9iamVjdHMgdGhhdCBpbnRlcnNlY3QgZWFjaCBvdGhlci5cbiAgICAgKiBAcGFyYW0gcGFzdCBPbGRlciB0aW1lbGluZS5cbiAgICAgKiBAcGFyYW0gcHJlc2VudCBOZXdlciB0aW1lbGluZS5cbiAgICAgKiBAcmV0dXJucyB7UmVzb2x2ZWRUaW1lbGluZX0gY29udGFpbmluZyBtZXJnZWQgdGltZWxpbmVzLlxuICAgICAqL1xuICAgIG1lcmdlVGltZWxpbmVPYmplY3RzKHBhc3QsIHByZXNlbnQsIGZyb21OZXdUaW1lbGluZSkge1xuICAgICAgICBjb25zdCByZXN1bHRpbmdPYmplY3RzID0ge307XG4gICAgICAgIGlmIChmcm9tTmV3VGltZWxpbmUpIHtcbiAgICAgICAgICAgIHBhc3QgPSB0aGlzLnRyaW1UaW1lbGluZShwYXN0LCB7IGVuZDogdGhpcy5fcGxheUhlYWRUaW1lIH0pO1xuICAgICAgICAgICAgcHJlc2VudCA9IHRoaXMudHJpbVRpbWVsaW5lKHByZXNlbnQsIHsgc3RhcnQ6IHRoaXMuX3BsYXlIZWFkVGltZSB9KTtcbiAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugd2FudCB0byBrZWVwIG9sZCBvYmplY3RzLCB0aGlzIGl0ZXJhdG9yIGlzIHVzZWQgdG8gY3JlYXRlIHVuaXF1ZSBvbGQgaWRzIGZvciB0aGVtXG4gICAgICAgICAgICB0aGlzLl9tZXJnZUl0ZXJhdG9yKys7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXN0Lm9iamVjdHMpLmZvckVhY2goKG9iaklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFzdE9iaiA9IHBhc3Qub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogaGFjayB0byBtYXJrIGl0IGFzIGEgXCJwYXN0IG9iamVjdFwiXG4gICAgICAgICAgICAgICAgaWYgKHBhc3RPYmouX19wYXN0T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciBpdCByaWdodCBhd2F5LCBpdCdzIG9sZC4gRG9uJ3QgZG8gYW55dGhpbmcgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHBhc3RPYmo7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgYW4gb2JqZWN0IGV4aXN0cyBpbiBib3RoIHRpbWVsaW5lc1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlbnRPYmogPSBwcmVzZW50Lm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgICAgIGlmIChwcmVzZW50T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSB0aGUgb2JqZWN0cywgb25seSBsb29rIGludG8gbWVyZ2luZyB0aGVtIGlmIHRoZXkgbG9vayBpZGVudGljYWxcbiAgICAgICAgICAgICAgICAgICAgaXNFcXVhbChPYmplY3QuYXNzaWduKHt9LCBwYXN0T2JqLCB7IHJlc29sdmVkOiBudWxsIH0pLCBPYmplY3QuYXNzaWduKHt9LCBwcmVzZW50T2JqLCB7IHJlc29sdmVkOiBudWxsIH0pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgYWxsIHBhc3QgaW5zdGFuY2VzIHN0b3AgYXQgYSBjZXJ0YWluIHRpbWUgYXQgdGhlIHZlcnkgbGF0ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRoYXQgYWxsIG5ldyBpbnN0YW5jZXMgc3RhcnQgYXQgdGhhdCB0aW1lIGF0IHRoZSB2ZXJ5IGVhcmxpZXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBpbnN0YW5jZXMgb2YgdGhvc2Ugb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbEluc3RhbmNlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdE9iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChwYXN0SW5zdGFuY2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEluc3RhbmNlc1twYXN0SW5zdGFuY2UuZW5kICsgJyddID0gcGFzdEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcy5mb3JFYWNoKHByZXNlbnRJbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbEluc3RhbmNlc1twcmVzZW50SW5zdGFuY2Uuc3RhcnQgKyAnJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlcyBhcmUgbmV4dCB0byBlYWNoIG90aGVyLCBtZXJnZSB0aGVtIGludG8gb25lOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXNbcHJlc2VudEluc3RhbmNlLnN0YXJ0ICsgJyddLmVuZCA9IHByZXNlbnRJbnN0YW5jZS5lbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXNbcHJlc2VudEluc3RhbmNlLnN0YXJ0ICsgJyddID0gcHJlc2VudEluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFsbEluc3RhbmNlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gYWxsSW5zdGFuY2VzW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB0aGUgbmV3IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF0gPSBwcmVzZW50T2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBkb24ndCBjb3B5IG92ZXIgb2xkIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdHMgZG9lc24ndCBsb29rIGlkZW50aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBuZXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHByZXNlbnRPYmo7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvbGQgb2JqZWN0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIG5ldyB0aW1lbGluZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBoYWNrIHRvIG1hcmsgaXQgYXMgYSBcInBhc3Qgb2JqZWN0XCJcbiAgICAgICAgICAgICAgICBwYXN0T2JqLl9fcGFzdE9iaiA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvdmVyIHRoZSBvbGQgb2JqZWN0XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nT2JqZWN0c1t0aGlzLl9tZXJnZUl0ZXJhdG9yICsgJ19fJyArIG9iaklkXSA9IHBhc3RPYmo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgbmV4dCBvYmplY3RzXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcmVzZW50Lm9iamVjdHMpLmZvckVhY2goKG9iaklkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlc2VudE9iaiA9IHByZXNlbnQub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXN0Lm9iamVjdHNbb2JqSWRdKSB7IC8vIChpZiBpdCBkaWQgZXhpc3RlZCBpbiB0aGUgcGFzdCwgaXQgaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkKVxuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IGNvcHkgb3ZlciB0aGUgbmV3IG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdPYmplY3RzW29iaklkXSA9IHByZXNlbnRPYmo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBuZXcgdGltZWxpbmUsIG9iamVjdHMgYW5kIGluc3RhbmNlcyBhcmUgb25seSBhZGRlZFxuICAgICAgICAgICAgT2JqZWN0LmtleXMocGFzdC5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RPYmogPSBwYXN0Lm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcGFzdE9iajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJlc2VudC5vYmplY3RzKS5mb3JFYWNoKChvYmpJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlbnRPYmogPSBwcmVzZW50Lm9iamVjdHNbb2JqSWRdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nT2JqID0gcmVzdWx0aW5nT2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1lcmdlIHdpdGggb2xkIGluc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0luc3RhbmNlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ09iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0luc3RhbmNlc1tpbnN0YW5jZS5zdGFydCArICdfJyArIGluc3RhbmNlLmVuZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHB1c2ggaW5zdGFuY2VzIHRoYXQgYXJlbid0IGFscmVhZHkgcHJlc2VudDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXhpc3RpbmdJbnN0YW5jZXNbaW5zdGFuY2Uuc3RhcnQgKyAnXycgKyBpbnN0YW5jZS5lbmRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdPYmoucmVzb2x2ZWQuaW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ09iamVjdHNbb2JqSWRdID0gcHJlc2VudE9iajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRpbmdMYXllcnMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMocmVzdWx0aW5nT2JqZWN0cykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gcmVzdWx0aW5nT2JqZWN0c1trZXldO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBvYmoubGF5ZXIgKyAnJztcbiAgICAgICAgICAgIGlmICghcmVzdWx0aW5nTGF5ZXJzW2xheWVyXSlcbiAgICAgICAgICAgICAgICByZXN1bHRpbmdMYXllcnNbbGF5ZXJdID0gW107XG4gICAgICAgICAgICByZXN1bHRpbmdMYXllcnNbbGF5ZXJdLnB1c2goa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXNlbnQpLCB7IG9iamVjdHM6IHJlc3VsdGluZ09iamVjdHMsIGxheWVyczogcmVzdWx0aW5nTGF5ZXJzIH0pO1xuICAgIH1cbiAgICB1cGRhdGVUaW1lbGluZVJlc29sdmVXaW5kb3coKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5nZXRFeHBhbmRlZFN0YXJ0RW5kVGltZSgxKTtcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fdGltZWxpbmVSZXNvbHZlRW5kID0gZW5kO1xuICAgICAgICB0aGlzLl90aW1lbGluZVJlc29sdmVab29tID0gdGhpcy5fdGltZWxpbmVab29tO1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RVcGRhdGVUaW1lKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgYW4gb3B0aW1hbCBudW1iZXIgb2Ygb2JqZWN0cyB0byBjcmVhdGUsIHNvIHRoYXQgdGhlIGRyYXdpbmcgc3RpbGwgcnVucyBzbW9vdGhseS5cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFJlc29sdmVUaW1lID0gNTA7IC8vIG1zXG4gICAgICAgICAgICBsZXQgcmF0aW8gPSB0YXJnZXRSZXNvbHZlVGltZSAvIHRoaXMubGF0ZXN0VXBkYXRlVGltZTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUNvdW50QWRqdXN0ID0gTWF0aC5tYXgoMC4xLCBNYXRoLm1pbigxMCwgKDEgKyAodGhpcy5fdGltZWxpbmVSZXNvbHZlQ291bnRBZGp1c3QgKiByYXRpbykpIC8gMikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEV4cGFuZGVkU3RhcnRFbmRUaW1lKG11bHRpcGxpZXIgPSAxKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuX3ZpZXdTdGFydFRpbWU7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLnZpZXdFbmRUaW1lO1xuICAgICAgICBsZXQgZHVyYXRpb24gPSBlbmQgLSBzdGFydDtcbiAgICAgICAgbGV0IGV4cGFuZCA9IGR1cmF0aW9uICogKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZUV4cGFuZCAtIDEpICogbXVsdGlwbGllcjtcbiAgICAgICAgc3RhcnQgLT0gZXhwYW5kICogMC4zMztcbiAgICAgICAgZW5kICs9IGV4cGFuZCAqIDAuNjY7IC8vIGV4cGFuZCBtb3JlIGludG8gdGhlIGZ1dHVyZVxuICAgICAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0KTtcbiAgICAgICAgZW5kID0gTWF0aC5tYXgoMCwgZW5kKTtcbiAgICAgICAgY29uc3Qgem9vbURpZmYgPSBNYXRoLm1heCh0aGlzLl90aW1lbGluZVJlc29sdmVab29tLCB0aGlzLl90aW1lbGluZVpvb20pIC9cbiAgICAgICAgICAgIE1hdGgubWluKHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVpvb20sIHRoaXMuX3RpbWVsaW5lWm9vbSk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0LCBlbmQsIHpvb21EaWZmIH07XG4gICAgfVxuICAgIGNoZWNrQXV0b21hdGljUmVyZXNvbHZlKCkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQsIHpvb21EaWZmIH0gPSB0aGlzLmdldEV4cGFuZGVkU3RhcnRFbmRUaW1lKDAuMik7XG4gICAgICAgIGlmICh0aGlzLl90aW1lbGluZVJlc29sdmVBdXRvICYmIChzdGFydCA8IHRoaXMuX3RpbWVsaW5lUmVzb2x2ZVN0YXJ0IHx8XG4gICAgICAgICAgICBlbmQgPiB0aGlzLl90aW1lbGluZVJlc29sdmVFbmQgfHxcbiAgICAgICAgICAgIHpvb21EaWZmID4gMykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXJlc29sdmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXJlc29sdmVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVyZXNvbHZlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGltZWxpbmVSZXNvbHZlV2luZG93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRpbWVsaW5lKCk7XG4gICAgICAgICAgICAgICAgfSwgTWF0aC5tYXgoMTAwLCB0aGlzLmxhdGVzdFVwZGF0ZVRpbWUgKiA1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tIENvbnZlcnNpb25zIGJldHdlZW4gcG9zaXRpb24gJiB0aW1lIC0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIFggY29vcmRpbmF0ZSBvZiBhIHRpbWUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGhlIHRpbWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSB0aW1lLlxuICAgICAqL1xuICAgIHRpbWVUb1hDb29yZCh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3RHJhd1ggKyAoKHRpbWUgLSB0aGlzLl92aWV3U3RhcnRUaW1lKSAqIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgdGltZSBvZiBhIFggY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSBUaGUgWCBjb29yZGluYXRlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHRpbWUgb2YgdGhlIFggY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICB4Q29vcmRUb1RpbWUocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdTdGFydFRpbWUgKyAoKHBvc2l0aW9uIC0gdGhpcy5fdmlld0RyYXdYKSAvIHRoaXMucGl4ZWxzV2lkdGhQZXJVbml0VGltZSk7XG4gICAgfVxuICAgIC8qKiBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIHRoZSB0aW1lIGluIGN1cnJlbnQgdmlldyAoMCBpIGJlZ2lubmluZywgMSBpcyBlbmQpICAqL1xuICAgIHRpbWVUb1JhdGlvKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aW1lIC0gdGhpcy5fdmlld1N0YXJ0VGltZSkgLyB0aGlzLnZpZXdSYW5nZTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gaXMgd2l0aGluIHRoZSBjdXJyZW50IHZpZXcgICovXG4gICAgaXN0aW1lSW5WaWV3KHRpbWUpIHtcbiAgICAgICAgY29uc3QgcmF0aW8gPSB0aGlzLnRpbWVUb1JhdGlvKHRpbWUpO1xuICAgICAgICByZXR1cm4gcmF0aW8gPj0gMCAmJiByYXRpbyA8IDE7XG4gICAgfVxuICAgIGNhcFhjb29yZFRvVmlldyhwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5fdmlld0RyYXdYLCBNYXRoLm1pbih0aGlzLl92aWV3RHJhd1ggKyB0aGlzLl92aWV3RHJhd1dpZHRoLCBwb3NpdGlvbikpO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLSBHZXR0ZXJzIC8gQ29udmVuaWVuY2UgZnVuY3Rpb25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8qKiBab29tIGZhY3RvciBbcGl4ZWxzIC8gdGltZV0gKi9cbiAgICBnZXQgcGl4ZWxzV2lkdGhQZXJVbml0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl90aW1lbGluZVpvb20gLyAxMDApO1xuICAgIH1cbiAgICAvKiogVGhlIHJhbmdlIG9mIHRoZSB2aWV3IFt0aW1lXSAqL1xuICAgIGdldCB2aWV3UmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3RHJhd1dpZHRoIC8gdGhpcy5waXhlbHNXaWR0aFBlclVuaXRUaW1lO1xuICAgIH1cbiAgICAvKiogVGhlIGVuZCB0aW1lIG9mIHRoZSB2aWV3IFt0aW1lXSAqL1xuICAgIGdldCB2aWV3RW5kVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdTdGFydFRpbWUgKyB0aGlzLnZpZXdSYW5nZTtcbiAgICB9XG59XG5leHBvcnRzLlRpbWVsaW5lVmlzdWFsaXplciA9IFRpbWVsaW5lVmlzdWFsaXplcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVsaW5lVmlzdWFsaXplci5qcy5tYXAiLCIiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gKiBlcXVpdmFsZW50LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjb21wYXJpbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucyxcbiAqIGRhdGUgb2JqZWN0cywgZXJyb3Igb2JqZWN0cywgbWFwcywgbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcyxcbiAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gKiBieSB0aGVpciBvd24sIG5vdCBpbmhlcml0ZWQsIGVudW1lcmFibGUgcHJvcGVydGllcy4gRnVuY3Rpb25zIGFuZCBET01cbiAqIG5vZGVzIGFyZSBjb21wYXJlZCBieSBzdHJpY3QgZXF1YWxpdHksIGkuZS4gYD09PWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uaXNFcXVhbChvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBvYmplY3QgPT09IG90aGVyO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFcXVhbCh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFcXVhbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwcmVzc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9uXCIpLCBleHBvcnRzKTtcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Jlc29sdmVkVGltZWxpbmVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVzb2x2ZXJcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RhdGVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdGltZWxpbmVcIiksIGV4cG9ydHMpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHlwZXNcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV2ZW50VHlwZSA9IHZvaWQgMDtcbnZhciBFdmVudFR5cGU7XG4oZnVuY3Rpb24gKEV2ZW50VHlwZSkge1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJTVEFSVFwiXSA9IDBdID0gXCJTVEFSVFwiO1xuICAgIEV2ZW50VHlwZVtFdmVudFR5cGVbXCJFTkRcIl0gPSAxXSA9IFwiRU5EXCI7XG4gICAgRXZlbnRUeXBlW0V2ZW50VHlwZVtcIktFWUZSQU1FXCJdID0gMl0gPSBcIktFWUZSQU1FXCI7XG59KShFdmVudFR5cGUgPSBleHBvcnRzLkV2ZW50VHlwZSB8fCAoZXhwb3J0cy5FdmVudFR5cGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZWRUaW1lbGluZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lbGluZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vbkNsb3NlQ2xlYW51cCA9IGV4cG9ydHMudmFsaWRhdGVFeHByZXNzaW9uID0gZXhwb3J0cy53cmFwSW5uZXJFeHByZXNzaW9ucyA9IGV4cG9ydHMuc2ltcGxpZnlFeHByZXNzaW9uID0gZXhwb3J0cy5pbnRlcnByZXRFeHByZXNzaW9uID0gZXhwb3J0cy5hcHBseUtleWZyYW1lQ29udGVudCA9IGV4cG9ydHMudmFsaWRhdGVSZWZlcmVuY2VTdHJpbmcgPSBleHBvcnRzLnZhbGlkYXRlS2V5ZnJhbWUgPSBleHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gZXhwb3J0cy52YWxpZGF0ZVRpbWVsaW5lID0gZXhwb3J0cy5nZXRSZXNvbHZlZFN0YXRlID0gZXhwb3J0cy5yZXNvbHZlVGltZWxpbmUgPSB2b2lkIDA7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbmNvbnN0IFN0YXRlSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXIvU3RhdGVIYW5kbGVyXCIpO1xuY29uc3QgRXhwcmVzc2lvbkhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyL0V4cHJlc3Npb25IYW5kbGVyXCIpO1xuY29uc3QgUmVzb2x2ZXJIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlci9SZXNvbHZlckhhbmRsZXJcIik7XG5jb25zdCBUaW1lbGluZVZhbGlkYXRvcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXIvVGltZWxpbmVWYWxpZGF0b3JcIik7XG4vKipcbiAqIFJlc29sdmVzIGEgdGltZWxpbmUsIGkuZS4gcmVzb2x2ZXMgdGhlIHJlZmVyZW5jZXMgYmV0d2VlbiBvYmplY3RzXG4gKiBhbmQgY2FsY3VsYXRlcyB0aGUgYWJzb2x1dGUgdGltZXMgZm9yIGFsbCBvYmplY3RzIGluIHRoZSB0aW1lbGluZS5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRpbWVsaW5lKHRpbWVsaW5lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzb2x2ZXJJbnN0YW5jZSA9IG5ldyBSZXNvbHZlckhhbmRsZXJfMS5SZXNvbHZlckhhbmRsZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc29sdmVySW5zdGFuY2UucmVzb2x2ZVRpbWVsaW5lKHRpbWVsaW5lKTtcbn1cbmV4cG9ydHMucmVzb2x2ZVRpbWVsaW5lID0gcmVzb2x2ZVRpbWVsaW5lO1xuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgc3RhdGUgZm9yIGEgY2VydGFpbiBwb2ludCBpbiB0aW1lLlxuICogVGhlIHN0YXRlIGNvbnRhaW5zIGFsbCBvYmplY3RzIHRoYXQgYXJlIGFjdGl2ZSBhdCB0aGF0IHBvaW50IGluIHRpbWUuXG4gKiBAcGFyYW0gcmVzb2x2ZWRUaW1lbGluZVxuICogQHBhcmFtIHRpbWVcbiAqIEBwYXJhbSBldmVudExpbWl0XG4gKi9cbmZ1bmN0aW9uIGdldFJlc29sdmVkU3RhdGUocmVzb2x2ZWRUaW1lbGluZSwgdGltZSwgZXZlbnRMaW1pdCA9IDApIHtcbiAgICBjb25zdCBzdGF0ZUhhbmRsZXIgPSBuZXcgU3RhdGVIYW5kbGVyXzEuU3RhdGVIYW5kbGVyKCk7XG4gICAgcmV0dXJuIHN0YXRlSGFuZGxlci5nZXRTdGF0ZShyZXNvbHZlZFRpbWVsaW5lLCB0aW1lLCBldmVudExpbWl0KTtcbn1cbmV4cG9ydHMuZ2V0UmVzb2x2ZWRTdGF0ZSA9IGdldFJlc29sdmVkU3RhdGU7XG4vKipcbiAqIFZhbGlkYXRlcyBhbGwgb2JqZWN0cyBpbiB0aGUgdGltZWxpbmUuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZ1xuICogQHBhcmFtIHRpbWVsaW5lIFRoZSB0aW1lbGluZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHN0cmljdCBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBvcHRpb25hbCBzdHJpY3QgcnVsZXMuIFNldCB0aGlzIHRvIHRydWUgdG8gaW5jcmVhc2UgZnV0dXJlIGNvbXBhdGliaWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZWxpbmUodGltZWxpbmUsIHN0cmljdCkge1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBUaW1lbGluZVZhbGlkYXRvcl8xLlRpbWVsaW5lVmFsaWRhdG9yKCk7XG4gICAgdmFsaWRhdG9yLnZhbGlkYXRlVGltZWxpbmUodGltZWxpbmUsIHN0cmljdCk7XG59XG5leHBvcnRzLnZhbGlkYXRlVGltZWxpbmUgPSB2YWxpZGF0ZVRpbWVsaW5lO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUaW1lbGluZS1vYmplY3QuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZ1xuICogQHBhcmFtIHRpbWVsaW5lIFRoZSB0aW1lbGluZSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIHN0cmljdCBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBvcHRpb25hbCBzdHJpY3QgcnVsZXMuIFNldCB0aGlzIHRvIHRydWUgdG8gaW5jcmVhc2UgZnV0dXJlIGNvbXBhdGliaWxpdHkuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iaiwgc3RyaWN0KSB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IFRpbWVsaW5lVmFsaWRhdG9yXzEuVGltZWxpbmVWYWxpZGF0b3IoKTtcbiAgICB2YWxpZGF0b3IudmFsaWRhdGVPYmplY3Qob2JqLCBzdHJpY3QpO1xufVxuZXhwb3J0cy52YWxpZGF0ZU9iamVjdCA9IHZhbGlkYXRlT2JqZWN0O1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUaW1lbGluZS1rZXlmcmFtZS4gVGhyb3dzIGFuIGVycm9yIGlmIHNvbWV0aGluZydzIHdyb25nXG4gKiBAcGFyYW0gdGltZWxpbmUgVGhlIHRpbWVsaW5lIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gc3RyaWN0IFNldCB0byB0cnVlIHRvIGVuYWJsZSBzb21lIG9wdGlvbmFsIHN0cmljdCBydWxlcy4gU2V0IHRoaXMgdG8gdHJ1ZSB0byBpbmNyZWFzZSBmdXR1cmUgY29tcGF0aWJpbGl0eS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVLZXlmcmFtZShrZXlmcmFtZSwgc3RyaWN0KSB7XG4gICAgY29uc3QgdmFsaWRhdG9yID0gbmV3IFRpbWVsaW5lVmFsaWRhdG9yXzEuVGltZWxpbmVWYWxpZGF0b3IoKTtcbiAgICB2YWxpZGF0b3IudmFsaWRhdGVLZXlmcmFtZShrZXlmcmFtZSwgc3RyaWN0KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVLZXlmcmFtZSA9IHZhbGlkYXRlS2V5ZnJhbWU7XG4vKipcbiAqIFZhbGlkYXRlcyBhIHN0cmluZyB0aGF0IGlzIHVzZWQgaW4gVGltZWxpbmUgYXMgYSByZWZlcmVuY2UgKGFuIGlkLCBhIGNsYXNzIG9yIGxheWVyKVxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gKiBAcGFyYW0gc3RyaWN0IFNldCB0byB0cnVlIHRvIGVuYWJsZSBzb21lIG9wdGlvbmFsIHN0cmljdCBydWxlcy4gU2V0IHRoaXMgdG8gdHJ1ZSB0byBpbmNyZWFzZSBmdXR1cmUgY29tcGF0aWJpbGl0eS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSZWZlcmVuY2VTdHJpbmcoc3RyLCBzdHJpY3QpIHtcbiAgICBUaW1lbGluZVZhbGlkYXRvcl8xLlRpbWVsaW5lVmFsaWRhdG9yLnZhbGlkYXRlUmVmZXJlbmNlU3RyaW5nKHN0ciwgc3RyaWN0KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVSZWZlcmVuY2VTdHJpbmcgPSB2YWxpZGF0ZVJlZmVyZW5jZVN0cmluZztcbi8qKlxuICogQXBwbHkga2V5ZnJhbWUgY29udGVudCBvbnRvIGl0cyBwYXJlbnQgY29udGVudC5cbiAqIFRoZSBrZXlmcmFtZSBjb250ZW50IGlzIGRlZXBseS1hcHBsaWVkIG9udG8gdGhlIHBhcmVudCBjb250ZW50LlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBtdXRhdGVzIHRoZSBwYXJlbnRDb250ZW50LlxuICovXG5mdW5jdGlvbiBhcHBseUtleWZyYW1lQ29udGVudChwYXJlbnRDb250ZW50LCBrZXlmcmFtZUNvbnRlbnQpIHtcbiAgICBTdGF0ZUhhbmRsZXJfMS5TdGF0ZUhhbmRsZXIuYXBwbHlLZXlmcmFtZUNvbnRlbnQocGFyZW50Q29udGVudCwga2V5ZnJhbWVDb250ZW50KTtcbn1cbmV4cG9ydHMuYXBwbHlLZXlmcmFtZUNvbnRlbnQgPSBhcHBseUtleWZyYW1lQ29udGVudDtcbmxldCBleHByZXNzaW9uSGFuZGxlciA9IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldEV4cHJlc3Npb25IYW5kbGVyKCkge1xuICAgIGlmICghZXhwcmVzc2lvbkhhbmRsZXIpXG4gICAgICAgIGV4cHJlc3Npb25IYW5kbGVyID0gbmV3IEV4cHJlc3Npb25IYW5kbGVyXzEuRXhwcmVzc2lvbkhhbmRsZXIodHJ1ZSk7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25IYW5kbGVyO1xufVxuZnVuY3Rpb24gaW50ZXJwcmV0RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgcmV0dXJuIGdldEV4cHJlc3Npb25IYW5kbGVyKCkuaW50ZXJwcmV0RXhwcmVzc2lvbihleHByZXNzaW9uKTtcbn1cbmV4cG9ydHMuaW50ZXJwcmV0RXhwcmVzc2lvbiA9IGludGVycHJldEV4cHJlc3Npb247XG5mdW5jdGlvbiBzaW1wbGlmeUV4cHJlc3Npb24oZXhwcjApIHtcbiAgICByZXR1cm4gZ2V0RXhwcmVzc2lvbkhhbmRsZXIoKS5zaW1wbGlmeUV4cHJlc3Npb24oZXhwcjApO1xufVxuZXhwb3J0cy5zaW1wbGlmeUV4cHJlc3Npb24gPSBzaW1wbGlmeUV4cHJlc3Npb247XG5mdW5jdGlvbiB3cmFwSW5uZXJFeHByZXNzaW9ucyh3b3Jkcykge1xuICAgIHJldHVybiBnZXRFeHByZXNzaW9uSGFuZGxlcigpLndyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzKTtcbn1cbmV4cG9ydHMud3JhcElubmVyRXhwcmVzc2lvbnMgPSB3cmFwSW5uZXJFeHByZXNzaW9ucztcbmZ1bmN0aW9uIHZhbGlkYXRlRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGV4cHIwLCBicmVhZGNydW1icykge1xuICAgIHJldHVybiBnZXRFeHByZXNzaW9uSGFuZGxlcigpLnZhbGlkYXRlRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGV4cHIwLCBicmVhZGNydW1icyk7XG59XG5leHBvcnRzLnZhbGlkYXRlRXhwcmVzc2lvbiA9IHZhbGlkYXRlRXhwcmVzc2lvbjtcbi8qKlxuICogSWYgeW91IGhhdmUgY2FsbGVkIGFueSBvZiB0aGUgbWFudWFsIGV4cHJlc3Npb24tZnVuY3Rpb25zLCBzdWNoIGFzIGludGVycHJldEV4cHJlc3Npb24oKSxcbiAqIHlvdSBjb3VsZCBjYWxsIHRoaXMgdG8gbWFudWFsbHkgY2xlYW4gdXAgYW4gaW50ZXJuYWwgY2FjaGUsIHRvIGVuc3VyZSB5b3VyIGFwcGxpY2F0aW9uIHF1aXRzIGNsZWFubHkuXG4gKi9cbmZ1bmN0aW9uIG9uQ2xvc2VDbGVhbnVwKCkge1xuICAgIGlmIChleHByZXNzaW9uSGFuZGxlcilcbiAgICAgICAgZXhwcmVzc2lvbkhhbmRsZXIuY2xlYXJDYWNoZSgpO1xufVxuZXhwb3J0cy5vbkNsb3NlQ2xlYW51cCA9IG9uQ2xvc2VDbGVhbnVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hUaW1lbGluZU9iamVjdCA9IGV4cG9ydHMuQ2FjaGVIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWIvbGliXCIpO1xuY29uc3QgcGVyZm9ybWFuY2VfMSA9IHJlcXVpcmUoXCIuL2xpYi9wZXJmb3JtYW5jZVwiKTtcbmNvbnN0IHJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vbGliL3JlZmVyZW5jZVwiKTtcbmNvbnN0IHRpbWVsaW5lXzEgPSByZXF1aXJlKFwiLi9saWIvdGltZWxpbmVcIik7XG5jbGFzcyBDYWNoZUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlLCByZXNvbHZlZFRpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgIGlmICghY2FjaGUub2JqSGFzaGVzKVxuICAgICAgICAgICAgY2FjaGUub2JqSGFzaGVzID0ge307XG4gICAgICAgIGlmICghY2FjaGUub2JqZWN0cylcbiAgICAgICAgICAgIGNhY2hlLm9iamVjdHMgPSB7fTtcbiAgICAgICAgaWYgKCFjYWNoZS5jYW5CZVVzZWQpIHtcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjYWNoZTpcbiAgICAgICAgICAgIGNhY2hlLm9iakhhc2hlcyA9IHt9O1xuICAgICAgICAgICAgY2FjaGUub2JqZWN0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYW5Vc2VJbmNvbWluZ0NhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhblVzZUluY29taW5nQ2FjaGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlLmNhbkJlVXNlZCB3aWxsIGJlIHNldCBpbiB0aGlzLnBlcnNpc3REYXRhKClcbiAgICAgICAgY2FjaGUuY2FuQmVVc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICB9XG4gICAgZGVidWcoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFRpbWVsaW5lLm9wdGlvbnMuZGVidWcpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICB9XG4gICAgZGV0ZXJtaW5lQ2hhbmdlZE9iamVjdHMoKSB7XG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgY2FjaGUuZGV0ZXJtaW5lQ2hhbmdlZE9iamVjdHMnKTtcbiAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgbmV3IG9iamVjdHMsIGFuZCBkZXRlcm1pbmUgd2hldGhlciB0aGV5IGhhdmUgY2hhbmdlZDpcbiAgICAgICAgY29uc3QgYWxsTmV3T2JqZWN0cyA9IHt9O1xuICAgICAgICBjb25zdCBjaGFuZ2VkUmVmZXJlbmNlcyA9IHt9O1xuICAgICAgICBjb25zdCBhZGRDaGFuZ2VkT2JqZWN0ID0gKG9iaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IHRoaXMuZ2V0QWxsUmVmZXJlbmNlc1RoaXNPYmplY3RBZmZlY3RzKG9iaik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZFJlZmVyZW5jZXNbcmVmXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIHRoaXMucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRIYXNoID0gdGhpcy5jYWNoZS5vYmpIYXNoZXNbb2JqLmlkXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hhc2ggPSBoYXNoVGltZWxpbmVPYmplY3Qob2JqKTtcbiAgICAgICAgICAgIGFsbE5ld09iamVjdHNbb2JqLmlkXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIW9sZEhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgQ2FjaGU6IE9iamVjdCBcIiR7b2JqLmlkfVwiIGlzIG5ld2ApO1xuICAgICAgICAgICAgZWxzZSBpZiAob2xkSGFzaCAhPT0gbmV3SGFzaClcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKGBDYWNoZTogT2JqZWN0IFwiJHtvYmouaWR9XCIgaGFzIGNoYW5nZWRgKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIE9iamVjdCBpcyBuZXc6XG4gICAgICAgICAgICAhb2xkSGFzaCB8fFxuICAgICAgICAgICAgICAgIC8vIE9iamVjdCBoYXMgY2hhbmdlZDpcbiAgICAgICAgICAgICAgICBvbGRIYXNoICE9PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZS5vYmpIYXNoZXNbb2JqLmlkXSA9IG5ld0hhc2g7XG4gICAgICAgICAgICAgICAgYWRkQ2hhbmdlZE9iamVjdChvYmopO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZE9iaiA9IHRoaXMuY2FjaGUub2JqZWN0c1tvYmouaWRdO1xuICAgICAgICAgICAgICAgIGlmIChvbGRPYmopXG4gICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZWRPYmplY3Qob2xkT2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIHRpbWluZy1hZmZlY3RpbmcgY2hhbmdlcyBkZXRlY3RlZFxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghb2xkSGFzaClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgQ2FjaGU6IE9iamVjdCBcIiR7b2JqLmlkfVwiIGlzIHNpbWlsYXJgKTtcbiAgICAgICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgdGltZWxpbmUtcHJvcGVydGllcyBoYXNuJ3QgY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAvLyB0aGUgY29udGVudCAoYW5kIG90aGVyIHByb3BlcnRpZXMpIG1pZ2h0IGhhdmU6XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqID0gdGhpcy5jYWNoZS5vYmplY3RzW29iai5pZF07XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKCFvbGRPYmopIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignb2xkSGFzaCcsIG9sZEhhc2gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdpZHMnLCBPYmplY3Qua2V5cyh0aGlzLmNhY2hlLm9iamVjdHMpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBFcnJvcjogb2JqIFwiJHtvYmouaWR9XCIgbm90IGZvdW5kIGluIGNhY2hlLCBldmVuIHRob3VnaCBoYXNoZXMgbWF0Y2ghYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUub2JqZWN0c1tvYmouaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5vYmosXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkOiBvbGRPYmoucmVzb2x2ZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5Vc2VJbmNvbWluZ0NhY2hlKSB7XG4gICAgICAgICAgICAvLyBHbyB0aHJvdWdoIGFsbCBvbGQgaGFzaGVzLCByZW1vdmluZyB0aGUgb25lcyB0aGF0IGRvZXNuJ3QgZXhpc3QgYW55bW9yZVxuICAgICAgICAgICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLmNhY2hlLm9iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbE5ld09iamVjdHNbb2JqSWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY2FjaGUub2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlLm9iakhhc2hlc1tvYmpJZF07XG4gICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZWRPYmplY3Qob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIG9iamVjdHMsIGJ5IGdyYWR1YWxseSByZW1vdmluZyB0aGUgaW52YWxpZGF0ZWQgb25lcyBmcm9tIHZhbGlkT2JqZWN0c1xuICAgICAgICAgICAgLy8gUHJlcGFyZSB2YWxpZE9iamVjdHM6XG4gICAgICAgICAgICBjb25zdCB2YWxpZE9iamVjdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIHRoaXMucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRPYmplY3RzW29iai5pZF0gPSBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogQWxsIHJlZmVyZW5jZXMgdGhhdCBkZXBlbmQgb24gYW5vdGhlciByZWZlcmVuY2UgKGllIG9iamVjdHMsIGNsYXNzcyBvciBsYXllcnMpOiAqL1xuICAgICAgICAgICAgY29uc3QgYWZmZWN0UmVmZXJlbmNlTWFwID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiB0aGlzLnJlc29sdmVkVGltZWxpbmUub2JqZWN0c01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBldmVyeXRoaW5nIHRoYXQgdGhpcyBvYmplY3QgYWZmZWN0czpcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZWRPYmogPSB0aGlzLmNhY2hlLm9iamVjdHNbb2JqLmlkXTtcbiAgICAgICAgICAgICAgICBsZXQgYWZmZWN0ZWRSZWZlcmVuY2VzID0gdGhpcy5nZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMob2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVkT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkUmVmZXJlbmNlcyA9ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoYWZmZWN0ZWRSZWZlcmVuY2VzLCB0aGlzLmdldEFsbFJlZmVyZW5jZXNUaGlzT2JqZWN0QWZmZWN0cyhjYWNoZWRPYmopKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZmZlY3RlZFJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gYWZmZWN0ZWRSZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmpSZWYgPSBgIyR7b2JqLmlkfWA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWYgIT09IG9ialJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RSZWZlcmVuY2VNYXBbb2JqUmVmXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RSZWZlcmVuY2VNYXBbb2JqUmVmXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW29ialJlZl0ucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBldmVyeXRoaW5nIHRoYXQgdGhpcyBvYmplY3QgaXMgYWZmZWN0ZWQgYnk6XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWRSZWZlcmVuY2VzW2AjJHtvYmouaWR9YF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9iamVjdCBpcyBkaXJlY3RseSBzYWlkIHRvIGJlIGludmFsaWQsIG5vIG5lZWQgdG8gYWRkIGl0IHRvIHJlZmVyZW5jaW5nT2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2UgaXQnbGwgYmUgZWFzaWx5IGludmFsaWRhdGVkIGFueXdheSBsYXRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogd2Ugb25seSBoYXZlIHRvIGNoZWNrIGZvciB0aGUgT0xEIG9iamVjdCwgc2luY2UgaWYgdGhlIG9sZCBhbmQgdGhlIG5ldyBvYmplY3QgZGlmZmVycyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCB3b3VsZCBtZWFuIGl0J2xsIGJlIGRpcmVjdGx5IGludmFsaWRhdGVkIGFueXdheS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmV0Y2ggYWxsIHJlZmVyZW5jZXMgZm9yIHRoZSBvYmplY3QgZnJvbSB0aGUgbGFzdCB0aW1lIGl0IHdhcyByZXNvbHZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoaXMgY2FuIGJlIGRvbmUsIHNpbmNlIF9pZl8gdGhlIG9iamVjdCB3YXMgY2hhbmdlZCBpbiBhbnkgd2F5IHNpbmNlIGxhc3QgcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQnbGwgYmUgaW52YWxpZGF0ZWQgYW55d2F5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXBlbmRPblJlZmVyZW5jZXMgPSBjYWNoZWRPYmoucmVzb2x2ZWQuZGlyZWN0UmVmZXJlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwZW5kT25SZWZlcmVuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmID0gZGVwZW5kT25SZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWZmZWN0UmVmZXJlbmNlTWFwW3JlZl0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdFJlZmVyZW5jZU1hcFtyZWZdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0UmVmZXJlbmNlTWFwW3JlZl0ucHVzaChgIyR7b2JqLmlkfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSBhbGwgY2hhbmdlZCBvYmplY3RzLCBhbmQgcmVjdXJzaXZlbHkgaW52YWxpZGF0ZSBhbGwgb2JqZWN0cyB0aGF0IHJlZmVyZW5jZSB0aG9zZSBvYmplY3RzOlxuICAgICAgICAgICAgY29uc3QgaGFuZGxlZFJlZmVyZW5jZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVmZXJlbmNlIG9mIE9iamVjdC5rZXlzKGNoYW5nZWRSZWZlcmVuY2VzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW52YWxpZGF0ZU9iamVjdHNXaXRoUmVmZXJlbmNlKGhhbmRsZWRSZWZlcmVuY2VzLCByZWZlcmVuY2UsIGFmZmVjdFJlZmVyZW5jZU1hcCwgdmFsaWRPYmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBvYmplY3RzIHRoYXQgYXJlIGxlZnQgaW4gdmFsaWRPYmplY3RzIGF0IHRoaXMgcG9pbnQgYXJlIHN0aWxsIHZhbGlkLlxuICAgICAgICAgICAgLy8gV2UgY2FuIHJldXNlIHRoZSBvbGQgcmVzb2x2aW5nIGZvciB0aG9zZTpcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIE9iamVjdC52YWx1ZXModmFsaWRPYmplY3RzKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5vYmplY3RzW29iai5pZF0pXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU29tZXRoaW5nIHdlbnQgd3Jvbmc6IFwiJHtvYmouaWR9XCIgZG9lcyBub3QgZXhpc3QgaW4gY2FjaGUucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNNYXAuc2V0KG9iai5pZCwgdGhpcy5jYWNoZS5vYmplY3RzW29iai5pZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICBwZXJzaXN0RGF0YSgpIHtcbiAgICAgICAgY29uc3QgdG9jID0gKDAsIHBlcmZvcm1hbmNlXzEudGljKSgnICBjYWNoZS5wZXJzaXN0RGF0YScpO1xuICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFRpbWVsaW5lLnJlc29sdmVFcnJvcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgcmVzb2x2ZSBlcnJvciwgY2xlYXIgdGhlIGNhY2hlOlxuICAgICAgICAgICAgdGhpcy5jYWNoZS5vYmpIYXNoZXMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUub2JqZWN0cyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5jYW5CZVVzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUub2JqZWN0cyA9ICgwLCBsaWJfMS5tYXBUb09iamVjdCkodGhpcy5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNNYXApO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5jYW5CZVVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICBnZXRBbGxSZWZlcmVuY2VzVGhpc09iamVjdEFmZmVjdHMobmV3T2JqKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBbYCMke25ld09iai5pZH1gXTtcbiAgICAgICAgaWYgKG5ld09iai5jbGFzc2VzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBuZXdPYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaChgLiR7Y2xhc3NOYW1lfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgdGltZWxpbmVfMS5vYmpIYXNMYXllcikobmV3T2JqKSlcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaChgJCR7bmV3T2JqLmxheWVyfWApO1xuICAgICAgICBpZiAobmV3T2JqLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5ld09iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaChgIyR7Y2hpbGQuaWR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZXM7XG4gICAgfVxuICAgIC8qKiBJbnZhbGlkYXRlIGFsbCBjaGFuZ2VkIG9iamVjdHMsIGFuZCByZWN1cnNpdmVseSBpbnZhbGlkYXRlIGFsbCBvYmplY3RzIHRoYXQgcmVmZXJlbmNlIHRob3NlIG9iamVjdHMgKi9cbiAgICBpbnZhbGlkYXRlT2JqZWN0c1dpdGhSZWZlcmVuY2UoaGFuZGxlZFJlZmVyZW5jZXMsIHJlZmVyZW5jZSwgYWZmZWN0UmVmZXJlbmNlTWFwLCB2YWxpZE9iamVjdHMpIHtcbiAgICAgICAgaWYgKGhhbmRsZWRSZWZlcmVuY2VzW3JlZmVyZW5jZV0pXG4gICAgICAgICAgICByZXR1cm47IC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzXG4gICAgICAgIGhhbmRsZWRSZWZlcmVuY2VzW3JlZmVyZW5jZV0gPSB0cnVlO1xuICAgICAgICBpZiAoKDAsIHJlZmVyZW5jZV8xLmlzT2JqZWN0UmVmZXJlbmNlKShyZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpJZCA9ICgwLCByZWZlcmVuY2VfMS5nZXRSZWZPYmplY3RJZCkocmVmZXJlbmNlKTtcbiAgICAgICAgICAgIGlmICh2YWxpZE9iamVjdHNbb2JqSWRdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbGlkT2JqZWN0c1tvYmpJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW52YWxpZGF0ZSBhbGwgb2JqZWN0cyB0aGF0IGRlcGVuZCBvbiBhbnkgb2YgdGhlIHJlZmVyZW5jZXMgdGhhdCB0aGlzIHJlZmVyZW5jZSBhZmZlY3RzOlxuICAgICAgICBjb25zdCBhZmZlY3RlZFJlZmVyZW5jZXMgPSBhZmZlY3RSZWZlcmVuY2VNYXBbcmVmZXJlbmNlXTtcbiAgICAgICAgaWYgKGFmZmVjdGVkUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZmZlY3RlZFJlZmVyZW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2luZ1JlZmVyZW5jZSA9IGFmZmVjdGVkUmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmludmFsaWRhdGVPYmplY3RzV2l0aFJlZmVyZW5jZShoYW5kbGVkUmVmZXJlbmNlcywgcmVmZXJlbmNpbmdSZWZlcmVuY2UsIGFmZmVjdFJlZmVyZW5jZU1hcCwgdmFsaWRPYmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FjaGVIYW5kbGVyID0gQ2FjaGVIYW5kbGVyO1xuLyoqIFJldHVybiBhIFwiaGFzaC1zdHJpbmdcIiB3aGljaCBjaGFuZ2VzIHdoZW5ldmVyIGFueXRoaW5nIHRoYXQgYWZmZWN0cyB0aW1pbmcgb2YgYSB0aW1lbGluZS1vYmplY3QgaGFzIGNoYW5nZWQuICovXG5mdW5jdGlvbiBoYXNoVGltZWxpbmVPYmplY3Qob2JqKSB7XG4gICAgLypcbiAgICBOb3RlOiBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIGlnbm9yZWQsIGFzIHRoZXkgZG9uJ3QgYWZmZWN0IHRpbWluZyBvciByZXNvbHZpbmc6XG4gICAgICogaWRcbiAgICAgKiBjaGlsZHJlblxuICAgICAqIGtleWZyYW1lc1xuICAgICAqIGlzR3JvdXBcbiAgICAgKiBjb250ZW50XG4gICAgICovXG4gICAgcmV0dXJuIGAke0pTT04uc3RyaW5naWZ5KG9iai5lbmFibGUpfSwkeyshIW9iai5kaXNhYmxlZH0sJHtvYmoucHJpb3JpdHl9Jywke29iai5yZXNvbHZlZC5wYXJlbnRJZH0sJHsrb2JqLnJlc29sdmVkXG4gICAgICAgIC5pc0tleWZyYW1lfSwke29iai5jbGFzc2VzID8gb2JqLmNsYXNzZXMuam9pbignLicpIDogJyd9LCR7b2JqLmxheWVyfSwkeyshIW9iai5zZWFtbGVzc31gO1xufVxuZXhwb3J0cy5oYXNoVGltZWxpbmVPYmplY3QgPSBoYXNoVGltZWxpbmVPYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4cHJlc3Npb25IYW5kbGVyID0gZXhwb3J0cy5SRUdFWFBfT1BFUkFUT1JTID0gZXhwb3J0cy5PUEVSQVRPUlMgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYi9saWJcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vbGliL2NhY2hlXCIpO1xuY29uc3QgZXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vbGliL2V4cHJlc3Npb25cIik7XG5leHBvcnRzLk9QRVJBVE9SUyA9IFsnJicsICd8JywgJysnLCAnLScsICcqJywgJy8nLCAnJScsICchJ107XG5leHBvcnRzLlJFR0VYUF9PUEVSQVRPUlMgPSBuZXcgUmVnRXhwKCcoWycgKyBleHBvcnRzLk9QRVJBVE9SUy5tYXAoKG8pID0+ICdcXFxcJyArIG8pLmpvaW4oJycpICsgJ1xcXFwoXFxcXCldKScsICdnJyk7XG5jbGFzcyBFeHByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoYXV0b0NsZWFyQ2FjaGUsIHNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgIHRoaXMuc2tpcFZhbGlkYXRpb24gPSBza2lwVmFsaWRhdGlvbjtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBjYWNoZV8xLkNhY2hlKGF1dG9DbGVhckNhY2hlKTtcbiAgICB9XG4gICAgaW50ZXJwcmV0RXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gICAgICAgIGlmICgoMCwgZXhwcmVzc2lvbl8xLmlzTnVtZXJpY0V4cHIpKGV4cHJlc3Npb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZXhwcmVzc2lvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb25TdHJpbmcgPSBleHByZXNzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuY2FjaGVSZXN1bHQoZXhwcmVzc2lvblN0cmluZywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cHIgPSBleHByZXNzaW9uU3RyaW5nLnJlcGxhY2UoZXhwb3J0cy5SRUdFWFBfT1BFUkFUT1JTLCAnICQxICcpOyAvLyBNYWtlIHN1cmUgdGhlcmUncyBhIHNwYWNlIGJldHdlZW4gZXZlcnkgb3BlcmF0b3IgJiBvcGVyYW5kXG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSAoMCwgbGliXzEuY29tcGFjdCkoZXhwci5zcGxpdCgnICcpKTtcbiAgICAgICAgICAgICAgICBpZiAod29yZHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZW1wdHkgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgIC8vIEZpeCBzcGVjaWFsIGNhc2U6IGEgKyAtIGJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gd29yZHMubGVuZ3RoIC0gMjsgaSA+PSAxOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh3b3Jkc1tpXSA9PT0gJy0nIHx8IHdvcmRzW2ldID09PSAnKycpICYmIHdvcmRJc09wZXJhdG9yKGV4cG9ydHMuT1BFUkFUT1JTLCB3b3Jkc1tpIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkc1tpXSA9IHdvcmRzW2ldICsgd29yZHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29yZHMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lckV4cHJlc3Npb24gPSB0aGlzLndyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJFeHByZXNzaW9uLnJlc3QubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludGVycHJldEV4cHJlc3Npb246IHN5bnRheCBlcnJvcjogcGFyZW50aGVzZXMgZG9uJ3QgYWRkIHVwIGluIFwiJHtleHByfVwiLmApO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lckV4cHJlc3Npb24uaW5uZXIubGVuZ3RoICUgMiAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludGVycHJldEV4cHJlc3Npb246IG9wZXJhbmRzICYgb3BlcmF0b3JzIGRvbid0IGFkZCB1cDogXCIke2lubmVyRXhwcmVzc2lvbi5pbm5lci5qb2luKCcgJyl9XCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVybkV4cHJlc3Npb24gPSB0aGlzLndvcmRzMkV4cHJlc3Npb24oZXhwb3J0cy5PUEVSQVRPUlMsIGlubmVyRXhwcmVzc2lvbi5pbm5lcik7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNraXBWYWxpZGF0aW9uKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlRXhwcmVzc2lvbihleHBvcnRzLk9QRVJBVE9SUywgcmV0dXJuRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVybkV4cHJlc3Npb247XG4gICAgICAgICAgICB9LCA2MCAqIDYwICogMTAwMCAvLyAxIGhvdXJcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogVHJ5IHRvIHNpbXBsaWZ5IGFuIGV4cHJlc3Npb24sIHRoaXMgaW5jbHVkZXM6XG4gICAgICogKiBDb21iaW5lIGNvbnN0YW50IG9wZXJhbmRzLCB1c2luZyBhcml0aG1ldGljIG9wZXJhdG9yc1xuICAgICAqIC4uLm1vcmUgdG8gY29tZT9cbiAgICAgKi9cbiAgICBzaW1wbGlmeUV4cHJlc3Npb24oZXhwcjApIHtcbiAgICAgICAgY29uc3QgZXhwciA9IHR5cGVvZiBleHByMCA9PT0gJ3N0cmluZycgPyB0aGlzLmludGVycHJldEV4cHJlc3Npb24oZXhwcjApIDogZXhwcjA7XG4gICAgICAgIGlmICghZXhwcilcbiAgICAgICAgICAgIHJldHVybiBleHByO1xuICAgICAgICBpZiAoaXNFeHByZXNzaW9uT2JqZWN0KGV4cHIpKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gdGhpcy5zaW1wbGlmeUV4cHJlc3Npb24oZXhwci5sKTtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBleHByLm87XG4gICAgICAgICAgICBjb25zdCByID0gdGhpcy5zaW1wbGlmeUV4cHJlc3Npb24oZXhwci5yKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG9wZXJhbmRzIGNhbiBiZSBjb21iaW5lZDpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbCArIHI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgLSByO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsICogcjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbCAvIHI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGwgJSByO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbCwgbywgciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGwsIG8sIHIgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgLy8gVHVybnMgWydhJywgJygnLCAnYicsICdjJywgJyknXSBpbnRvIFsnYScsIFsnYicsICdjJ11dXG4gICAgLy8gb3IgWydhJywgJyYnLCAnIScsICdiJ10gaW50byBbJ2EnLCAnJicsIFsnJywgJyEnLCAnYiddXVxuICAgIHdyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN3aXRjaCAod29yZHNbaV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICcoJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSB0aGlzLndyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBpbm5lciBleHByZXNzaW9uIGFuZCByZW1vdmUgdGhhXG4gICAgICAgICAgICAgICAgICAgIHdvcmRzW2ldID0gdG1wLmlubmVyO1xuICAgICAgICAgICAgICAgICAgICB3b3Jkcy5zcGxpY2UoaSArIDEsIDk5OTk5LCAuLi50bXAucmVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyOiB3b3Jkcy5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3Q6IHdvcmRzLnNsaWNlKGkgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlICchJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSB0aGlzLndyYXBJbm5lckV4cHJlc3Npb25zKHdvcmRzLnNsaWNlKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBpbm5lciBleHByZXNzaW9uIGFmdGVyIHRoZSAnISdcbiAgICAgICAgICAgICAgICAgICAgd29yZHNbaV0gPSBbJycsICchJ10uY29uY2F0KHRtcC5pbm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzLnNwbGljZShpICsgMSwgOTk5OTksIC4uLnRtcC5yZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbm5lcjogd29yZHMsXG4gICAgICAgICAgICByZXN0OiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFZhbGlkYXRlcyBhbiBleHByZXNzaW9uLiBSZXR1cm5zIHRydWUgb24gc3VjY2VzcywgdGhyb3dzIGVycm9yIGlmIG5vdCAqL1xuICAgIHZhbGlkYXRlRXhwcmVzc2lvbihvcGVyYXRvckxpc3QsIGV4cHIwLCBicmVhZGNydW1icykge1xuICAgICAgICBpZiAoIWJyZWFkY3J1bWJzKVxuICAgICAgICAgICAgYnJlYWRjcnVtYnMgPSAnUk9PVCc7XG4gICAgICAgIGlmICgoMCwgbGliXzEuaXNPYmplY3QpKGV4cHIwKSAmJiAhKDAsIGxpYl8xLmlzQXJyYXkpKGV4cHIwKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IGV4cHIwO1xuICAgICAgICAgICAgaWYgKGV4cHIubCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfS5sIG1pc3NpbmcgaW4gJHtKU09OLnN0cmluZ2lmeShleHByKX1gKTtcbiAgICAgICAgICAgIGlmIChleHByLm8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHZhbGlkYXRlRXhwcmVzc2lvbjogJHticmVhZGNydW1ic30ubyBtaXNzaW5nIGluICR7SlNPTi5zdHJpbmdpZnkoZXhwcil9YCk7XG4gICAgICAgICAgICBpZiAoZXhwci5yID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWxpZGF0ZUV4cHJlc3Npb246ICR7YnJlYWRjcnVtYnN9LnIgbWlzc2luZyBpbiAke0pTT04uc3RyaW5naWZ5KGV4cHIpfWApO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHByLm8gIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdmFsaWRhdGVFeHByZXNzaW9uOiAke2JyZWFkY3J1bWJzfS5vIG5vdCBhIHN0cmluZ2ApO1xuICAgICAgICAgICAgaWYgKCF3b3JkSXNPcGVyYXRvcihvcGVyYXRvckxpc3QsIGV4cHIubykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGJyZWFkY3J1bWJzICsgJy5vIG5vdCB2YWxpZDogXCInICsgZXhwci5vICsgJ1wiJyk7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmFsaWRhdGVFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgZXhwci5sLCBicmVhZGNydW1icyArICcubCcpICYmXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCBleHByLnIsIGJyZWFkY3J1bWJzICsgJy5yJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIwICE9PSBudWxsICYmIHR5cGVvZiBleHByMCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGV4cHIwICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWxpZGF0ZUV4cHJlc3Npb246ICR7YnJlYWRjcnVtYnN9IGlzIG9mIGludmFsaWQgdHlwZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHdvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCB3b3Jkcykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCF3b3Jkcz8ubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3b3JkczJFeHByZXNzaW9uOiBzeW50YXggZXJyb3I6IHVuYmFsYW5jZWQgZXhwcmVzc2lvbicpO1xuICAgICAgICB3aGlsZSAod29yZHMubGVuZ3RoID09PSAxICYmIHdvcmRzWzBdICE9PSBudWxsICYmICgwLCBsaWJfMS5pc0FycmF5KSh3b3Jkc1swXSkpXG4gICAgICAgICAgICB3b3JkcyA9IHdvcmRzWzBdO1xuICAgICAgICBpZiAod29yZHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHdvcmRzWzBdO1xuICAgICAgICAvLyBGaW5kIHRoZSBvcGVyYXRvciB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5OlxuICAgICAgICBsZXQgb3BlcmF0b3JJID0gLTE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3BlcmF0b3JMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IG9wZXJhdG9yTGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvckkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0b3JJID0gd29yZHMubGFzdEluZGV4T2Yob3BlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVyYXRvckkgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBsID0gd29yZHMuc2xpY2UoMCwgb3BlcmF0b3JJKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB3b3Jkcy5zbGljZShvcGVyYXRvckkgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB7XG4gICAgICAgICAgICAgICAgbDogdGhpcy53b3JkczJFeHByZXNzaW9uKG9wZXJhdG9yTGlzdCwgbCksXG4gICAgICAgICAgICAgICAgbzogd29yZHNbb3BlcmF0b3JJXSxcbiAgICAgICAgICAgICAgICByOiB0aGlzLndvcmRzMkV4cHJlc3Npb24ob3BlcmF0b3JMaXN0LCByKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dvcmRzMkV4cHJlc3Npb246IHN5bnRheCBlcnJvcjogb3BlcmF0b3Igbm90IGZvdW5kOiBcIicgKyB3b3Jkcy5qb2luKCcgJykgKyAnXCInKTtcbiAgICB9XG59XG5leHBvcnRzLkV4cHJlc3Npb25IYW5kbGVyID0gRXhwcmVzc2lvbkhhbmRsZXI7XG5mdW5jdGlvbiBpc0V4cHJlc3Npb25PYmplY3QoZXhwcikge1xuICAgIHJldHVybiAodHlwZW9mIGV4cHIgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGV4cHIgIT09IG51bGwgJiZcbiAgICAgICAgZXhwci5sICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZXhwci5vICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgZXhwci5yICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gd29yZElzT3BlcmF0b3Iob3BlcmF0b3JMaXN0LCB3b3JkKSB7XG4gICAgaWYgKG9wZXJhdG9yTGlzdC5pbmRleE9mKHdvcmQpICE9PSAtMSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXhwcmVzc2lvbkhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkluc3RhbmNlSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGNhcF8xID0gcmVxdWlyZShcIi4vbGliL2NhcFwiKTtcbmNvbnN0IGV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRcIik7XG5jb25zdCBpbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vbGliL2luc3RhbmNlXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWIvbGliXCIpO1xuY29uc3QgcmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9saWIvcmVmZXJlbmNlXCIpO1xuY2xhc3MgSW5zdGFuY2VIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlZFRpbWVsaW5lKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgfVxuICAgIGludmVydEluc3RhbmNlcyhpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluc3RhbmNlcyA9IHRoaXMuY2xlYW5JbnN0YW5jZXMoaW5zdGFuY2VzLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGludmVydGVkSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VzWzBdLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLnJlc29sdmVkVGltZWxpbmUuZ2V0SW5zdGFuY2VJZCgpLFxuICAgICAgICAgICAgICAgICAgICBpc0ZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGluc3RhbmNlc1swXS5yZWZlcmVuY2VzLCBgQCR7aW5zdGFuY2VzWzBdLmlkfWApLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5zdGFuY2UgPSAoMCwgbGliXzEubGFzdCkoaW52ZXJ0ZWRJbnN0YW5jZXMpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IGluc3RhbmNlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVydGVkSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRJbnN0YW5jZUlkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogaW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShpbnN0YW5jZS5yZWZlcmVuY2VzLCBgQCR7aW5zdGFuY2UuaWR9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXBzOiBpbnN0YW5jZS5jYXBzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW52ZXJ0ZWRJbnN0YW5jZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRJbnN0YW5jZUlkKCksXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgbGlzdCBvZiBldmVudHMgaW50byBhIGxpc3Qgb2YgaW5zdGFuY2VzLlxuICAgICAqIEBwYXJhbSBldmVudHMgVGhlIGxpc3Qgb2Ygc3RhcnQtIGFuZCBlbmQtIGV2ZW50c1xuICAgICAqIEBwYXJhbSBhbGxvd01lcmdlIElmIHRydWUsIHdpbGwgbWVyZ2UgaW5zdGFuY2VzIHRoYXQgb3ZlcmxhcCBpbnRvIG9uZS5cbiAgICAgKiBAcGFyYW0gYWxsb3daZXJvR2FwcyBJZiB0cnVlLCBhbGxvd3MgemVyby1sZW5ndGggZ2FwcyBiZXR3ZWVuIGluc3RhbmNlcy4gSWYgZmFsc2UsIHdpbGwgY29tYmluZSB0aGUgdHdvIGludG8gb25lIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBvbWl0T3JpZ2luYWxTdGFydEVuZCBPZiB0cnVlLCB3aWxsIG5vdCBrZWVwIC5vcmlnaW5hbFN0YXJ0IGFuZCAub3JpZ2luYWxFbmQgb2YgdGhlIGluc3RhbmNlc1xuICAgICAqL1xuICAgIGNvbnZlcnRFdmVudHNUb0luc3RhbmNlcyhldmVudHMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMgPSBmYWxzZSwgb21pdE9yaWdpbmFsU3RhcnRFbmQgPSBmYWxzZSkge1xuICAgICAgICAoMCwgZXZlbnRfMS5zb3J0RXZlbnRzKShldmVudHMpO1xuICAgICAgICBjb25zdCBhY3RpdmVJbnN0YW5jZXMgPSB7fTtcbiAgICAgICAgbGV0IGFjdGl2ZUluc3RhbmNlSWQgPSBudWxsO1xuICAgICAgICBsZXQgcHJldmlvdXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbmVnYXRpdmVJbnN0YW5jZXMgPSB7fTtcbiAgICAgICAgbGV0IHByZXZpb3VzTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5lZ2F0aXZlSW5zdGFuY2VJZCA9IG51bGw7XG4gICAgICAgIGNvbnN0IHJldHVybkluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgICAgICBjb25zdCBldmVudElkID0gZXZlbnQuZGF0YS5pZCA/PyBldmVudC5kYXRhLmluc3RhbmNlLmlkO1xuICAgICAgICAgICAgY29uc3QgbGFzdEluc3RhbmNlID0gcmV0dXJuSW5zdGFuY2VzW3JldHVybkluc3RhbmNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChldmVudC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0LWV2ZW50XG4gICAgICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VzW2V2ZW50SWRdID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5lZ2F0aXZlSW5zdGFuY2VzW2V2ZW50SWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRW5kLWV2ZW50XG4gICAgICAgICAgICAgICAgZGVsZXRlIGFjdGl2ZUluc3RhbmNlc1tldmVudElkXTtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZUluc3RhbmNlc1tldmVudElkXSA9IGV2ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFjdGl2ZUluc3RhbmNlcykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYW4gYWN0aXZlIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgaWYgKCFhbGxvd01lcmdlICYmICFhbGxvd1plcm9HYXBzICYmIGxhc3RJbnN0YW5jZSAmJiBwcmV2aW91c05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIHByZXZpb3VzbHkgYW4gaW5BY3RpdmUgKG5lZ2F0aXZlKSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICBsYXN0SW5zdGFuY2Uuc3RhcnQgPSBldmVudC50aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbyA9IHRoaXMuaGFuZGxlQWN0aXZlSW5zdGFuY2VzKGV2ZW50LCBsYXN0SW5zdGFuY2UsIGFjdGl2ZUluc3RhbmNlSWQsIGV2ZW50SWQsIGFjdGl2ZUluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgPSBvLmFjdGl2ZUluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvLnJldHVybkluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSBvLnJldHVybkluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9taXRPcmlnaW5hbFN0YXJ0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2UgPSB7IC4uLm5ld0luc3RhbmNlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2Uub3JpZ2luYWxTdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdJbnN0YW5jZS5vcmlnaW5hbEVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybkluc3RhbmNlcy5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2aW91c0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaW5zdGFuY2VzIGFyZSBhY3RpdmVcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluc3RhbmNlICYmIHByZXZpb3VzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSBldmVudC50aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChPYmplY3Qua2V5cyhuZWdhdGl2ZUluc3RhbmNlcykubGVuZ3RoICYmICFldmVudC5kYXRhLm5vdEFOZWdhdGl2ZUluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgbmVnYXRpdmUgaW5zdGFuY2UgcnVubmluZ1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvID0gdGhpcy5oYW5kbGVBY3RpdmVJbnN0YW5jZXMoZXZlbnQsIGxhc3RJbnN0YW5jZSwgbmVnYXRpdmVJbnN0YW5jZUlkLCBldmVudElkLCBuZWdhdGl2ZUluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2Fwcyk7XG4gICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlSW5zdGFuY2VJZCA9IG8uYWN0aXZlSW5zdGFuY2VJZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG8ucmV0dXJuSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm8ucmV0dXJuSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IG8ucmV0dXJuSW5zdGFuY2UuZW5kID8/IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBvLnJldHVybkluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbWl0T3JpZ2luYWxTdGFydEVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0luc3RhbmNlLm9yaWdpbmFsU3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2Uub3JpZ2luYWxFbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMucHVzaChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByZXZpb3VzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiByZXR1cm5JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwgJiYgaW5zdGFuY2UuZW5kIDwgaW5zdGFuY2Uuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBuZWdhdGl2ZSBkdXJhdGlvbnMsIHNldCBpdCB0byB6ZXJvIGluc3RlYWQ6XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZW5kID0gaW5zdGFuY2Uuc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybkluc3RhbmNlcztcbiAgICB9XG4gICAgaGFuZGxlQWN0aXZlSW5zdGFuY2VzKGV2ZW50LCBsYXN0SW5zdGFuY2UsIGFjdGl2ZUluc3RhbmNlSWQsIGV2ZW50SWQsIGFjdGl2ZUluc3RhbmNlcywgYWxsb3dNZXJnZSwgYWxsb3daZXJvR2FwcyA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXR1cm5JbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIGlmICghYWxsb3dNZXJnZSAmJlxuICAgICAgICAgICAgZXZlbnQudmFsdWUgJiZcbiAgICAgICAgICAgIGxhc3RJbnN0YW5jZSAmJlxuICAgICAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCAhPT0gZXZlbnRJZCkge1xuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgaW5zdGFuY2U6XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gZXZlbnQudGltZTtcbiAgICAgICAgICAgIHJldHVybkluc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLnJlc29sdmVkVGltZWxpbmUuZ2V0SW5zdGFuY2VJZCgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBldmVudC50aW1lLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBldmVudC5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kOiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsRW5kLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxTdGFydCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhY3RpdmVJbnN0YW5jZUlkID0gZXZlbnRJZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWxsb3dNZXJnZSAmJiAhZXZlbnQudmFsdWUgJiYgbGFzdEluc3RhbmNlICYmIGFjdGl2ZUluc3RhbmNlSWQgPT09IGV2ZW50SWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBhY3RpdmUgaW5zdGFuY2Ugc3RvcHBlZCBwbGF5aW5nLCBidXQgYW5vdGhlciBpcyBzdGlsbCBwbGF5aW5nXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RJbnN0YW5jZSA9ICgwLCBsaWJfMS5yZWR1Y2VPYmopKGFjdGl2ZUluc3RhbmNlcywgKG1lbW8sIGluc3RhbmNlRXZlbnQsIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbW8gPT09IG51bGwgfHwgbWVtby5ldmVudC50aW1lIDwgaW5zdGFuY2VFdmVudC50aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogaW5zdGFuY2VFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIC8vIFJlc3RhcnQgdGhhdCBpbnN0YW5jZSBub3c6XG4gICAgICAgICAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9IGV2ZW50LnRpbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoMCwgaW5zdGFuY2VfMS5pc0luc3RhbmNlSWQpKGV2ZW50SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2V2ZW50SWR9XyR7dGhpcy5yZXNvbHZlZFRpbWVsaW5lLmdldEluc3RhbmNlSWQoKX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGBAJHtldmVudElkfV8ke3RoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRJbnN0YW5jZUlkKCl9YCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGV2ZW50LnRpbWUsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbGF0ZXN0SW5zdGFuY2UuZXZlbnQucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxFbmQsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGV2ZW50LmRhdGEuaW5zdGFuY2Uub3JpZ2luYWxTdGFydCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFjdGl2ZUluc3RhbmNlSWQgPSBsYXRlc3RJbnN0YW5jZS5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd01lcmdlICYmICFhbGxvd1plcm9HYXBzICYmIGxhc3RJbnN0YW5jZSAmJiBsYXN0SW5zdGFuY2UuZW5kID09PSBldmVudC50aW1lKSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJldmlvdXNseSBydW5uaW5nIGVuZGVkIGp1c3Qgbm93XG4gICAgICAgICAgICAvLyByZXN1bWUgcHJldmlvdXMgaW5zdGFuY2U6XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gbnVsbDtcbiAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzID0gKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShsYXN0SW5zdGFuY2UucmVmZXJlbmNlcywgZXZlbnQucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAoMCwgY2FwXzEuYWRkQ2Fwc1RvUmVzdW1pbmcpKGxhc3RJbnN0YW5jZSwgZXZlbnQuZGF0YS5pbnN0YW5jZS5jYXBzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbGFzdEluc3RhbmNlIHx8IGxhc3RJbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHByZXZpb3VzbHkgcnVubmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgaW5zdGFuY2U6XG4gICAgICAgICAgICByZXR1cm5JbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKDAsIGluc3RhbmNlXzEuaXNJbnN0YW5jZUlkKShldmVudElkKSA/IGV2ZW50SWQgOiBgQCR7ZXZlbnRJZH1gLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBldmVudC50aW1lLFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBldmVudC5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIGNhcHM6IGV2ZW50LmRhdGEuaW5zdGFuY2UuY2FwcyxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZDogZXZlbnQuZGF0YS5pbnN0YW5jZS5vcmlnaW5hbEVuZCxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0OiBldmVudC5kYXRhLmluc3RhbmNlLm9yaWdpbmFsU3RhcnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCA9IGV2ZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhbHJlYWR5IGEgcnVubmluZyBpbnN0YW5jZVxuICAgICAgICAgICAgbGFzdEluc3RhbmNlLnJlZmVyZW5jZXMgPSAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGxhc3RJbnN0YW5jZS5yZWZlcmVuY2VzLCBldmVudC5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICgwLCBjYXBfMS5hZGRDYXBzVG9SZXN1bWluZykobGFzdEluc3RhbmNlLCBldmVudC5kYXRhLmluc3RhbmNlLmNhcHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SW5zdGFuY2U/LmNhcHMgJiYgIWxhc3RJbnN0YW5jZS5jYXBzLmxlbmd0aClcbiAgICAgICAgICAgIGRlbGV0ZSBsYXN0SW5zdGFuY2UuY2FwcztcbiAgICAgICAgaWYgKHJldHVybkluc3RhbmNlICYmXG4gICAgICAgICAgICBsYXN0SW5zdGFuY2UgJiZcbiAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5zdGFydCA9PT0gbGFzdEluc3RhbmNlLmVuZCAmJlxuICAgICAgICAgICAgbGFzdEluc3RhbmNlLmVuZCA9PT0gcmV0dXJuSW5zdGFuY2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIHByZXZpb3VzIHplcm8tbGVuZ3RoIHdpdGggdGhpcyBvbmUgaW5zdGVhZFxuICAgICAgICAgICAgbGFzdEluc3RhbmNlLmlkID0gcmV0dXJuSW5zdGFuY2UuaWQ7XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2Uuc3RhcnQgPSByZXR1cm5JbnN0YW5jZS5zdGFydDtcbiAgICAgICAgICAgIGxhc3RJbnN0YW5jZS5lbmQgPSByZXR1cm5JbnN0YW5jZS5lbmQ7XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2UucmVmZXJlbmNlcyA9IHJldHVybkluc3RhbmNlLnJlZmVyZW5jZXM7XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2UuY2FwcyA9IHJldHVybkluc3RhbmNlLmNhcHM7XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2Uub3JpZ2luYWxTdGFydCA9IHJldHVybkluc3RhbmNlLm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICBsYXN0SW5zdGFuY2Uub3JpZ2luYWxFbmQgPSByZXR1cm5JbnN0YW5jZS5vcmlnaW5hbEVuZDtcbiAgICAgICAgICAgIHJldHVybkluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZlSW5zdGFuY2VJZCxcbiAgICAgICAgICAgIHJldHVybkluc3RhbmNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBpbnN0YW5jZXMsIGpvaW4gb3ZlcmxhcHBpbmcgZXRjLi5cbiAgICAgKiBAcGFyYW0gaW5zdGFuY2VzXG4gICAgICovXG4gICAgY2xlYW5JbnN0YW5jZXMoaW5zdGFuY2VzLCBhbGxvd01lcmdlLCBhbGxvd1plcm9HYXBzID0gZmFsc2UpIHtcbiAgICAgICAgLy8gRmlyc3QsIG9wdGltaXplIGZvciBjZXJ0YWluIGNvbW1vbiBzaXR1YXRpb25zOlxuICAgICAgICBpZiAoaW5zdGFuY2VzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgaWYgKGluc3RhbmNlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSB9LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGluc3RhbmNlLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5lbmQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlOiBpbnN0YW5jZSB9LFxuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRFdmVudHNUb0luc3RhbmNlcyhldmVudHMsIGFsbG93TWVyZ2UsIGFsbG93WmVyb0dhcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXAgaW5zdGFuY2VzIHNvIHRoYXQgdGhleSBhcmUgd2l0aGluIHRoZWlyIHBhcmVudEluc3RhbmNlc1xuICAgICAqIEBwYXJhbSBpbnN0YW5jZXNcbiAgICAgKiBAcGFyYW0gY2FwcGluZ0luc3RhbmNlc1xuICAgICAqL1xuICAgIGNhcEluc3RhbmNlcyhpbnN0YW5jZXMsIGNhcHBpbmdJbnN0YW5jZXMsIGFsbG93WmVyb0dhcHMgPSB0cnVlKSB7XG4gICAgICAgIGlmICgoMCwgcmVmZXJlbmNlXzEuaXNSZWZlcmVuY2UpKGNhcHBpbmdJbnN0YW5jZXMpIHx8IGNhcHBpbmdJbnN0YW5jZXMgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2VzO1xuICAgICAgICBsZXQgcmV0dXJuSW5zdGFuY2VzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZU9yZyA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkSW5zdGFuY2VUaW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2FwcGluZ0luc3RhbmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcEluc3RhbmNlID0gY2FwcGluZ0luc3RhbmNlc1tqXTtcbiAgICAgICAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIGluc3RhbmNlIGNyb3NzZXMgdGhlIHBhcmVudCBhdCBhbGw6XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlT3JnLnN0YXJ0IDw9IChjYXBJbnN0YW5jZS5lbmQgPz8gSW5maW5pdHkpICYmXG4gICAgICAgICAgICAgICAgICAgIChpbnN0YW5jZU9yZy5lbmQgPz8gSW5maW5pdHkpID49IGNhcEluc3RhbmNlLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5jYXBJbnN0YW5jZShpbnN0YW5jZU9yZywgY2FwSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhcnQgPj0gY2FwSW5zdGFuY2Uuc3RhcnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbnN0YW5jZS5lbmQgPz8gSW5maW5pdHkpIDw9IChjYXBJbnN0YW5jZS5lbmQgPz8gSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5zdGFuY2UgaXMgd2l0aGluIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCA9PT0gaW5zdGFuY2UuZW5kICYmIGFkZGVkSW5zdGFuY2VUaW1lcy5oYXMoaW5zdGFuY2Uuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHplcm8tbGVuZ3RoIGluc3RhbmNlcyBpZiB0aGVyZSBhcmUgYWxyZWFkeSBpcyBpbnN0YW5jZXMgY292ZXJpbmcgdGhhdCB0aW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5yZWZlcmVuY2VzID0gKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShpbnN0YW5jZS5yZWZlcmVuY2VzLCBjYXBJbnN0YW5jZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMucHVzaChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRJbnN0YW5jZVRpbWVzLmFkZChpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWRJbnN0YW5jZVRpbWVzLmFkZChpbnN0YW5jZS5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybkluc3RhbmNlcy5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0IC0gYi5zdGFydCk7XG4gICAgICAgIC8vIEVuc3VyZSB1bmlxdWUgaWRzOlxuICAgICAgICBjb25zdCBpZHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiByZXR1cm5JbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgaWYgKGlkc1tpbnN0YW5jZS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmlkID0gYCR7aW5zdGFuY2UuaWR9JHsrK2lkc1tpbnN0YW5jZS5pZF19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlkc1tpbnN0YW5jZS5pZF0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFuIHVwIHRoZSBpbnN0YW5jZXMsIHRvIHJlbW92ZSBkdXBsaWNhdGVzXG4gICAgICAgIHJldHVybkluc3RhbmNlcyA9IHRoaXMuY2xlYW5JbnN0YW5jZXMocmV0dXJuSW5zdGFuY2VzLCB0cnVlLCBhbGxvd1plcm9HYXBzKTtcbiAgICAgICAgcmV0dXJuIHJldHVybkluc3RhbmNlcztcbiAgICB9XG4gICAgY2FwSW5zdGFuY2UoaW5zdGFuY2VPcmcsIGNhcEluc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0geyAuLi5pbnN0YW5jZU9yZyB9O1xuICAgICAgICAvLyBDYXAgc3RhcnRcbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0IDwgY2FwSW5zdGFuY2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5zdGFuY2VTdGFydFRpbWUoaW5zdGFuY2UsIGNhcEluc3RhbmNlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYXAgZW5kXG4gICAgICAgIGlmICgoaW5zdGFuY2UuZW5kID8/IEluZmluaXR5KSA+IChjYXBJbnN0YW5jZS5lbmQgPz8gSW5maW5pdHkpKSB7XG4gICAgICAgICAgICB0aGlzLnNldEluc3RhbmNlRW5kVGltZShpbnN0YW5jZSwgY2FwSW5zdGFuY2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIHNldEluc3RhbmNlRW5kVGltZShpbnN0YW5jZSwgZW5kVGltZSkge1xuICAgICAgICBpbnN0YW5jZS5vcmlnaW5hbEVuZCA9IGluc3RhbmNlLm9yaWdpbmFsRW5kID8/IGluc3RhbmNlLmVuZDtcbiAgICAgICAgaW5zdGFuY2UuZW5kID0gZW5kVGltZTtcbiAgICB9XG4gICAgc2V0SW5zdGFuY2VTdGFydFRpbWUoaW5zdGFuY2UsIHN0YXJ0VGltZSkge1xuICAgICAgICBpbnN0YW5jZS5vcmlnaW5hbFN0YXJ0ID0gaW5zdGFuY2Uub3JpZ2luYWxTdGFydCA/PyBpbnN0YW5jZS5zdGFydDtcbiAgICAgICAgaW5zdGFuY2Uuc3RhcnQgPSBzdGFydFRpbWU7XG4gICAgfVxuICAgIGFwcGx5UmVwZWF0aW5nSW5zdGFuY2VzKGluc3RhbmNlcywgcmVwZWF0VGltZTApIHtcbiAgICAgICAgaWYgKHJlcGVhdFRpbWUwID09PSBudWxsIHx8ICFyZXBlYXRUaW1lMC52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZXM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVkVGltZWxpbmUub3B0aW9ucztcbiAgICAgICAgY29uc3QgcmVwZWF0VGltZSA9IHJlcGVhdFRpbWUwLnZhbHVlO1xuICAgICAgICBjb25zdCByZXBlYXRlZEluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGluc3RhbmNlcykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0VGltZSA9IE1hdGgubWF4KG9wdGlvbnMudGltZSAtICgob3B0aW9ucy50aW1lIC0gaW5zdGFuY2Uuc3RhcnQpICUgcmVwZWF0VGltZSksIGluc3RhbmNlLnN0YXJ0KTtcbiAgICAgICAgICAgIGxldCBlbmRUaW1lID0gaW5zdGFuY2UuZW5kID09PSBudWxsID8gbnVsbCA6IGluc3RhbmNlLmVuZCArIChzdGFydFRpbWUgLSBpbnN0YW5jZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBjYXAgPSAoaW5zdGFuY2UuY2Fwc1xuICAgICAgICAgICAgICAgID8gaW5zdGFuY2UuY2Fwcy5maW5kKChjYXApID0+IGluc3RhbmNlLnJlZmVyZW5jZXMuaW5kZXhPZihgQCR7Y2FwLmlkfWApICE9PSAtMSlcbiAgICAgICAgICAgICAgICA6IG51bGwpID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IG9wdGlvbnMubGltaXRDb3VudCA/PyAyO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubGltaXRUaW1lICYmIHN0YXJ0VGltZSA+PSBvcHRpb25zLmxpbWl0VGltZSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FwcGVkU3RhcnRUaW1lID0gY2FwID8gTWF0aC5tYXgoY2FwLnN0YXJ0LCBzdGFydFRpbWUpIDogc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcHBlZEVuZFRpbWUgPSBjYXAgJiYgY2FwLmVuZCAhPT0gbnVsbCAmJiBlbmRUaW1lICE9PSBudWxsID8gTWF0aC5taW4oY2FwLmVuZCwgZW5kVGltZSkgOiBlbmRUaW1lO1xuICAgICAgICAgICAgICAgIGlmICgoY2FwcGVkRW5kVGltZSA/PyBJbmZpbml0eSkgPiBjYXBwZWRTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwZWF0ZWRJbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5yZXNvbHZlZFRpbWVsaW5lLmdldEluc3RhbmNlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjYXBwZWRTdGFydFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGNhcHBlZEVuZFRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGluc3RhbmNlLnJlZmVyZW5jZXMsIHJlcGVhdFRpbWUwLnJlZmVyZW5jZXMsIGBAJHtpbnN0YW5jZS5pZH1gKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZSArPSByZXBlYXRUaW1lO1xuICAgICAgICAgICAgICAgIGlmIChlbmRUaW1lICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBlbmRUaW1lICs9IHJlcGVhdFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYW5JbnN0YW5jZXMocmVwZWF0ZWRJbnN0YW5jZXMsIGZhbHNlKTtcbiAgICB9XG59XG5leHBvcnRzLkluc3RhbmNlSGFuZGxlciA9IEluc3RhbmNlSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUluc3RhbmNlSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGF5ZXJTdGF0ZUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYi9saWJcIik7XG5jb25zdCBwZXJmb3JtYW5jZV8xID0gcmVxdWlyZShcIi4vbGliL3BlcmZvcm1hbmNlXCIpO1xuLyoqXG4gKiBMYXllclN0YXRlSGFuZGxlciBpbnN0YW5jZXMgYXJlIHNob3J0LWxpdmVkLlxuICogVGhleSBhcmUgaW5pdGlhbGl6ZWQsIC5yZXNvbHZlQ29uZmxpY3RzKCkgaXMgY2FsbGVkIGFuZCB0aGVuIGRpc2NhcmRlZFxuICovXG5jbGFzcyBMYXllclN0YXRlSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IocmVzb2x2ZWRUaW1lbGluZSwgaW5zdGFuY2UsIGxheWVyKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRUaW1lbGluZSA9IHJlc29sdmVkVGltZWxpbmU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLnBvaW50c0luVGltZSA9IHt9O1xuICAgICAgICB0aGlzLm9iamVjdHNPbkxheWVyID0gW107XG4gICAgICAgIHRoaXMub2JqZWN0SWRzT25MYXllciA9IHRoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRMYXllck9iamVjdHMobGF5ZXIpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVGltZWxpbmUub3B0aW9ucy5kZWJ1ZylcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKiogUmVzb2x2ZSBjb25mbGljdHMgYmV0d2VlbiBvYmplY3RzIG9uIHRoZSBsYXllci4gKi9cbiAgICByZXNvbHZlQ29uZmxpY3RzKCkge1xuICAgICAgICBjb25zdCB0b2MgPSAoMCwgcGVyZm9ybWFuY2VfMS50aWMpKCcgICAgICAgcmVzb2x2ZUNvbmZsaWN0cycpO1xuICAgICAgICAvKlxuICAgICAgICAgICAgVGhpcyBhbGdvcml0bSBiYXNpY2FsbHkgd29ya3MgbGlrZSB0aGlzOlxuXG4gICAgICAgICAgICAxLiBDb2xsZWN0IGFsbCBpbnN0YW5jZXMgc3RhcnQtIGFuZCBlbmQtdGltZXMgYXMgcG9pbnRzLW9mLWludGVyZXN0XG4gICAgICAgICAgICAyLiBTd2VlcCB0aHJvdWdoIHRoZSBwb2ludHMtb2YtaW50ZXJlc3QgYW5kIGRldGVybWluZSB3aGljaCBpbnN0YW5jZSBpcyB0aGUgXCJ3aW5uaW5nIG9uZVwiIGF0IGV2ZXJ5IHBvaW50IGluIHRpbWVcbiAgICAgICAgKi9cbiAgICAgICAgLy8gUG9wdWxhdGUgdGhpcy5vYmplY3RzT25MYXllcjpcbiAgICAgICAgZm9yIChjb25zdCBvYmpJZCBvZiB0aGlzLm9iamVjdElkc09uTGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0c09uTGF5ZXIucHVzaCh0aGlzLnJlc29sdmVkVGltZWxpbmUuZ2V0T2JqZWN0KG9iaklkKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdC1wYXRoOiBpZiB0aGVyZSdzIG9ubHkgb25lIG9iamVjdCBvbiB0aGUgbGF5ZXIsIGl0IGNhbid0IGNvbmZsaWN0IHdpdGggYW55dGhpbmdcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0c09uTGF5ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiB0aGlzLm9iamVjdHNPbkxheWVyKSB7XG4gICAgICAgICAgICAgICAgb2JqLnJlc29sdmVkLnJlc29sdmVkQ29uZmxpY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2Uub3JpZ2luYWxTdGFydCA9IGluc3RhbmNlLm9yaWdpbmFsU3RhcnQgPz8gaW5zdGFuY2Uuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLm9yaWdpbmFsRW5kID0gaW5zdGFuY2Uub3JpZ2luYWxFbmQgPz8gaW5zdGFuY2UuZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnKGA9PT09PT09IHJlc29sdmVDb25mbGljdHMgXCIke3RoaXMubGF5ZXJ9XCIgKCR7dGhpcy5vYmplY3RzT25MYXllci5sZW5ndGh9IG9iamVjdHMpYCk7XG4gICAgICAgIC8vIFNvcnQgdG8gbWFrZSBzdXJlIHBhcmVudCBncm91cHMgYXJlIGV2YWx1YXRlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW46XG4gICAgICAgIHRoaXMub2JqZWN0c09uTGF5ZXIuc29ydChjb21wYXJlT2JqZWN0c09uTGF5ZXIpO1xuICAgICAgICAvLyBTdGVwIDE6IENvbGxlY3QgYWxsIHBvaW50cy1vZi1pbnRlcmVzdCAod2hpY2ggcG9pbnRzIGluIHRpbWUgd2Ugd2FudCB0byBldmFsdWF0ZSlcbiAgICAgICAgLy8gYW5kIHdoaWNoIGluc3RhbmNlcyB0aGF0IGFyZSBpbnRlcmVzdGluZ1xuICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiB0aGlzLm9iamVjdHNPbkxheWVyKSB7XG4gICAgICAgICAgICAvLyBOb3RlczpcbiAgICAgICAgICAgIC8vIFNpbmNlIGtleWZyYW1lcyBjYW4ndCBiZSBwbGFjZWQgb24gYSBsYXllciwgd2UgYXNzdW1lIHRoYXQgdGhlIG9iamVjdCBpcyBub3QgYSBrZXlmcmFtZVxuICAgICAgICAgICAgLy8gV2UgYWxzbyBhc3N1bWUgdGhhdCB0aGUgb2JqZWN0IGhhcyBhIGxheWVyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lRXZlbnRzID0gW107XG4gICAgICAgICAgICAgICAgdGltZUV2ZW50cy5wdXNoKHsgdGltZTogaW5zdGFuY2Uuc3RhcnQsIGVuYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kKVxuICAgICAgICAgICAgICAgICAgICB0aW1lRXZlbnRzLnB1c2goeyB0aW1lOiBpbnN0YW5jZS5lbmQsIGVuYWJsZTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBhIHJlZmVyZW5jZSB0byB0aGlzIGluc3RhbmNlIG9uIGFsbCBwb2ludHMgaW4gdGltZSB0aGF0IGNvdWxkIGFmZmVjdCBpdDpcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRpbWVFdmVudCBvZiB0aW1lRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lRXZlbnQuZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50SW5UaW1lKHRpbWVFdmVudC50aW1lLCAnc3RhcnQnLCBvYmosIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnRJblRpbWUodGltZUV2ZW50LnRpbWUsICdlbmQnLCBvYmosIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5yZXNvbHZlZC5yZXNvbHZlZENvbmZsaWN0cyA9IHRydWU7XG4gICAgICAgICAgICBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzLnNwbGljZSgwKTsgLy8gY2xlYXIgdGhlIGluc3RhbmNlcywgc28gbmV3IGluc3RhbmNlcyBjYW4gYmUgcmUtYWRkZWQgbGF0ZXJcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDI6IFJlc29sdmUgdGhlIHN0YXRlIGZvciB0aGUgcG9pbnRzLW9mLWludGVyZXN0XG4gICAgICAgIC8vIFRoaXMgaXMgZG9uZSBieSBzd2VlcGluZyB0aGUgcG9pbnRzLW9mLWludGVyZXN0IGNocm9ub2xvZ2ljYWxseSxcbiAgICAgICAgLy8gZGV0ZXJtaW5pbmcgdGhlIHN0YXRlIGZvciBldmVyeSBwb2ludCBpbiB0aW1lIGJ5IGFkZGluZyAmIHJlbW92aW5nIG9iamVjdHMgZnJvbSBhc3BpcmluZ0luc3RhbmNlc1xuICAgICAgICAvLyBUaGVuIHNvcnRpbmcgaXQgdG8gZGV0ZXJtaW5lIHdobyB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGFjdGl2ZU9iaklkcyA9IHt9O1xuICAgICAgICAvKiogVGhlIG9iamVjdHMgaW4gYXNwaXJpbmdJbnN0YW5jZXMgICovXG4gICAgICAgIGxldCBhc3BpcmluZ0luc3RhbmNlcyA9IFtdO1xuICAgICAgICBjb25zdCB0aW1lcyA9IE9iamVjdC5rZXlzKHRoaXMucG9pbnRzSW5UaW1lKVxuICAgICAgICAgICAgLm1hcCgodGltZSkgPT4gcGFyc2VGbG9hdCh0aW1lKSlcbiAgICAgICAgICAgIC8vIFNvcnQgY2hyb25vbG9naWNhbGx5OlxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBwb2ludHMtb2YtaW50ZXJlc3QgdGltZXM6XG4gICAgICAgIGZvciAoY29uc3QgdGltZSBvZiB0aW1lcykge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhgLS0tLS0tLS0tLS0tLS0gdGltZTogJHt0aW1lfWApO1xuICAgICAgICAgICAgLyoqIEEgc2V0IG9mIGlkZW50aWZpZXJzIGZvciB3aGljaCBpbnN0YW5jZS1ldmVudHMgaGF2ZSBiZWVuIGNoZWNrIGF0IHRoaXMgcG9pbnQgaW4gdGltZS4gVXNlZCB0byBhdm9pZCBsb29raW5nIGF0IHRoZSBzYW1lIG9iamVjdCB0d2ljZS4gKi9cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrZWRUaGlzVGltZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIC8qKiBMaXN0IG9mIHRoZSBpbnN0YW5jZXMgdG8gY2hlY2sgYXQgdGhpcyBwb2ludCBpbiB0aW1lLiAqL1xuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2VzVG9DaGVjayA9IHRoaXMucG9pbnRzSW5UaW1lW3RpbWVdO1xuICAgICAgICAgICAgaW5zdGFuY2VzVG9DaGVjay5zb3J0KGNvbXBhcmVJbnN0YW5jZXNUb0NoZWNrKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgaW5zdGFuY2VzVG9DaGVjay5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG8gPSBpbnN0YW5jZXNUb0NoZWNrW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iaiA9IG8ub2JqO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gby5pbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBsZXQgdG9CZUVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0ID09PSB0aW1lICYmIGluc3RhbmNlLmVuZCA9PT0gdGltZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgemVyby1sZW5ndGggaW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICBpZiAoby5pbnN0YW5jZUV2ZW50ID09PSAnc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9CZUVuYWJsZWQgPSB0cnVlOyAvLyBTdGFydCBhIHplcm8tbGVuZ3RoIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQmVFbmFibGVkID0gZmFsc2U7IC8vIEVuZCBhIHplcm8tbGVuZ3RoIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b0JlRW5hYmxlZCA9IChpbnN0YW5jZS5zdGFydCB8fCAwKSA8PSB0aW1lICYmIChpbnN0YW5jZS5lbmQgPz8gSW5maW5pdHkpID4gdGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGAke29iai5pZH1fJHtpbnN0YW5jZS5pZH1fJHtvLmluc3RhbmNlRXZlbnR9YDtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrZWRUaGlzVGltZS5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBjaGVjayBlYWNoIG9iamVjdCBhbmQgZXZlbnQtdHlwZSBvbmNlIGZvciBldmVyeSBwb2ludCBpbiB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWRUaGlzVGltZS5hZGQoaWRlbnRpZmllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0JlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGluc3RhbmNlIHdhbnRzIHRvIGJlIGVuYWJsZWQgKGlzIHN0YXJ0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGFzcGlyaW5nSW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXMucHVzaCh7IG9iaiwgaW5zdGFuY2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5zdGFuY2UgZG9lc24ndCB3YW50IHRvIGJlIGVuYWJsZWQgKGlzIGVuZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGFzcGlyaW5nSW5zdGFuY2VzOlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNwaXJpbmdJbnN0YW5jZXMgPSByZW1vdmVGcm9tQXNwaXJpbmdJbnN0YW5jZXMoYXNwaXJpbmdJbnN0YW5jZXMsIG9iai5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU29ydCB0aGUgaW5zdGFuY2VzIG9uIGxheWVyIHRvIGRldGVybWluZSB3aG8gaXMgdGhlIGFjdGl2ZSBvbmU6XG4gICAgICAgICAgICAgICAgICAgIGFzcGlyaW5nSW5zdGFuY2VzLnNvcnQoY29tcGFyZUFzcGlyaW5nSW5zdGFuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIGZpcnN0IGluc3RhbmNlIGluIGFzcGlyaW5nSW5zdGFuY2VzIGlzIHRoZSBhY3RpdmUgb25lLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZU9uVG9wT2ZMYXllciA9IGFzcGlyaW5nSW5zdGFuY2VzWzBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgY3VycmVudCBzdGF0ZTpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldk9iakluc3RhbmNlID0gY3VycmVudFN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlT2xkID0gaW5zdGFuY2VPblRvcE9mTGF5ZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghcHJldk9iakluc3RhbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldk9iakluc3RhbmNlLmlkICE9PSBpbnN0YW5jZU9uVG9wT2ZMYXllci5vYmouaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcHJldk9iakluc3RhbmNlLmluc3RhbmNlLmlkLnN0YXJ0c1dpdGgoYCR7aW5zdGFuY2VPblRvcE9mTGF5ZXIuaW5zdGFuY2UuaWR9YCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVPbGQgPSAhaW5zdGFuY2VPblRvcE9mTGF5ZXIgJiYgcHJldk9iakluc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZU9sZCB8fCByZW1vdmVPbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2T2JqSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXAgdGhlIG9sZCBpbnN0YW5jZSwgc28gaXQnbGwgZW5kIGF0IHRoaXMgcG9pbnQgaW4gdGltZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldEluc3RhbmNlRW5kVGltZShwcmV2T2JqSW5zdGFuY2UuaW5zdGFuY2UsIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoYCR7cHJldk9iakluc3RhbmNlLmlkfSBzdG9wYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGFjdGl2ZU9iaklkczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWN0aXZlT2JqSWRzW3ByZXZPYmpJbnN0YW5jZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VPbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgbmV3IG9iamVjdEluc3RhbmNlIHRvIGJlIHRoZSBjdXJyZW50IG9uZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPYmogPSBpbnN0YW5jZU9uVG9wT2ZMYXllci5vYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKGAke2N1cnJlbnRPYmouaWR9IHBsYXlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0luc3RhbmNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmluc3RhbmNlT25Ub3BPZkxheWVyLmluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIHNldHRpbmcgbmV3IHN0YXJ0ICYgZW5kIHRpbWVzIHNvIHRoZXkgbWF0Y2ggdXAgd2l0aCB0aGUgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21JbnN0YW5jZUlkOiBpbnN0YW5jZU9uVG9wT2ZMYXllci5pbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZDogaW5zdGFuY2VPblRvcE9mTGF5ZXIuaW5zdGFuY2Uub3JpZ2luYWxFbmQgPz8gaW5zdGFuY2VPblRvcE9mTGF5ZXIuaW5zdGFuY2UuZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGluc3RhbmNlT25Ub3BPZkxheWVyLmluc3RhbmNlLm9yaWdpbmFsU3RhcnQgPz8gaW5zdGFuY2VPblRvcE9mTGF5ZXIuaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgaW5zdGFuY2UgaWQgdW5pcXVlOlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50T2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50T2JqLnJlc29sdmVkLmluc3RhbmNlc1tpXS5pZCA9PT0gbmV3SW5zdGFuY2UuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SW5zdGFuY2UuaWQgPSBgJHtuZXdJbnN0YW5jZS5pZH1fJCR7Y3VycmVudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RofWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE9iai5yZXNvbHZlZC5pbnN0YW5jZXMucHVzaChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdPYmpJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jdXJyZW50T2JqLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBuZXdJbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRvIGN1cnJlbnQgc3RhdGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSBuZXdPYmpJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhY3RpdmVPYmpJZHM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVPYmpJZHNbbmV3T2JqSW5zdGFuY2UuaWRdID0gbmV3T2JqSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVtb3ZlT2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgZnJvbSBjdXJyZW50IHN0YXRlOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBpbnN0YW5jZXMgb2YgYWxsIG9iamVjdHMgYXJlIGNhbGN1bGF0ZWQsXG4gICAgICAgIC8vIHRha2luZyBpbnRvIGFjY291bnQgcHJpb3JpdGllcywgY2xhc2hlcyBldGMuXG4gICAgICAgIC8vIENhcCBjaGlsZHJlbiBpbnNpZGUgdGhlaXIgcGFyZW50czpcbiAgICAgICAgLy8gRnVuY3Rpb25hbGx5LCB0aGlzIGlzbid0IG5lZWRlZCBzaW5jZSB0aGlzIGlzIGRvbmUgaW4gUmVzb2x2ZWRUaW1lbGluZUhhbmRsZXIucmVzb2x2ZVRpbWVsaW5lT2JqKCkgYW55d2F5LlxuICAgICAgICAvLyBIb3dldmVyIGJ5IGNhcHBpbmcgY2hpbGRyZW4gaGVyZSBzb21lIHJlLWV2YWx1YXRpbmcgaXRlcmF0aW9ucyBjYW4gYmUgYXZvaWRlZCwgc28gdGhpcyBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbENoaWxkcmVuID0gdGhpcy5vYmplY3RzT25MYXllclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9iaikgPT4gISFvYmoucmVzb2x2ZWQucGFyZW50SWQpXG4gICAgICAgICAgICAgICAgLy8gU29ydCwgc28gdGhhdCB0aGUgb3V0ZXJtb3N0IGFyZSBoYW5kbGVkIGZpcnN0OlxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmVzb2x2ZWQubGV2ZWxEZWVwIC0gYi5yZXNvbHZlZC5sZXZlbERlZXA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGFsbENoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnJlc29sdmVkVGltZWxpbmUuZ2V0T2JqZWN0KG9iai5yZXNvbHZlZC5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlLmNsZWFuSW5zdGFuY2VzKHRoaXMuaW5zdGFuY2UuY2FwSW5zdGFuY2VzKG9iai5yZXNvbHZlZC5pbnN0YW5jZXMsIHBhcmVudC5yZXNvbHZlZC5pbnN0YW5jZXMpLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoJz09PT0gcmVzb2x2ZUNvbmZsaWN0cyBkb25lJyk7XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICAvKiogQWRkIGFuIGluc3RhbmNlIGFuZCBldmVudCB0byBhIGNlcnRhaW4gcG9pbnQtaW4tdGltZSAqL1xuICAgIGFkZFBvaW50SW5UaW1lKHRpbWUsIGluc3RhbmNlRXZlbnQsIG9iaiwgaW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm90ZSBvbiBvcmRlcjogRW5kaW5nIGV2ZW50cyBjb21lIGJlZm9yZSBzdGFydGluZyBldmVudHNcbiAgICAgICAgdGhpcy5kZWJ1ZygnYWRkUG9pbnRJblRpbWUnLCB0aW1lLCBpbnN0YW5jZUV2ZW50LCBpbnN0YW5jZSk7XG4gICAgICAgIGlmICghdGhpcy5wb2ludHNJblRpbWVbdGltZSArICcnXSlcbiAgICAgICAgICAgIHRoaXMucG9pbnRzSW5UaW1lW3RpbWUgKyAnJ10gPSBbXTtcbiAgICAgICAgdGhpcy5wb2ludHNJblRpbWVbdGltZSArICcnXS5wdXNoKHsgb2JqLCBpbnN0YW5jZSwgaW5zdGFuY2VFdmVudCB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxheWVyU3RhdGVIYW5kbGVyID0gTGF5ZXJTdGF0ZUhhbmRsZXI7XG5mdW5jdGlvbiBjb21wYXJlT2JqZWN0c09uTGF5ZXIoYSwgYikge1xuICAgIC8vIFNvcnQgdG8gbWFrZSBzdXJlIHBhcmVudCBncm91cHMgYXJlIGV2YWx1YXRlZCBiZWZvcmUgdGhlaXIgY2hpbGRyZW46XG4gICAgcmV0dXJuIGEucmVzb2x2ZWQubGV2ZWxEZWVwIC0gYi5yZXNvbHZlZC5sZXZlbERlZXAgfHwgKDAsIGxpYl8xLmNvbXBhcmVTdHJpbmdzKShhLmlkLCBiLmlkKTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVJbnN0YW5jZXNUb0NoZWNrKGEsIGIpIHtcbiAgICAvLyBOb3RlOiB3ZSBhc3N1bWUgdGhhdCB0aGVyZSBhcmUgbm8ga2V5ZnJhbWVzIGhlcmUuIChpZiB0aGVyZSB3aGVyZSwgdGhleSB3b3VsZCBiZSBzb3J0ZWQgZmlyc3QpXG4gICAgaWYgKGEuaW5zdGFuY2UuaWQgPT09IGIuaW5zdGFuY2UuaWQgJiYgYS5pbnN0YW5jZS5zdGFydCA9PT0gYi5pbnN0YW5jZS5zdGFydCAmJiBhLmluc3RhbmNlLmVuZCA9PT0gYi5pbnN0YW5jZS5lbmQpIHtcbiAgICAgICAgLy8gQSAmIEIgYXJlIHRoZSBzYW1lIGluc3RhbmNlLCBpdCBpcyBhIHplcm8tbGVuZ3RoIGluc3RhbmNlIVxuICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHB1dCB0aGUgc3RhcnQgYmVmb3JlIHRoZSBlbmQ6XG4gICAgICAgIGlmIChhLmluc3RhbmNlRXZlbnQgPT09ICdzdGFydCcgJiYgYi5pbnN0YW5jZUV2ZW50ID09PSAnZW5kJylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEuaW5zdGFuY2VFdmVudCA9PT0gJ2VuZCcgJiYgYi5pbnN0YW5jZUV2ZW50ID09PSAnc3RhcnQnKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBlbmRpbmcgaW5zdGFuY2VzIGZpcnN0OlxuICAgIGlmIChhLmluc3RhbmNlRXZlbnQgPT09ICdzdGFydCcgJiYgYi5pbnN0YW5jZUV2ZW50ID09PSAnZW5kJylcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGEuaW5zdGFuY2VFdmVudCA9PT0gJ2VuZCcgJiYgYi5pbnN0YW5jZUV2ZW50ID09PSAnc3RhcnQnKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEuaW5zdGFuY2Uuc3RhcnQgPT09IGEuaW5zdGFuY2UuZW5kIHx8IGIuaW5zdGFuY2Uuc3RhcnQgPT09IGIuaW5zdGFuY2UuZW5kKSB7XG4gICAgICAgIC8vIFB1dCBsYXRlci1lbmRpbmcgaW5zdGFuY2VzIGxhc3QgKGluIHRoZSBjYXNlIG9mIHplcm8tbGVuZ3RoIHZzIG5vbi16ZXJvLWxlbmd0aCBpbnN0YW5jZSk6XG4gICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSAoYS5pbnN0YW5jZS5lbmQgPz8gSW5maW5pdHkpIC0gKGIuaW5zdGFuY2UuZW5kID8/IEluZmluaXR5KTtcbiAgICAgICAgaWYgKGRpZmZlcmVuY2UpXG4gICAgICAgICAgICByZXR1cm4gZGlmZmVyZW5jZTtcbiAgICB9XG4gICAgaWYgKGEub2JqLnJlc29sdmVkICYmIGIub2JqLnJlc29sdmVkKSB7XG4gICAgICAgIC8vIERlZXBlciBvYmplY3RzIChjaGlsZHJlbiBpbiBncm91cHMpIGNvbWVzIGxhdGVyLCB3ZSB3YW50IHRvIGNoZWNrIHRoZSBwYXJlbnQgZ3JvdXBzIGZpcnN0OlxuICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gYS5vYmoucmVzb2x2ZWQubGV2ZWxEZWVwIC0gYi5vYmoucmVzb2x2ZWQubGV2ZWxEZWVwO1xuICAgICAgICBpZiAoZGlmZmVyZW5jZSlcbiAgICAgICAgICAgIHJldHVybiBkaWZmZXJlbmNlO1xuICAgIH1cbiAgICAvLyBMYXN0IHJlc29ydCwgc29ydCBieSBpZCB0byBtYWtlIGl0IGRldGVybWluaXN0aWM6XG4gICAgcmV0dXJuICgwLCBsaWJfMS5jb21wYXJlU3RyaW5ncykoYS5vYmouaWQsIGIub2JqLmlkKSB8fCAoMCwgbGliXzEuY29tcGFyZVN0cmluZ3MpKGEuaW5zdGFuY2UuaWQsIGIuaW5zdGFuY2UuaWQpO1xufVxuY29uc3QgcmVtb3ZlRnJvbUFzcGlyaW5nSW5zdGFuY2VzID0gKGFzcGlyaW5nSW5zdGFuY2VzLCBvYmpJZCkgPT4ge1xuICAgIGNvbnN0IHJldHVybkluc3RhbmNlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXNwaXJpbmdJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFzcGlyaW5nSW5zdGFuY2VzW2ldLm9iai5pZCAhPT0gb2JqSWQpXG4gICAgICAgICAgICByZXR1cm5JbnN0YW5jZXMucHVzaChhc3BpcmluZ0luc3RhbmNlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5JbnN0YW5jZXM7XG59O1xuZnVuY3Rpb24gY29tcGFyZUFzcGlyaW5nSW5zdGFuY2VzKGEsIGIpIHtcbiAgICAvLyBEZXRlcm1pbmUgd2hvIHRha2VzIHByZWNlZGVuY2U6XG4gICAgcmV0dXJuICgoYi5vYmoucHJpb3JpdHkgfHwgMCkgLSAoYS5vYmoucHJpb3JpdHkgfHwgMCkgfHwgLy8gRmlyc3QsIHNvcnQgdXNpbmcgcHJpb3JpdHlcbiAgICAgICAgYi5pbnN0YW5jZS5zdGFydCAtIGEuaW5zdGFuY2Uuc3RhcnQgfHwgLy8gVGhlbiwgc29ydCB1c2luZyB0aGUgc3RhcnQgdGltZVxuICAgICAgICAoMCwgbGliXzEuY29tcGFyZVN0cmluZ3MpKGEub2JqLmlkLCBiLm9iai5pZCkgfHwgLy8gTGFzdCByZXNvcnQsIHNvcnQgYnkgaWQgdG8gbWFrZSBpdCBkZXRlcm1pbmlzdGljXG4gICAgICAgICgwLCBsaWJfMS5jb21wYXJlU3RyaW5ncykoYS5pbnN0YW5jZS5pZCwgYi5pbnN0YW5jZS5pZCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGF5ZXJTdGF0ZUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlZmVyZW5jZUhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYi9saWJcIik7XG5jb25zdCBjYXBfMSA9IHJlcXVpcmUoXCIuL2xpYi9jYXBcIik7XG5jb25zdCBldmVudF8xID0gcmVxdWlyZShcIi4vbGliL2V2ZW50XCIpO1xuY29uc3QgcmVmZXJlbmNlXzEgPSByZXF1aXJlKFwiLi9saWIvcmVmZXJlbmNlXCIpO1xuY29uc3QgZXhwcmVzc2lvbl8xID0gcmVxdWlyZShcIi4vbGliL2V4cHJlc3Npb25cIik7XG5jbGFzcyBSZWZlcmVuY2VIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXNvbHZlZFRpbWVsaW5lLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLnJlc29sdmVkVGltZWxpbmUgPSByZXNvbHZlZFRpbWVsaW5lO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMub3BlcmF0ZUFwcGx5UGFyZW50SW5zdGFuY2UgPSAoYSwgYikgPT4ge1xuICAgICAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGEudmFsdWUgKyBiLnZhbHVlLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9vayB1cCBhIHJlZmVyZW5jZSBvbiB0aGUgdGltZWxpbmVcbiAgICAgKiBSZXR1cm4gdmFsdWVzOlxuICAgICAqIFRpbWVsaW5lT2JqZWN0SW5zdGFuY2VbXTogSW5zdGFuY2VzIG9uIHRoZSB0aW1lbGluZSB3aGVyZSB0aGUgcmVmZXJlbmNlIGV4cHJlc3Npb24gaXMgdHJ1ZVxuICAgICAqIFZhbHVlV2l0aFJlZmVyZW5jZTogQSBzaW5ndWxhciB2YWx1ZSB3aGljaCBjYW4gYmUgY29tYmluZWQgYXJpdGhtZXRpY2FsbHkgd2l0aCBJbnN0YW5jZXNcbiAgICAgKiBudWxsOiBNZWFucyBcInNvbWV0aGluZyBpcyBpbnZhbGlkXCIsIGFuIG51bGwtdmFsdWUgd2lsbCBhbHdheXMgcmV0dXJuIG51bGwgd2hlbiBjb21iaW5lZCB3aXRoIG90aGVyIHZhbHVlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqIEBwYXJhbSBleHByXG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKi9cbiAgICBsb29rdXBFeHByZXNzaW9uKG9iaiwgZXhwciwgY29udGV4dCkge1xuICAgICAgICBpZiAoZXhwciA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbiAgICAgICAgaWYgKHR5cGVvZiBleHByID09PSAnc3RyaW5nJyAmJiAoMCwgZXhwcmVzc2lvbl8xLmlzTnVtZXJpY0V4cHIpKGV4cHIpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChleHByKSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZXhwcixcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGV4cHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBleHByID0gZXhwci50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBleHByTG93ZXIgPSBleHByLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoZXhwckxvd2VyID09PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHByTG93ZXIgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb29rIHVwIHN0cmluZ1xuICAgICAgICAgICAgbGV0IHJlZmVyZW5jZWRPYmpzID0gW107XG4gICAgICAgICAgICBsZXQgcmVmID0gY29udGV4dDtcbiAgICAgICAgICAgIGxldCByZXN0ID0gJyc7XG4gICAgICAgICAgICBsZXQgb2JqSWRzVG9SZWZlcmVuY2UgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGFsbFJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGxldCByZWZlcmVuY2VJc09rID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBNYXRjaCBpZCwgZXhhbXBsZTogXCIjb2JqZWN0SWQuc3RhcnRcIlxuICAgICAgICAgICAgY29uc3QgbSA9IC9eXFxXKiMoW14uXSspKC4qKS8uZXhlYyhleHByKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBtWzFdO1xuICAgICAgICAgICAgICAgIHJlc3QgPSBtWzJdO1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUlzT2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9iaklkc1RvUmVmZXJlbmNlID0gW2lkXTtcbiAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzLnB1c2goYCMke2lkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggY2xhc3MsIGV4YW1wbGU6IFwiLmNsYXNzTmFtZS5zdGFydFwiXG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IC9eXFxXKlxcLihbXi5dKykoLiopLy5leGVjKGV4cHIpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG1bMV07XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBtWzJdO1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb2JqSWRzVG9SZWZlcmVuY2UgPSB0aGlzLnJlc29sdmVkVGltZWxpbmUuZ2V0Q2xhc3NPYmplY3RzKGNsYXNzTmFtZSkgPz8gW107XG4gICAgICAgICAgICAgICAgICAgIGFsbFJlZmVyZW5jZXMucHVzaChgLiR7Y2xhc3NOYW1lfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggbGF5ZXIsIGV4YW1wbGU6IFwiJGxheWVyXCJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IC9eXFxXKlxcJChbXi5dKykoLiopLy5leGVjKGV4cHIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBtWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9IG1bMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VJc09rID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iaklkc1RvUmVmZXJlbmNlID0gdGhpcy5yZXNvbHZlZFRpbWVsaW5lLmdldExheWVyT2JqZWN0cyhsYXllcikgPz8gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxSZWZlcmVuY2VzLnB1c2goYCQke2xheWVyfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmpJZHNUb1JlZmVyZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZk9iaklkID0gb2JqSWRzVG9SZWZlcmVuY2VbaV07XG4gICAgICAgICAgICAgICAgaWYgKHJlZk9iaklkID09PSBvYmouaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9va3MgbGlrZSB0aGUgb2JqZWN0IGlzIHJlZmVyZW5jaW5nIGl0c2VsZiFcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5yZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZk9iaiA9IHRoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRPYmplY3QocmVmT2JqSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmT2JqKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlZE9ianMucHVzaChyZWZPYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVmZXJlbmNlSXNPaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNsdWRlIGFueSBzZWxmLXJlZmVyZW5jaW5nIG9iamVjdHM6XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlZE9ianMgPSByZWZlcmVuY2VkT2Jqcy5maWx0ZXIoKHJlZk9iaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXJlZk9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VkT2Jqcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoL3N0YXJ0Ly5leGVjKHJlc3QpKVxuICAgICAgICAgICAgICAgICAgICByZWYgPSAnc3RhcnQnO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9lbmQvLmV4ZWMocmVzdCkpXG4gICAgICAgICAgICAgICAgICAgIHJlZiA9ICdlbmQnO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKC9kdXJhdGlvbi8uZXhlYyhyZXN0KSlcbiAgICAgICAgICAgICAgICAgICAgcmVmID0gJ2R1cmF0aW9uJztcbiAgICAgICAgICAgICAgICBpZiAocmVmID09PSAnZHVyYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIER1cmF0aW9uIHJlZmVycyB0byB0aGUgZmlyc3Qgb2JqZWN0IG9uIHRoZSByZXNvbHZlZCB0aW1lbGluZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBSZWZlcmVuY2VkT2Jqc0R1cmF0aW9uKG9iaiwgcmVmZXJlbmNlZE9ianMsIGFsbFJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWYgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwUmVmZXJlbmNlZE9ianMob2JqLCByZWZlcmVuY2VkT2JqcywgYWxsUmVmZXJlbmNlcywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVmID09PSAnZW5kJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb29rdXBSZWZlcmVuY2VkT2JqcyhvYmosIHJlZmVyZW5jZWRPYmpzLCBhbGxSZWZlcmVuY2VzLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICgwLCBsaWJfMS5hc3NlcnROZXZlcikocmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IFtdLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWV4cHIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCwgYWxsUmVmZXJlbmNlczogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4cHIgaXMgYW4gZXhwcmVzc2lvbk9ialxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9va3VwRXhwcmVzc2lvbk9iaihvYmosIGNvbnRleHQsIGV4cHIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFwcGx5UGFyZW50SW5zdGFuY2VzKHBhcmVudEluc3RhbmNlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0ZU9uQXJyYXlzKHBhcmVudEluc3RhbmNlcywgdmFsdWUsIHRoaXMub3BlcmF0ZUFwcGx5UGFyZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFuIGFjdGlvbiBvbiAyIGFycmF5cy4gQmVoYXZlcyBzb21ld2hhdCBsaWtlIHRoZSBcIi4qXCItb3BlcmF0b3IgaW4gTWF0bGFiXG4gICAgICogQHBhcmFtIGFycmF5MFxuICAgICAqIEBwYXJhbSBhcnJheTFcbiAgICAgKiBAcGFyYW0gb3BlcmF0ZVxuICAgICAqL1xuICAgIG9wZXJhdGVPbkFycmF5cyhhcnJheTAsIGFycmF5MSwgb3BlcmF0ZSkge1xuICAgICAgICBpZiAoYXJyYXkwID09PSBudWxsIHx8IGFycmF5MSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoKDAsIHJlZmVyZW5jZV8xLmlzUmVmZXJlbmNlKShhcnJheTApICYmICgwLCByZWZlcmVuY2VfMS5pc1JlZmVyZW5jZSkoYXJyYXkxKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGUoYXJyYXkwLCBhcnJheTEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBtaW5MZW5ndGggPSBNYXRoLm1pbigoMCwgbGliXzEuaXNBcnJheSkoYXJyYXkwKSA/IGFycmF5MC5sZW5ndGggOiBJbmZpbml0eSwgKDAsIGxpYl8xLmlzQXJyYXkpKGFycmF5MSkgPyBhcnJheTEubGVuZ3RoIDogSW5maW5pdHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gKDAsIGxpYl8xLmlzQXJyYXkpKGFycmF5MClcbiAgICAgICAgICAgICAgICA/IGFycmF5MFtpXVxuICAgICAgICAgICAgICAgIDogeyBpZDogJ0AnLCBzdGFydDogYXJyYXkwLnZhbHVlLCBlbmQ6IGFycmF5MC52YWx1ZSwgcmVmZXJlbmNlczogYXJyYXkwLnJlZmVyZW5jZXMgfTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAoMCwgbGliXzEuaXNBcnJheSkoYXJyYXkxKVxuICAgICAgICAgICAgICAgID8gYXJyYXkxW2ldXG4gICAgICAgICAgICAgICAgOiB7IGlkOiAnQCcsIHN0YXJ0OiBhcnJheTEudmFsdWUsIGVuZDogYXJyYXkxLnZhbHVlLCByZWZlcmVuY2VzOiBhcnJheTEucmVmZXJlbmNlcyB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBhLmlzRmlyc3RcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IGEuc3RhcnQsIHJlZmVyZW5jZXM6IGEucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICAgICAgOiBiLmlzRmlyc3RcbiAgICAgICAgICAgICAgICAgICAgPyB7IHZhbHVlOiBiLnN0YXJ0LCByZWZlcmVuY2VzOiBiLnJlZmVyZW5jZXMgfVxuICAgICAgICAgICAgICAgICAgICA6IG9wZXJhdGUoeyB2YWx1ZTogYS5zdGFydCwgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShhLnJlZmVyZW5jZXMsIGEuaWQgPT09ICdAJyA/IFtdIDogYEAke2EuaWR9YCkgfSwgeyB2YWx1ZTogYi5zdGFydCwgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShiLnJlZmVyZW5jZXMsIGIuaWQgPT09ICdAJyA/IFtdIDogYEAke2IuaWR9YCkgfSk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBhLmlzRmlyc3RcbiAgICAgICAgICAgICAgICA/IGEuZW5kICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZTogYS5lbmQsIHJlZmVyZW5jZXM6IGEucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgICAgIDogYi5pc0ZpcnN0XG4gICAgICAgICAgICAgICAgICAgID8gYi5lbmQgIT09IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB2YWx1ZTogYi5lbmQsIHJlZmVyZW5jZXM6IGIucmVmZXJlbmNlcyB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiBvcGVyYXRlKGEuZW5kICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShhLnJlZmVyZW5jZXMsIGEuaWQgPT09ICdAJyA/IFtdIDogYEAke2EuaWR9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsIGIuZW5kICE9PSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYi5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShiLnJlZmVyZW5jZXMsIGIuaWQgPT09ICdAJyA/IFtdIDogYEAke2IuaWR9YCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5yZXNvbHZlZFRpbWVsaW5lLmdldEluc3RhbmNlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGVuZCA9PT0gbnVsbCA/IG51bGwgOiBlbmQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoc3RhcnQucmVmZXJlbmNlcywgZW5kICE9PSBudWxsID8gZW5kLnJlZmVyZW5jZXMgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIGNhcHM6ICgwLCBjYXBfMS5qb2luQ2FwcykoYS5jYXBzLCBiLmNhcHMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmNsZWFuSW5zdGFuY2VzKHJlc3VsdCwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rIHVwIHRoZSByZWZlcmVuY2VkIG9iamVjdHMgKGluIHRoZSBjb250ZXh0IG9mIGEgZHVyYXRpb24tcmVmZXJlbmNlKVxuICAgICAqL1xuICAgIGxvb2t1cFJlZmVyZW5jZWRPYmpzRHVyYXRpb24ob2JqLCByZWZlcmVuY2VkT2JqcywgYWxsUmVmZXJlbmNlcykge1xuICAgICAgICBjb25zdCBpbnN0YW5jZUR1cmF0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZWRPYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VkT2JqID0gcmVmZXJlbmNlZE9ianNbaV07XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcmVmZXJlbmNlZCBvYmplY3QgaXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIHdoZXJlIHJlZmVyZW5jZWQgb2JqZWN0KHMpIGFyZSByZWN1cnNpdmVseSByZXNvbHZlZFxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFRpbWVsaW5lLnJlc29sdmVUaW1lbGluZU9iaihyZWZlcmVuY2VkT2JqKTtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLnJlc29sdmVkUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcgJiYgcmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcXVlcnlpbmcgb2JqZWN0IGlzIHNlbGYtcmVmZXJlbmNpbmcsIGV4Y2x1ZGUgYW55IG90aGVyIHNlbGYtcmVmZXJlbmNpbmcgb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0SW5zdGFuY2UgPSByZWZlcmVuY2VkT2JqLnJlc29sdmVkLmluc3RhbmNlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gZmlyc3RJbnN0YW5jZS5lbmQgIT09IG51bGwgPyBmaXJzdEluc3RhbmNlLmVuZCAtIGZpcnN0SW5zdGFuY2Uuc3RhcnQgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VEdXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShbYCMke3JlZmVyZW5jZWRPYmouaWR9YF0sIGZpcnN0SW5zdGFuY2UucmVmZXJlbmNlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpcnN0RHVyYXRpb24gPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc3RhbmNlRHVyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gaW5zdGFuY2VEdXJhdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAoZmlyc3REdXJhdGlvbiA9PT0gbnVsbCB8fCBkLnZhbHVlIDwgZmlyc3REdXJhdGlvbi52YWx1ZSlcbiAgICAgICAgICAgICAgICBmaXJzdER1cmF0aW9uID0gZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZpcnN0RHVyYXRpb24sIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9vayB1cCB0aGUgcmVmZXJlbmNlZCBvYmplY3RzXG4gICAgICovXG4gICAgbG9va3VwUmVmZXJlbmNlZE9ianMob2JqLCByZWZlcmVuY2VkT2JqcywgYWxsUmVmZXJlbmNlcywgaW52ZXJ0LCBpZ25vcmVGaXJzdElmWmVybykge1xuICAgICAgICBsZXQgcmVmZXJlbmNlZEluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlZmVyZW5jZWRPYmpzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZWZlcmVuY2VkT2JqID0gcmVmZXJlbmNlZE9ianNbaV07XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcmVmZXJlbmNlZCBvYmplY3QgaXMgcmVzb2x2ZWQuXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIHdoZXJlIHJlZmVyZW5jZWQgb2JqZWN0KHMpIGFyZSByZWN1cnNpdmVseSByZXNvbHZlZFxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFRpbWVsaW5lLnJlc29sdmVUaW1lbGluZU9iaihyZWZlcmVuY2VkT2JqKTtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLnJlc29sdmVkUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNTZWxmUmVmZXJlbmNpbmcgJiYgcmVmZXJlbmNlZE9iai5yZXNvbHZlZC5pc1NlbGZSZWZlcmVuY2luZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcXVlcnlpbmcgb2JqZWN0IGlzIHNlbGYtcmVmZXJlbmNpbmcsIGV4Y2x1ZGUgYW55IG90aGVyIHNlbGYtcmVmZXJlbmNpbmcgb2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRJbnN0YW5jZXMgPSByZWZlcmVuY2VkSW5zdGFuY2VzLmNvbmNhdChyZWZlcmVuY2VkT2JqLnJlc29sdmVkLmluc3RhbmNlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZlcmVuY2VkSW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGludmVydCkge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRJbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlLmludmVydEluc3RhbmNlcyhyZWZlcmVuY2VkSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZmVyZW5jZWRJbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlLmNsZWFuSW5zdGFuY2VzKHJlZmVyZW5jZWRJbnN0YW5jZXMsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlnbm9yZUZpcnN0SWZaZXJvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSByZWZlcmVuY2VkSW5zdGFuY2VzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiBmaXJzdC5zdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VkSW5zdGFuY2VzLnNwbGljZSgwLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHJlZmVyZW5jZWRJbnN0YW5jZXMsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogW10sIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29rIHVwIGFuIEV4cHJlc3Npb25PYmpcbiAgICAgKi9cbiAgICBsb29rdXBFeHByZXNzaW9uT2JqKG9iaiwgY29udGV4dCwgZXhwcikge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5sb29rdXBFeHByZXNzaW9uKG9iaiwgZXhwci5sLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgciA9IHRoaXMubG9va3VwRXhwcmVzc2lvbihvYmosIGV4cHIuciwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGxvb2t1cEV4cHIgPSB7XG4gICAgICAgICAgICBsOiBsLnJlc3VsdCxcbiAgICAgICAgICAgIG86IGV4cHIubyxcbiAgICAgICAgICAgIHI6IHIucmVzdWx0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhbGxSZWZlcmVuY2VzID0gbC5hbGxSZWZlcmVuY2VzLmNvbmNhdChyLmFsbFJlZmVyZW5jZXMpO1xuICAgICAgICBpZiAobG9va3VwRXhwci5vID09PSAnIScpIHtcbiAgICAgICAgICAgIC8vIEludmVydCwgaWUgZGlzY2FyZCBsLCBpbnZlcnQgYW5kIHJldHVybiByOlxuICAgICAgICAgICAgaWYgKGxvb2t1cEV4cHIuciAmJiAoMCwgbGliXzEuaXNBcnJheSkobG9va3VwRXhwci5yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdGhpcy5pbnN0YW5jZS5pbnZlcnRJbnN0YW5jZXMobG9va3VwRXhwci5yKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgaW52ZXJ0IGEgdmFsdWVcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGxvb2t1cEV4cHIucixcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvb2t1cEV4cHIubCA9PT0gbnVsbCB8fCBsb29rdXBFeHByLnIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogbnVsbCwgYWxsUmVmZXJlbmNlczogYWxsUmVmZXJlbmNlcyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxvb2t1cEV4cHIubyA9PT0gJyYnIHx8IGxvb2t1cEV4cHIubyA9PT0gJ3wnKSB7XG4gICAgICAgICAgICBjb25zdCBjb21iaW5lciA9IG5ldyBSZWZlcmVuY2VBbmRPckNvbWJpbmVyKHRoaXMucmVzb2x2ZWRUaW1lbGluZSwgbG9va3VwRXhwci5sLCBsb29rdXBFeHByLnIsIGxvb2t1cEV4cHIubyk7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZXMgPSBjb21iaW5lci5jYWxjdWxhdGVSZXN1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogaW5zdGFuY2VzLCBhbGxSZWZlcmVuY2VzOiBhbGxSZWZlcmVuY2VzIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRlID0gT3BlcmF0b3JzLmdldChsb29rdXBFeHByLm8pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vcGVyYXRlT25BcnJheXMobG9va3VwRXhwci5sLCBsb29rdXBFeHByLnIsIG9wZXJhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiByZXN1bHQsIGFsbFJlZmVyZW5jZXM6IGFsbFJlZmVyZW5jZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUmVmZXJlbmNlSGFuZGxlciA9IFJlZmVyZW5jZUhhbmRsZXI7XG4vKiogSGVscGVyIGNsYXNzIHRoYXQgZGVhbHMgd2l0aCBhbiBBbmQgKCcmJykgb3IgYW4gT3IgKCd8JykgZXhwcmVzc2lvbiAqL1xuY2xhc3MgUmVmZXJlbmNlQW5kT3JDb21iaW5lciB7XG4gICAgY29uc3RydWN0b3IocmVzb2x2ZWRUaW1lbGluZSwgbGVmdE9wZXJhbmQsIHJpZ2h0T3BlcmFuZCwgb3BlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFRpbWVsaW5lID0gcmVzb2x2ZWRUaW1lbGluZTtcbiAgICAgICAgdGhpcy5sZWZ0T3BlcmFuZCA9IGxlZnRPcGVyYW5kO1xuICAgICAgICB0aGlzLnJpZ2h0T3BlcmFuZCA9IHJpZ2h0T3BlcmFuZDtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wZXJhdG9yID09PSAnJicpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY1Jlc3VsdCA9IChsZWZ0LCByaWdodCkgPT4gISEobGVmdCAmJiByaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3BlcmF0b3IgPT09ICd8Jykge1xuICAgICAgICAgICAgdGhpcy5jYWxjUmVzdWx0ID0gKGxlZnQsIHJpZ2h0KSA9PiAhIShsZWZ0IHx8IHJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAoMCwgbGliXzEuYXNzZXJ0TmV2ZXIpKG9wZXJhdG9yKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aGlzLmNhbGNSZXN1bHQgPSAoKSA9PiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGxpYl8xLmlzQXJyYXkpKGxlZnRPcGVyYW5kKSlcbiAgICAgICAgICAgIHRoaXMuX2FkZEluc3RhbmNlRXZlbnRzKGxlZnRPcGVyYW5kLCB0cnVlKTtcbiAgICAgICAgaWYgKCgwLCBsaWJfMS5pc0FycmF5KShyaWdodE9wZXJhbmQpKVxuICAgICAgICAgICAgdGhpcy5fYWRkSW5zdGFuY2VFdmVudHMocmlnaHRPcGVyYW5kLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gKDAsIGV2ZW50XzEuc29ydEV2ZW50cykodGhpcy5ldmVudHMpO1xuICAgIH1cbiAgICBfYWRkSW5zdGFuY2VFdmVudHMoaW5zdGFuY2VzLCBsZWZ0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGFydCAhPT0gaW5zdGFuY2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gZXZlbnQgZG9lc24ndCBhY3R1YWxseSBleGlzdC4uLlxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY3VsYXRlUmVzdWx0KCkge1xuICAgICAgICBsZXQgbGVmdFZhbHVlID0gKDAsIHJlZmVyZW5jZV8xLmlzUmVmZXJlbmNlKSh0aGlzLmxlZnRPcGVyYW5kKSA/ICEhdGhpcy5sZWZ0T3BlcmFuZC52YWx1ZSA6IGZhbHNlO1xuICAgICAgICBsZXQgcmlnaHRWYWx1ZSA9ICgwLCByZWZlcmVuY2VfMS5pc1JlZmVyZW5jZSkodGhpcy5yaWdodE9wZXJhbmQpID8gISF0aGlzLnJpZ2h0T3BlcmFuZC52YWx1ZSA6IGZhbHNlO1xuICAgICAgICBsZXQgbGVmdEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgbGV0IHJpZ2h0SW5zdGFuY2UgPSBudWxsO1xuICAgICAgICBsZXQgcmVzdWx0VmFsdWUgPSB0aGlzLmNhbGNSZXN1bHQobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICAgICAgdGhpcy51cGRhdGVJbnN0YW5jZSgwLCByZXN1bHRWYWx1ZSwgKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKSgoMCwgcmVmZXJlbmNlXzEuaXNSZWZlcmVuY2UpKHRoaXMubGVmdE9wZXJhbmQpID8gdGhpcy5sZWZ0T3BlcmFuZC5yZWZlcmVuY2VzIDogW10sICgwLCByZWZlcmVuY2VfMS5pc1JlZmVyZW5jZSkodGhpcy5yaWdodE9wZXJhbmQpID8gdGhpcy5yaWdodE9wZXJhbmQucmVmZXJlbmNlcyA6IFtdKSwgW10pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5ldmVudHNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGUubGVmdCkge1xuICAgICAgICAgICAgICAgIGxlZnRWYWx1ZSA9IGUudmFsdWU7XG4gICAgICAgICAgICAgICAgbGVmdEluc3RhbmNlID0gZS5pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHJpZ2h0SW5zdGFuY2UgPSBlLmluc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQudGltZSAhPT0gZS50aW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UmVzdWx0VmFsdWUgPSB0aGlzLmNhbGNSZXN1bHQobGVmdFZhbHVlLCByaWdodFZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRDYXBzID0gKGxlZnRJbnN0YW5jZSA/IGxlZnRJbnN0YW5jZS5jYXBzID8/IFtdIDogW10pLmNvbmNhdChyaWdodEluc3RhbmNlID8gcmlnaHRJbnN0YW5jZS5jYXBzID8/IFtdIDogW10pO1xuICAgICAgICAgICAgICAgIGlmIChuZXdSZXN1bHRWYWx1ZSAhPT0gcmVzdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbnN0YW5jZShlLnRpbWUsIG5ld1Jlc3VsdFZhbHVlLCAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGxlZnRJbnN0YW5jZSA/IGxlZnRJbnN0YW5jZS5yZWZlcmVuY2VzIDogW10sIHJpZ2h0SW5zdGFuY2UgPyByaWdodEluc3RhbmNlLnJlZmVyZW5jZXMgOiBbXSksIHJlc3VsdENhcHMpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZSA9IG5ld1Jlc3VsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZXM7XG4gICAgfVxuICAgIHVwZGF0ZUluc3RhbmNlKHRpbWUsIHZhbHVlLCByZWZlcmVuY2VzLCBjYXBzKSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRJbnN0YW5jZUlkKCksXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRpbWUsXG4gICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgY2FwczogY2FwcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGFzdEluc3RhbmNlID0gKDAsIGxpYl8xLmxhc3QpKHRoaXMuaW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGlmIChsYXN0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBsYXN0SW5zdGFuY2UuZW5kID0gdGltZTtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCB1cGRhdGUgcmVmZXJlbmNlIG9uIGVuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqIEhlbHBlciBjbGFzcyBmb3IgdmFyaW91cyBvcGVyYXRvcnMgKi9cbmNsYXNzIE9wZXJhdG9ycyB7XG4gICAgc3RhdGljIGdldChvcGVyYXRvcikge1xuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLkFkZDtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBPcGVyYXRvcnMuU3VidHJhY3Q7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLk11bHRpcGx5O1xuICAgICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9wZXJhdG9ycy5EaXZpZGU7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLk1vZHVsbztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAoMCwgbGliXzEuYXNzZXJ0TmV2ZXIpKG9wZXJhdG9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gT3BlcmF0b3JzLk51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5PcGVyYXRvcnMuQWRkID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogYS52YWx1ZSArIGIudmFsdWUsXG4gICAgICAgIHJlZmVyZW5jZXM6ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgIH07XG59O1xuT3BlcmF0b3JzLlN1YnRyYWN0ID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogYS52YWx1ZSAtIGIudmFsdWUsXG4gICAgICAgIHJlZmVyZW5jZXM6ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgIH07XG59O1xuT3BlcmF0b3JzLk11bHRpcGx5ID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogYS52YWx1ZSAqIGIudmFsdWUsXG4gICAgICAgIHJlZmVyZW5jZXM6ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoYS5yZWZlcmVuY2VzLCBiLnJlZmVyZW5jZXMpLFxuICAgIH07XG59O1xuT3BlcmF0b3JzLkRpdmlkZSA9IChhLCBiKSA9PiB7XG4gICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGEudmFsdWUgLyBiLnZhbHVlLFxuICAgICAgICByZWZlcmVuY2VzOiAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGEucmVmZXJlbmNlcywgYi5yZWZlcmVuY2VzKSxcbiAgICB9O1xufTtcbk9wZXJhdG9ycy5Nb2R1bG8gPSAoYSwgYikgPT4ge1xuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBhLnZhbHVlICUgYi52YWx1ZSxcbiAgICAgICAgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShhLnJlZmVyZW5jZXMsIGIucmVmZXJlbmNlcyksXG4gICAgfTtcbn07XG5PcGVyYXRvcnMuTnVsbCA9ICgpID0+IHtcbiAgICByZXR1cm4gbnVsbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWZlcmVuY2VIYW5kbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvbHZlZFRpbWVsaW5lSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IEV4cHJlc3Npb25IYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9FeHByZXNzaW9uSGFuZGxlclwiKTtcbmNvbnN0IFJlZmVyZW5jZUhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL1JlZmVyZW5jZUhhbmRsZXJcIik7XG5jb25zdCBsaWJfMSA9IHJlcXVpcmUoXCIuL2xpYi9saWJcIik7XG5jb25zdCBJbnN0YW5jZUhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlSGFuZGxlclwiKTtcbmNvbnN0IHJlZmVyZW5jZV8xID0gcmVxdWlyZShcIi4vbGliL3JlZmVyZW5jZVwiKTtcbmNvbnN0IGV2ZW50XzEgPSByZXF1aXJlKFwiLi9saWIvZXZlbnRcIik7XG5jb25zdCBpbnN0YW5jZV8xID0gcmVxdWlyZShcIi4vbGliL2luc3RhbmNlXCIpO1xuY29uc3QgdGltZWxpbmVfMSA9IHJlcXVpcmUoXCIuL2xpYi90aW1lbGluZVwiKTtcbmNvbnN0IExheWVyU3RhdGVIYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9MYXllclN0YXRlSGFuZGxlclwiKTtcbmNvbnN0IGV4cHJlc3Npb25fMSA9IHJlcXVpcmUoXCIuL2xpYi9leHByZXNzaW9uXCIpO1xuY29uc3QgcGVyZm9ybWFuY2VfMSA9IHJlcXVpcmUoXCIuL2xpYi9wZXJmb3JtYW5jZVwiKTtcbmNvbnN0IENhY2hlSGFuZGxlcl8xID0gcmVxdWlyZShcIi4vQ2FjaGVIYW5kbGVyXCIpO1xuLyoqXG4gKiBBIFJlc29sdmVkVGltZWxpbmVIYW5kbGVyIGluc3RhbmNlIGlzIHNob3J0LWxpdmVkIGFuZCB1c2VkIHRvIHJlc29sdmUgYSB0aW1lbGluZS5cbiAqIEludGVuZGVkIHVzYWdlOlxuICogMS4gY29uc3QgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZWRUaW1lbGluZUhhbmRsZXIob3B0aW9ucylcbiAqIDIuIHRpbWVsaW5lT2JqZWN0cy5mb3JFYWNoKG9iaiA9PiByZXNvbHZlci5hZGRUaW1lbGluZU9iamVjdChvYmopKVxuICogMy4gcmVzb2x2ZXIucmVzb2x2ZUFsbFRpbWVsaW5lT2JqcygpXG4gKi9cbmNsYXNzIFJlc29sdmVkVGltZWxpbmVIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8qKiBNYXBzIG9iamVjdCBpZCB0byBvYmplY3QgKi9cbiAgICAgICAgdGhpcy5vYmplY3RzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogTWFwcyBjbGFzc05hbWUgdG8gYSBsaXN0IG9mIG9iamVjdCBpZHMgICovXG4gICAgICAgIHRoaXMuY2xhc3Nlc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIE1hcHMgbGF5ZXIgdG8gYSBsaXN0IG9mIG9iamVjdCBpZHMgICovXG4gICAgICAgIHRoaXMubGF5ZXJzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBhbiBhcnJheSBvZiBvYmplY3QgaWRzIHRvIGFuIG9iamVjdCBpZCAob2JqZWN0cyB0aGF0IGRpcmVjdGx5IHJlZmVyZW5jZSBhbiByZWZlcmVuY2UpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJlY3RSZWZlcmVuY2VNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBIb3cgbWFueSBvYmplY3RzIHRoYXQgd2FzIGFjdHVhbGx5IHJlc29sdmVkIChpcyBhZmZlY3RlZCB3aGVuIHVzaW5nIGNhY2hlKSAqL1xuICAgICAgICB0aGlzLnN0YXRpc3RpY1Jlc29sdmluZ09iamVjdENvdW50ID0gMDtcbiAgICAgICAgLyoqIEhvdyBtYW55IHRpbWVzIGFuIG9iamVjdCB3aGVyZSByZXNvbHZlZC4gKGlzIGFmZmVjdGVkIHdoZW4gdXNpbmcgY2FjaGUpICovXG4gICAgICAgIHRoaXMuc3RhdGlzdGljUmVzb2x2aW5nQ291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBNYXAgb2Ygc3RyaW5ncyAoaW5zdGFuY2UgaGFzaGVzKSB0aGF0IGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGFuIG9iamVjdHMgaW5zdGFuY2VzIGhhdmUgY2hhbmdlZC5cbiAgICAgICAgICogTWFwcyBvYmplY3RJZCAtPiBpbnN0YW5jZXNIYXNoXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdmVkT2JqSW5zdGFuY2VzSGFzaCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgZXhwbGFuYXRpb25zIGZvdyB3aHkgYW4gb2JqZWN0IGNoYW5nZWQgZHVyaW5nIGEgcmVzb2x2ZSBpdGVyYXRpb24uXG4gICAgICAgICAqIFVzZWQgZm9yIGRlYnVnZ2luZyBhbmQgRXJyb3JzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZWRPYmpJZHNFeHBsYW5hdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgTWFwIHRoYXQgY29udGFpbnMgdGhlIG9iamVjdHMgdGhhdCBuZWVkcyB0byByZXNvbHZlIGFnYWluLlxuICAgICAgICAgKiBPYmplY3QgYXJlIGFkZGVkIGludG8gdGhpcyBhZnRlciB0aGlzLnJlc29sdmVDb25mbGljdHNGb3JMYXllcigpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9iamVjdHNUb1JlUmVzb2x2ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIENvdW50ZXIgdGhhdCBpbmNyZWFzZXMgZHVyaW5nIHJlc29sdmluZywgZm9yIGV2ZXJ5IG9iamVjdCB0aGF0IG1pZ2h0IG5lZWQgcmUtcmVzb2x2aW5nKi9cbiAgICAgICAgdGhpcy5vYmplY3RSZXNvbHZlQ291bnQgPSAwO1xuICAgICAgICAvKiogRXJyb3IgbWVzc2FnZSwgaXMgc2V0IHdoZW4gYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgYW5kIHRoaXMub3B0aW9ucy5kb250VGhyb3dPbkVycm9yIGlzIHNldCAqL1xuICAgICAgICB0aGlzLl9yZXNvbHZlRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2lkQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBuZXcgRXhwcmVzc2lvbkhhbmRsZXJfMS5FeHByZXNzaW9uSGFuZGxlcihmYWxzZSwgdGhpcy5vcHRpb25zLnNraXBWYWxpZGF0aW9uKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBJbnN0YW5jZUhhbmRsZXJfMS5JbnN0YW5jZUhhbmRsZXIodGhpcyk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlID0gbmV3IFJlZmVyZW5jZUhhbmRsZXJfMS5SZWZlcmVuY2VIYW5kbGVyKHRoaXMsIHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmRlYnVnID0gdGhpcy5vcHRpb25zLmRlYnVnID8/IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgcmVzb2x2ZUVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVycm9yO1xuICAgIH1cbiAgICAvKiogUG9wdWxhdGUgUmVzb2x2ZWRUaW1lbGluZUhhbmRsZXIgd2l0aCBhIHRpbWVsaW5lLW9iamVjdC4gKi9cbiAgICBhZGRUaW1lbGluZU9iamVjdChvYmopIHtcbiAgICAgICAgdGhpcy5fYWRkVGltZWxpbmVPYmplY3Qob2JqLCAwLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqIFJlc29sdmUgdGhlIHRpbWVsaW5lLiAqL1xuICAgIHJlc29sdmVBbGxUaW1lbGluZU9ianMoKSB7XG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgcmVzb2x2ZUFsbFRpbWVsaW5lT2JqcycpO1xuICAgICAgICB0aGlzLmRlYnVnVHJhY2UoJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IHJlc29sdmVBbGxUaW1lbGluZU9ianMnKTtcbiAgICAgICAgLy8gU3RlcCAwOiBQcmVwYXJhdGlvbnM6XG4gICAgICAgIC8qKiBOdW1iZXIgb2Ygb2JqZWN0cyBpbiB0aW1lbGluZSAqL1xuICAgICAgICBjb25zdCBvYmplY3RDb3VudCA9IHRoaXMub2JqZWN0c01hcC5zaXplO1xuICAgICAgICAvKiogTWF4IGFsbG93ZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgb3ZlciBvYmplY3RzICovXG4gICAgICAgIGNvbnN0IG9iamVjdFJlc29sdmVDb3VudE1heCA9IG9iamVjdENvdW50ICogKHRoaXMub3B0aW9ucy5jb25mbGljdE1heERlcHRoID8/IDUpO1xuICAgICAgICAvKlxuICAgICAgICAgICAgVGhlIHJlc29sdmluZyBhbGdvcml0aG0gYmFzaWNhbGx5IHdvcmtzIGxpa2UgdGhpczpcblxuICAgICAgICAgICAgMWE6IFJlc29sdmUgYWxsIG9iamVjdHNcbiAgICAgICAgICAgIDFiOiBSZXNvbHZlIGNvbmZsaWN0cyBmb3IgYWxsIGxheWVyc1xuICAgICAgICAgICAgICAgIEFsc28gZGV0ZXJtaW5lIHdoaWNoIG9iamVjdHMgZGVwZW5kIG9uIGNoYW5nZWQgb2JqZWN0cyBkdWUgdG8gY29uZmxpY3RzXG5cbiAgICAgICAgICAgIDI6IExvb3AsIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIGNoYW5nZWQgb2JqZWN0czpcbiAgICAgICAgICAgICAgICAyYTogUmVzb2x2ZSBvYmplY3RzIHRoYXQgZGVwZW5kIG9uIGNoYW5nZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgIDJiOiBSZXNvbHZlIGNvbmZsaWN0cyBmb3IgYWZmZWN0ZWQgbGF5ZXJzIGluIDJhXG4gICAgICAgICAgICAgICAgICAgIEFsc28gZGV0ZXJtaW5lIHdoaWNoIG9iamVjdHMgZGVwZW5kIG9uIGNoYW5nZWQgb2JqZWN0cyBkdWUgdG8gY29uZmxpY3RzXG4gICAgICAgICovXG4gICAgICAgIC8vIFN0ZXAgMWE6IFJlc29sdmUgYWxsIG9iamVjdHM6XG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIHRoaXMub2JqZWN0c01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlVGltZWxpbmVPYmoob2JqKTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIHRoaXMucmVzb2x2ZWRPYmpJbnN0YW5jZXNIYXNoIG5vdywgc28gdGhhdCBvbmx5IGNoYW5nZXMgdG8gdGhlIHRpbWVsaW5lIGluc3RhbmNlc1xuICAgICAgICAgICAgLy8gaW4gdGhpcy5yZXNvbHZlQ29uZmxpY3RzRm9yT2JqcygpIHdpbGwgYmUgZGV0ZWN0ZWQgbGF0ZXI6XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkT2JqSW5zdGFuY2VzSGFzaC5zZXQob2JqLmlkLCAoMCwgaW5zdGFuY2VfMS5nZXRJbnN0YW5jZXNIYXNoKShvYmoucmVzb2x2ZWQuaW5zdGFuY2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVFcnJvcilcbiAgICAgICAgICAgIHJldHVybjsgLy8gQWJvcnQgb24gZXJyb3JcbiAgICAgICAgLy8gU3RlcCAxYjogUmVzb2x2ZSBjb25mbGljdHMgZm9yIGFsbCBvYmplY3RzOlxuICAgICAgICB0aGlzLnJlc29sdmVDb25mbGljdHNGb3JPYmpzKG51bGwpO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x2ZUVycm9yKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBBYm9ydCBvbiBlcnJvclxuICAgICAgICAvLyBTdGVwIDI6IHJlLXJlc29sdmUgYWxsIGNoYW5nZWQgb2JqZWN0cywgdW50aWwgbm8gbW9yZSBjaGFuZ2VzIGFyZSBkZXRlY3RlZDpcbiAgICAgICAgd2hpbGUgKHRoaXMub2JqZWN0c1RvUmVSZXNvbHZlLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmplY3RSZXNvbHZlQ291bnQgPj0gb2JqZWN0UmVzb2x2ZUNvdW50TWF4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYE1heGltdW0gY29uZmxpY3QgaXRlcmF0aW9uIHJlYWNoZWQgKCR7dGhpcy5vYmplY3RSZXNvbHZlQ291bnR9KS4gVGhpcyBpcyBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5IGluIHRoZSB0aW1lbGluZS4gTGF0ZXN0IGNoYW5nZXM6XFxuJHt0aGlzLmNoYW5nZWRPYmpJZHNFeHBsYW5hdGlvbnMuam9pbignTmV4dCBpdGVyYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicpfWApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9udFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNvbHZlRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdUcmFjZShgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z1RyYWNlKGBvYmplY3RzVG9SZVJlc29sdmU6IFske0FycmF5LmZyb20odGhpcy5vYmplY3RzVG9SZVJlc29sdmUuZW50cmllcygpKX1dYCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z1RyYWNlKGBkaXJlY3RSZWZlcmVuY2VzOiBbJHtBcnJheS5mcm9tKHRoaXMuZGlyZWN0UmVmZXJlbmNlTWFwLmVudHJpZXMoKSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06IFske3ZhbHVlfV1gKX1dYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2xsZWN0IGFuZCByZXNldCBhbGwgb2JqZWN0cyB0aGF0IGRlcGVuZCBvbiBwcmV2aW91c2x5IGNoYW5nZWQgb2JqZWN0c1xuICAgICAgICAgICAgY29uc3QgY29uZmxpY3RPYmplY3RzVG9SZXNvbHZlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiB0aGlzLm9iamVjdHNUb1JlUmVzb2x2ZS52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub2JqZWN0UmVzb2x2ZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgLy8gRm9yY2UgYSBuZXcgcmVzb2x2ZSwgc2luY2UgdGhlIHJlZmVyZW5jZWQgb2JqZWN0cyBtaWdodCBoYXZlIGNoYW5nZWQgKGR1ZSB0byBjb25mbGljdHMpOlxuICAgICAgICAgICAgICAgIGxldCBuZWVkc0NvbmZsaWN0UmVzb2x2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICghb2JqLnJlc29sdmVkLnJlc29sdmVkUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVUaW1lbGluZU9iaihvYmopO1xuICAgICAgICAgICAgICAgICAgICBuZWVkc0NvbmZsaWN0UmVzb2x2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghb2JqLnJlc29sdmVkLnJlc29sdmVkQ29uZmxpY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5lZWRzQ29uZmxpY3RSZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRzQ29uZmxpY3RSZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0T2JqZWN0c1RvUmVzb2x2ZS5wdXNoKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEFib3J0IG9uIGVycm9yXG4gICAgICAgICAgICAvLyBSZXNvbHZlIGNvbmZsaWN0cyBmb3Igb2JqZWN0cyB0aGF0IGRlcGVuZCBvbiBwcmV2aW91c2x5IGNoYW5nZWQgb2JqZWN0czpcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbmZsaWN0c0Zvck9ianMoY29uZmxpY3RPYmplY3RzVG9SZXNvbHZlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSBhIHRpbWVsaW5lLW9iamVjdC5cbiAgICAgKiBUaGUgUmVzb2x2ZSBhbGdvcml0aG0gd29ya3MgbGlrZSB0aGlzOlxuICAgICAqIDEuIEdvIHRocm91Z2ggdGhlIC5lbmFibGUgZXhwcmVzc2lvbihzKSBhbmQgbG9vayB1cCBhbGwgcmVmZXJlbmNlZCBvYmplY3RzLlxuICAgICAqIFx0ICAxLjUgRm9yIGVhY2ggcmVmZXJlbmNlZCBvYmplY3QsIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQgZmlyc3QgaWYgbm90IGFscmVhZHkgcmVzb2x2ZWQuXG4gICAgICogMi4gQ29sbGVjdCB0aGUgcmVzb2x2ZWQgaW5zdGFuY2VzIGFuZCBjYWxjdWxhdGUgdGhlIHJlc3VsdGluZyBsaXN0IG9mIHJlc3VsdGluZyBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgcmVzb2x2ZVRpbWVsaW5lT2JqKG9iaikge1xuICAgICAgICBpZiAob2JqLnJlc29sdmVkLnJlc29sdmluZykge1xuICAgICAgICAgICAgLy8gQ2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBFcnJvcihgQ2lyY3VsYXIgZGVwZW5kZW5jeSB3aGVuIHRyeWluZyB0byByZXNvbHZlIFwiJHtvYmouaWR9XCJgKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZG9udFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIG9iai5yZXNvbHZlZC5maXJzdFJlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvYmoucmVzb2x2ZWQucmVzb2x2ZWRSZWZlcmVuY2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBvYmoucmVzb2x2ZWQucmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgb2JqLnJlc29sdmVkLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmoucmVzb2x2ZWQucmVzb2x2ZWRSZWZlcmVuY2VzKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IHJlc29sdmVkXG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgICAgcmVzb2x2ZVRpbWVsaW5lT2JqJyk7XG4gICAgICAgIG9iai5yZXNvbHZlZC5yZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRpc3RpY1Jlc29sdmluZ0NvdW50Kys7XG4gICAgICAgIGlmICghb2JqLnJlc29sdmVkLmZpcnN0UmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGlzdGljUmVzb2x2aW5nT2JqZWN0Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYnVnVHJhY2UoYD09PT09PT09PT09PSByZXNvbHZpbmcgXCIke29iai5pZH1cImApO1xuICAgICAgICBjb25zdCBkaXJlY3RSZWZlcmVuY2VzID0gW107XG4gICAgICAgIGxldCByZXN1bHRpbmdJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgaWYgKG9iai5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmVzdWx0aW5nSW5zdGFuY2VzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBMb29wIHVwIHJlZmVyZW5jZXMgdG8gdGhlIHBhcmVudDpcbiAgICAgICAgICAgIGxldCBwYXJlbnRJbnN0YW5jZXMgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGhhc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHBhcmVudFJlZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICBoYXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHBhcmVudFJlZiA9IGAjJHtvYmoucmVzb2x2ZWQucGFyZW50SWR9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRMb29rdXAgPSB0aGlzLnJlZmVyZW5jZS5sb29rdXBFeHByZXNzaW9uKG9iaiwgdGhpcy5leHByZXNzaW9uLmludGVycHJldEV4cHJlc3Npb24ocGFyZW50UmVmKSwgJ3N0YXJ0Jyk7XG4gICAgICAgICAgICAgICAgLy8gcHVzaFRvQXJyYXkoZGlyZWN0UmVmZXJlbmNlcywgcGFyZW50TG9va3VwLmFsbFJlZmVyZW5jZXMpXG4gICAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2VzID0gcGFyZW50TG9va3VwLnJlc3VsdDsgLy8gYSBzdGFydC1yZWZlcmVuY2Ugd2lsbCBhbHdheXMgcmV0dXJuIGFuIGFycmF5LCBvciBudWxsXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEluc3RhbmNlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgcGFyZW50SW5zdGFuY2VzIHJlZmVyZW5jZXMgdGhlIHBhcmVudDpcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXJlbnRJbnN0YW5jZSBvZiBwYXJlbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEluc3RhbmNlLnJlZmVyZW5jZXMgPSAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKHBhcmVudEluc3RhbmNlLnJlZmVyZW5jZXMsIHBhcmVudFJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmFibGVzID0gKDAsIGxpYl8xLmVuc3VyZUFycmF5KShvYmouZW5hYmxlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5hYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuYWJsZSA9IGVuYWJsZXNbaV07XG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGhlIGVuYWJsZS5yZXBlYXRpbmcgZXhwcmVzc2lvbjpcbiAgICAgICAgICAgICAgICBjb25zdCBsb29rdXBSZXBlYXRpbmcgPSBlbmFibGUucmVwZWF0aW5nICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxvb2t1cEV4cHJlc3Npb24ob2JqLCBkaXJlY3RSZWZlcmVuY2VzLCBlbmFibGUucmVwZWF0aW5nLCAnZHVyYXRpb24nKVxuICAgICAgICAgICAgICAgICAgICA6IHsgcmVzdWx0OiBudWxsIH07XG4gICAgICAgICAgICAgICAgbGV0IGxvb2tlZHVwUmVwZWF0aW5nO1xuICAgICAgICAgICAgICAgIGlmIChsb29rdXBSZXBlYXRpbmcucmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgbG9va2VkdXBSZXBlYXRpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgbGliXzEuaXNBcnJheSkobG9va3VwUmVwZWF0aW5nLnJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2t1cFJlcGVhdGluZy5yZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rZWR1cFJlcGVhdGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobG9va3VwUmVwZWF0aW5nLnJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2tlZHVwUmVwZWF0aW5nID0gKDAsIGxpYl8xLmxpdGVyYWwpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbG9va3VwUmVwZWF0aW5nLnJlc3VsdFswXS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rdXBSZXBlYXRpbmcucmVzdWx0WzBdLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsb29rdXAgZm9yIHJlcGVhdGluZyByZXR1cm5lZCBtdWx0aXBsZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQsIHBlcmhhcHMgdGhpcyBjb3VsZCBiZSBzdXBwb3J0ZWQgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvb2t1cEV4cHJlc3Npb24gc2hvdWxkIG5ldmVyIHJldHVybiBhbiBhcnJheSBmb3IgLmR1cmF0aW9uIGxvb2t1cGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb29rZWR1cFJlcGVhdGluZyA9IGxvb2t1cFJlcGVhdGluZy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qKiBBcnJheSBvZiBpbnN0YW5jZXMgdGhpcyBlbmFibGUtZXhwcmVzc2lvbiByZXN1bHRlZCBpbiAqL1xuICAgICAgICAgICAgICAgIGxldCBlbmFibGVJbnN0YW5jZXM7XG4gICAgICAgICAgICAgICAgaWYgKGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdoaWxlRXhwciA9IFxuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIFwiMVwiLCAxOlxuICAgICAgICAgICAgICAgICAgICBlbmFibGUud2hpbGUgPT09ICcxJyB8fCBlbmFibGUud2hpbGUgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RydWUnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IC8vIEhhbmRsZSBzcGVjaWFsIGNhc2UgXCIwXCIsIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlLndoaWxlID09PSAnMCcgfHwgZW5hYmxlLndoaWxlID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ2ZhbHNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGVuYWJsZS53aGlsZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogYSBsb29rdXAgZm9yICd3aGlsZScgd29ya3MgdGhlIHNhbWUgYXMgZm9yICdzdGFydCdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9va3VwV2hpbGUgPSB0aGlzLmxvb2t1cEV4cHJlc3Npb24ob2JqLCBkaXJlY3RSZWZlcmVuY2VzLCB3aGlsZUV4cHIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9va3VwV2hpbGUucmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgbGliXzEuaXNBcnJheSkobG9va3VwV2hpbGUucmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlSW5zdGFuY2VzID0gbG9va3VwV2hpbGUucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cFdoaWxlLnJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlSW5zdGFuY2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SW5zdGFuY2VJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbG9va3VwV2hpbGUucmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2t1cFdoaWxlLnJlc3VsdC5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZW5hYmxlLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9va3VwU3RhcnQgPSB0aGlzLmxvb2t1cEV4cHJlc3Npb24ob2JqLCBkaXJlY3RSZWZlcmVuY2VzLCBlbmFibGUuc3RhcnQsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rZWR1cFN0YXJ0cyA9IGxvb2t1cFN0YXJ0LnJlZmVyc1RvUGFyZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucmVmZXJlbmNlLmFwcGx5UGFyZW50SW5zdGFuY2VzKHBhcmVudEluc3RhbmNlcywgbG9va3VwU3RhcnQucmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBTdGFydC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBlbmRFdmVudHM6IEV2ZW50Rm9ySW5zdGFuY2VbXSA9IFtdXG4gICAgICAgICAgICAgICAgICAgIGxldCBpU3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaUVuZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWR1cFN0YXJ0cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBsaWJfMS5pc0FycmF5KShsb29rZWR1cFN0YXJ0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc3RhcnQtdGltZXMgb2YgdGhlIGluc3RhbmNlcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgb2YgZXZlbnRzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gKFRoZSBlbmQtdGltZXMgYXJlIGlycmVsZXZhbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvb2tlZHVwU3RhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBsb29rZWR1cFN0YXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudElkID0gYCR7b2JqLmlkfV8ke2lTdGFydCsrfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2U6IGluc3RhbmNlLCBpZDogZXZlbnRJZCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGxvb2tlZHVwU3RhcnRzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldEluc3RhbmNlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBsb29rZWR1cFN0YXJ0cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwU3RhcnRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBgJHtvYmouaWR9XyR7aVN0YXJ0Kyt9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IGxvb2tlZHVwU3RhcnRzLnJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5hYmxlLmVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rdXBFbmQgPSB0aGlzLmxvb2t1cEV4cHJlc3Npb24ob2JqLCBkaXJlY3RSZWZlcmVuY2VzLCBlbmFibGUuZW5kLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiogQ29udGFpbnMgYW4gaW52ZXJ0ZWQgbGlzdCBvZiBpbnN0YW5jZXMuIFRoZXJlZm9yZSAuc3RhcnQgbWVhbnMgYW4gZW5kICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb29rZWR1cEVuZHMgPSAhbG9va3VwRW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb29rdXBFbmQucmVmZXJzVG9QYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnJlZmVyZW5jZS5hcHBseVBhcmVudEluc3RhbmNlcyhwYXJlbnRJbnN0YW5jZXMsIGxvb2t1cEVuZC5yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbG9va3VwRW5kLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWR1cEVuZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoMCwgbGliXzEuaXNBcnJheSkobG9va2VkdXBFbmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgc3RhcnQtdGltZXMgb2YgdGhlIGluc3RhbmNlcyBhbmQgYWRkIHRoZW0gKGFzIGVuZC1ldmVudHMpIHRvIHRoZSBsaXN0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChUaGUgZW5kLXRpbWVzIGFyZSBpcnJlbGV2YW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9va2VkdXBFbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0gbG9va2VkdXBFbmRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2U6IGluc3RhbmNlLCBpZDogYCR7b2JqLmlkfV8ke2lFbmQrK31gIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsb29rZWR1cEVuZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGxvb2tlZHVwRW5kcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmdldEluc3RhbmNlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogbG9va2VkdXBFbmRzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cEVuZHMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogYCR7b2JqLmlkfV8ke2lFbmQrK31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBsb29rZWR1cEVuZHMucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9va3VwRHVyYXRpb24gPSB0aGlzLmxvb2t1cEV4cHJlc3Npb24ob2JqLCBkaXJlY3RSZWZlcmVuY2VzLCBlbmFibGUuZHVyYXRpb24sICdkdXJhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxvb2tlZHVwRHVyYXRpb24gPSBsb29rdXBEdXJhdGlvbi5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9va2VkdXBEdXJhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgwLCBsaWJfMS5pc0FycmF5KShsb29rZWR1cER1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWR1cER1cmF0aW9uLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29rZWR1cER1cmF0aW9uID0gKDAsIGxpYl8xLmxpdGVyYWwpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsb29rZWR1cER1cmF0aW9uWzBdLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogbG9va2VkdXBEdXJhdGlvblswXS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobG9va2VkdXBEdXJhdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9va2VkdXBEdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb29rdXAgcmVuZGVkZWQgbXVsdGlwbGUgZHVyYXRpb25zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHVuc3VwcG9ydGVkIGF0IHRoZSBtb21lbnQsIGJ1dCBjb3VsZCBwb3NzaWJseSBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxvb2tlZHVwRHVyYXRpb24gc2hvdWxkIG5ldmVyIHJldHVybiBhbiBhcnJheSBmb3IgLmR1cmF0aW9uIGxvb2t1cGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb29rZWR1cER1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvb2tlZHVwUmVwZWF0aW5nICE9PSBudWxsICYmIGxvb2tlZHVwRHVyYXRpb24udmFsdWUgPiBsb29rZWR1cFJlcGVhdGluZy52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYXAgZHVyYXRpb24gdG8gcmVwZWF0aW5nIGR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb2tlZHVwRHVyYXRpb24udmFsdWUgPSBsb29rZWR1cFJlcGVhdGluZy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR28gdGhyb3VnaCBhbGwgcHJlLWV4aXN0aW5nIHN0YXJ0LWV2ZW50cywgYW5kIGFkZCBlbmQtZXZlbnRzIGZvciBlYWNoIG9mIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0RXZlbnQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElzIGEgc3RhcnQtZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBzdGFydEV2ZW50LnRpbWUgKyBsb29rZWR1cER1cmF0aW9uLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9ICgwLCByZWZlcmVuY2VfMS5qb2luUmVmZXJlbmNlcykoc3RhcnRFdmVudC5yZWZlcmVuY2VzLCBsb29rZWR1cER1cmF0aW9uLnJlZmVyZW5jZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHN0YXJ0RXZlbnQuZGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzdGFydEV2ZW50LmRhdGEuaW5zdGFuY2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZXM6IHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlSW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZS5jb252ZXJ0RXZlbnRzVG9JbnN0YW5jZXMoZXZlbnRzLCBmYWxzZSwgZmFsc2UsIFxuICAgICAgICAgICAgICAgICAgICAvLyBPbWl0IHRoZSByZWZlcmVuY2VkIG9yaWdpbmFsU3RhcnQvRW5kIHdoZW4gdXNpbmcgZW5hYmxlLnN0YXJ0OlxuICAgICAgICAgICAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FwIHRob3NlIGluc3RhbmNlcyB0byB0aGUgcGFyZW50IGluc3RhbmNlczpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFJlZiAmJiBwYXJlbnRJbnN0YW5jZXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBwYXJlbnRJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbnN0YW5jZU1hcC5zZXQoaW5zdGFuY2UuaWQsIGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHBlZEVuYWJsZUluc3RhbmNlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBlbmFibGVJbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlZFBhcmVudEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdvIHRocm91Z2ggdGhlIHJlZmVyZW5jZXMgaW4gcmV2ZXJzZSwgYmVjYXVzZSBzb21ldGltZXMgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMsIGFuZCB0aGUgbGFzdCBvbmUgaXMgcHJvYmFibHkgdGhlIG9uZSB3ZSB3YW50IHRvIHVzZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaW5zdGFuY2UucmVmZXJlbmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBpbnN0YW5jZS5yZWZlcmVuY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIHJlZmVyZW5jZV8xLmlzSW5zdGFuY2VSZWZlcmVuY2UpKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRQYXJlbnRJbnN0YW5jZSA9IHBhcmVudEluc3RhbmNlTWFwLmdldCgoMCwgcmVmZXJlbmNlXzEuZ2V0UmVmSW5zdGFuY2VJZCkocmVmKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZFBhcmVudEluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkUGFyZW50SW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwcGVkSW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlLmNhcEluc3RhbmNlKGluc3RhbmNlLCBtYXRjaGVkUGFyZW50SW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhcHBlZEluc3RhbmNlLmNhcHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXBwZWRJbnN0YW5jZS5jYXBzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlLmNhcHMucHVzaCgoMCwgbGliXzEubGl0ZXJhbCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG1hdGNoZWRQYXJlbnRJbnN0YW5jZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBtYXRjaGVkUGFyZW50SW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IG1hdGNoZWRQYXJlbnRJbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkRW5hYmxlSW5zdGFuY2VzLnB1c2goY2FwcGVkSW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FwcGVkRW5hYmxlSW5zdGFuY2VzLnB1c2goaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZUluc3RhbmNlcyA9IGNhcHBlZEVuYWJsZUluc3RhbmNlcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlSW5zdGFuY2VzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuYWJsZUluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2UuYXBwbHlSZXBlYXRpbmdJbnN0YW5jZXMoZW5hYmxlSW5zdGFuY2VzLCBsb29rZWR1cFJlcGVhdGluZyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBpbnN0YW5jZXMgcmVzdWx0aW5nIGZyb20gdGhpcyBlbmFibGUtZXhwcmVzc2lvbiB0byB0aGUgbGlzdDpcbiAgICAgICAgICAgICAgICAoMCwgbGliXzEucHVzaFRvQXJyYXkpKHJlc3VsdGluZ0luc3RhbmNlcywgZW5hYmxlSW5zdGFuY2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhcCB0aGUgaW5zdGFuY2VzIHRvIHRoZSBwYXJlbnQgaW5zdGFuY2VzOlxuICAgICAgICAgICAgaWYgKGhhc1BhcmVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdGluZ0luc3RhbmNlcyA9IHRoaXMuY2FwSW5zdGFuY2VzVG9QYXJlbnRJbnN0YW5jZXMoe1xuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXM6IHJlc3VsdGluZ0luc3RhbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SW5zdGFuY2VzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2UgdGhlIGluc3RhbmNlIGlkcyB1bmlxdWU6XG4gICAgICAgIGNvbnN0IGlkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIHJlc3VsdGluZ0luc3RhbmNlcykge1xuICAgICAgICAgICAgaWYgKGlkU2V0LmhhcyhpbnN0YW5jZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5pZCA9IGAke2luc3RhbmNlLmlkfV8ke3RoaXMuZ2V0SW5zdGFuY2VJZCgpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZFNldC5hZGQoaW5zdGFuY2UuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmouc2VhbWxlc3MgJiYgcmVzdWx0aW5nSW5zdGFuY2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJlc3VsdGluZ0luc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2UuY2xlYW5JbnN0YW5jZXMocmVzdWx0aW5nSW5zdGFuY2VzLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5wYXJlbnRJZCkge1xuICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlcy5wdXNoKGAjJHtvYmoucmVzb2x2ZWQucGFyZW50SWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvYmoucmVzb2x2ZWQuZmlyc3RSZXNvbHZlZCkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IG5lZWRzIHRvIGJlIGRvbmUgdXBvbiBmaXJzdCByZXNvbHZlOlxuICAgICAgICAgICAgdGhpcy51cGRhdGVEaXJlY3RSZWZlcmVuY2VNYXAob2JqLCBkaXJlY3RSZWZlcmVuY2VzKTtcbiAgICAgICAgfVxuICAgICAgICBvYmoucmVzb2x2ZWQuZmlyc3RSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIG9iai5yZXNvbHZlZC5yZXNvbHZlZFJlZmVyZW5jZXMgPSB0cnVlO1xuICAgICAgICBvYmoucmVzb2x2ZWQucmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIG9iai5yZXNvbHZlZC5pbnN0YW5jZXMgPSByZXN1bHRpbmdJbnN0YW5jZXM7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnVHJhY2UoYGRpcmVjdFJlZmVyZW5jZXMgXCIke29iai5pZH1cIjogJHtKU09OLnN0cmluZ2lmeShkaXJlY3RSZWZlcmVuY2VzKX1gKTtcbiAgICAgICAgICAgIHRoaXMuZGVidWdUcmFjZShgcmVzb2x2ZWQgXCIke29iai5pZH1cIjogJHtKU09OLnN0cmluZ2lmeShvYmoucmVzb2x2ZWQuaW5zdGFuY2VzKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5hbGx5OlxuICAgICAgICBvYmoucmVzb2x2ZWQucmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICBnZXRTdGF0aXN0aWNzKCkge1xuICAgICAgICBjb25zdCB0b2MgPSAoMCwgcGVyZm9ybWFuY2VfMS50aWMpKCcgIGdldFN0YXRpc3RpY3MnKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5za2lwU3RhdGlzdGljcykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkSW5zdGFuY2VDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZE9iamVjdENvdW50OiAwLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkR3JvdXBDb3VudDogMCxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEtleWZyYW1lQ291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2aW5nT2JqZWN0Q291bnQ6IDAsXG4gICAgICAgICAgICAgICAgcmVzb2x2aW5nQ291bnQ6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRpc3RpY3MgPSB7XG4gICAgICAgICAgICB0b3RhbENvdW50OiAwLFxuICAgICAgICAgICAgcmVzb2x2ZWRJbnN0YW5jZUNvdW50OiAwLFxuICAgICAgICAgICAgcmVzb2x2ZWRPYmplY3RDb3VudDogMCxcbiAgICAgICAgICAgIHJlc29sdmVkR3JvdXBDb3VudDogMCxcbiAgICAgICAgICAgIHJlc29sdmVkS2V5ZnJhbWVDb3VudDogMCxcbiAgICAgICAgICAgIHJlc29sdmluZ09iamVjdENvdW50OiB0aGlzLnN0YXRpc3RpY1Jlc29sdmluZ09iamVjdENvdW50LFxuICAgICAgICAgICAgcmVzb2x2aW5nQ291bnQ6IHRoaXMuc3RhdGlzdGljUmVzb2x2aW5nQ291bnQsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIHRoaXMub2JqZWN0c01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc3RhdGlzdGljcy50b3RhbENvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAob2JqLmlzR3JvdXApIHtcbiAgICAgICAgICAgICAgICBzdGF0aXN0aWNzLnJlc29sdmVkR3JvdXBDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgc3RhdGlzdGljcy5yZXNvbHZlZEtleWZyYW1lQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRpc3RpY3MucmVzb2x2ZWRPYmplY3RDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGlzdGljcy5yZXNvbHZlZEluc3RhbmNlQ291bnQgKz0gb2JqLnJlc29sdmVkLmluc3RhbmNlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdG9jKCk7XG4gICAgICAgIHJldHVybiBzdGF0aXN0aWNzO1xuICAgIH1cbiAgICBpbml0aWFsaXplQ2FjaGUoY2FjaGVPYmopIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IG5ldyBDYWNoZUhhbmRsZXJfMS5DYWNoZUhhbmRsZXIoY2FjaGVPYmosIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3QuXG4gICAgICogdHlwZS13aXNlLCBhc3N1bWVzIHlvdSBrbm93IHdoYXQgb2JqZWN0IHlvdSdyZSBsb29raW5nIGZvclxuICAgICAqL1xuICAgIGdldE9iamVjdChvYmpJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzTWFwLmdldChvYmpJZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2JqZWN0IGlkcyBvbiBhIGxheWVyXG4gICAgICogdHlwZS13aXNlLCBhc3N1bWVzIHlvdSBrbm93IHdoYXQgbGF5ZXIgeW91J3JlIGxvb2tpbmcgZm9yXG4gICAgICovXG4gICAgZ2V0TGF5ZXJPYmplY3RzKGxheWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyc01hcC5nZXQobGF5ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG9iamVjdCBpZHMgb24gYSBsYXllclxuICAgICAqIHR5cGUtd2lzZSwgYXNzdW1lcyB5b3Uga25vdyB3aGF0IGNsYXNzTmFtZSB5b3UncmUgbG9va2luZyBmb3JcbiAgICAgKi9cbiAgICBnZXRDbGFzc09iamVjdHMoY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXNNYXAuZ2V0KGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGNhcEluc3RhbmNlc1RvUGFyZW50SW5zdGFuY2VzKGFyZykge1xuICAgICAgICBpZiAoIWFyZy5wYXJlbnRJbnN0YW5jZXMpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGluc3RhbmNlIG9mIGFyZy5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5zdGFydCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBpbnN0YW5jZS5yZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgaW5zdGFuY2UsIGlzUGFyZW50OiBmYWxzZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogaW5zdGFuY2UucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBpbnN0YW5jZSwgaXNQYXJlbnQ6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBhcmcucGFyZW50SW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdGltZTogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogaW5zdGFuY2UucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICBkYXRhOiB7IGluc3RhbmNlLCBpc1BhcmVudDogdHJ1ZSB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuZW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBpbnN0YW5jZS5lbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogaW5zdGFuY2UucmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBpbnN0YW5jZSwgaXNQYXJlbnQ6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoMCwgZXZlbnRfMS5zb3J0RXZlbnRzKShldmVudHMsIGNvbXBhcmVFdmVudHMpO1xuICAgICAgICBjb25zdCBwYXJlbnRBY3RpdmVJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY2hpbGRBY3RpdmVJbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRBY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGNhcHBlZEluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZUN1cnJlbnRBY3RpdmUoKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGNhcHBlZEluc3RhbmNlcy5wdXNoKGN1cnJlbnRBY3RpdmUuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBldmVudHMpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmlzUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEFjdGl2ZUluc3RhbmNlcy5wdXNoKGV2ZW50LmRhdGEuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RhbmNlXzEuc3BsaWNlSW5zdGFuY2VzKShwYXJlbnRBY3RpdmVJbnN0YW5jZXMsIChpKSA9PiAoaSA9PT0gZXZlbnQuZGF0YS5pbnN0YW5jZSA/IHVuZGVmaW5lZCA6IGkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBDaGlsZCBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGlmIChldmVudC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEFjdGl2ZUluc3RhbmNlcy5wdXNoKGV2ZW50LmRhdGEuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGluc3RhbmNlXzEuc3BsaWNlSW5zdGFuY2VzKShjaGlsZEFjdGl2ZUluc3RhbmNlcywgKGkpID0+IChpID09PSBldmVudC5kYXRhLmluc3RhbmNlID8gdW5kZWZpbmVkIDogaSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkSW5zdGFuY2UgPSBjaGlsZEFjdGl2ZUluc3RhbmNlc1tjaGlsZEFjdGl2ZUluc3RhbmNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEluc3RhbmNlID0gcGFyZW50QWN0aXZlSW5zdGFuY2VzW3BhcmVudEFjdGl2ZUluc3RhbmNlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIC8qKiBJZiB0aGVyZSBpcyBhbiBhY3RpdmUgY2hpbGQgaW5zdGFuY2UgKi9cbiAgICAgICAgICAgIGNvbnN0IHRvQmVFbmFibGVkID0gQm9vbGVhbihjaGlsZEluc3RhbmNlICYmIHBhcmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICh0b0JlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaW5zdGFuY2UgaXMgc3RpbGwgdGhlIHNhbWU6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5zdGFuY2UuaWQgIT09IGN1cnJlbnRBY3RpdmUuaW5zdGFuY2UuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXJlbnRJbnN0YW5jZSAhPT0gY3VycmVudEFjdGl2ZS5wYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBwYXJlbnQgc3RpbGwgaXMgYWN0aXZlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFwYXJlbnRBY3RpdmVJbnN0YW5jZXMuaW5jbHVkZXMoY3VycmVudEFjdGl2ZS5wYXJlbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGFyZW50IGlzbid0IGFjdGl2ZSBhbnltb3JlLCBzdG9wIGFuZCBzdGFydCBhIG5ldyBpbnN0YW5jZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3AgaW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlLmluc3RhbmNlLmVuZCA9IGV2ZW50LnRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlLmluc3RhbmNlLm9yaWdpbmFsRW5kID0gY3VycmVudEFjdGl2ZS5pbnN0YW5jZS5vcmlnaW5hbEVuZCA/PyBldmVudC50aW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEFjdGl2ZS5pbnN0YW5jZS5yZWZlcmVuY2VzID0gKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShjdXJyZW50QWN0aXZlLmluc3RhbmNlLnJlZmVyZW5jZXMsIGV2ZW50LmRhdGEuaW5zdGFuY2UucmVmZXJlbmNlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZUN1cnJlbnRBY3RpdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGFuIGFjdGl2ZSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3RpdmUuaW5zdGFuY2UuaWQgIT09IGNoaWxkSW5zdGFuY2UuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlLmluc3RhbmNlLnJlZmVyZW5jZXMgPSAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGN1cnJlbnRBY3RpdmUuaW5zdGFuY2UucmVmZXJlbmNlcywgY2hpbGRJbnN0YW5jZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgaW5zdGFuY2U6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBY3RpdmUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNoaWxkSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGV2ZW50LnRpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsU3RhcnQ6IGNoaWxkSW5zdGFuY2Uub3JpZ2luYWxTdGFydCA/PyBldmVudC50aW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9yaWdpbmFsRW5kOiBjaGlsZEluc3RhbmNlLm9yaWdpbmFsRW5kID8/IG51bGwsIC8vIHNldCBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQ6IGNoaWxkSW5zdGFuY2Uub3JpZ2luYWxTdGFydCA/PyBjaGlsZEluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRW5kOiBjaGlsZEluc3RhbmNlLm9yaWdpbmFsRW5kID8/IGNoaWxkSW5zdGFuY2UuZW5kID8/IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlczogKDAsIHJlZmVyZW5jZV8xLmpvaW5SZWZlcmVuY2VzKShjaGlsZEluc3RhbmNlLnJlZmVyZW5jZXMsIC4uLnBhcmVudEFjdGl2ZUluc3RhbmNlcy5tYXAoKGkpID0+IGkucmVmZXJlbmNlcykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50SW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBpbnN0YW5jZTpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFjdGl2ZS5pbnN0YW5jZS5lbmQgPSBldmVudC50aW1lO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlLmluc3RhbmNlLm9yaWdpbmFsRW5kID0gY3VycmVudEFjdGl2ZS5pbnN0YW5jZS5vcmlnaW5hbEVuZCA/PyBldmVudC50aW1lO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QWN0aXZlLmluc3RhbmNlLnJlZmVyZW5jZXMgPSAoMCwgcmVmZXJlbmNlXzEuam9pblJlZmVyZW5jZXMpKGN1cnJlbnRBY3RpdmUuaW5zdGFuY2UucmVmZXJlbmNlcywgZXZlbnQuZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2VzKTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVDdXJyZW50QWN0aXZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsaXplQ3VycmVudEFjdGl2ZSgpO1xuICAgICAgICByZXR1cm4gY2FwcGVkSW5zdGFuY2VzO1xuICAgIH1cbiAgICB1cGRhdGVEaXJlY3RSZWZlcmVuY2VNYXAob2JqLCBkaXJlY3RSZWZlcmVuY2VzKSB7XG4gICAgICAgIG9iai5yZXNvbHZlZC5kaXJlY3RSZWZlcmVuY2VzID0gZGlyZWN0UmVmZXJlbmNlcztcbiAgICAgICAgZm9yIChjb25zdCByZWYgb2YgZGlyZWN0UmVmZXJlbmNlcykge1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0c1RoaXNJc1JlZmVyZW5jaW5nID0gW107XG4gICAgICAgICAgICBpZiAoKDAsIHJlZmVyZW5jZV8xLmlzT2JqZWN0UmVmZXJlbmNlKShyZWYpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqSWQgPSAoMCwgcmVmZXJlbmNlXzEuZ2V0UmVmT2JqZWN0SWQpKHJlZik7XG4gICAgICAgICAgICAgICAgb2JqZWN0c1RoaXNJc1JlZmVyZW5jaW5nLnB1c2gob2JqSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHJlZmVyZW5jZV8xLmlzQ2xhc3NSZWZlcmVuY2UpKHJlZikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSAoMCwgcmVmZXJlbmNlXzEuZ2V0UmVmQ2xhc3MpKHJlZik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvYmpJZCBvZiB0aGlzLmdldENsYXNzT2JqZWN0cyhjbGFzc05hbWUpID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHNUaGlzSXNSZWZlcmVuY2luZy5wdXNoKG9iaklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgcmVmZXJlbmNlXzEuaXNMYXllclJlZmVyZW5jZSkocmVmKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyID0gKDAsIHJlZmVyZW5jZV8xLmdldFJlZkxheWVyKShyZWYpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb2JqSWQgb2YgdGhpcy5nZXRMYXllck9iamVjdHMobGF5ZXIpID8/IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdHNUaGlzSXNSZWZlcmVuY2luZy5wdXNoKG9iaklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAoMCwgcmVmZXJlbmNlXzEuaXNJbnN0YW5jZVJlZmVyZW5jZSkocmVmKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgKDAsIGxpYl8xLmFzc2VydE5ldmVyKShyZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZWZPYmpJZCBvZiBvYmplY3RzVGhpc0lzUmVmZXJlbmNpbmcpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVmcyA9IHRoaXMuZGlyZWN0UmVmZXJlbmNlTWFwLmdldChyZWZPYmpJZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RSZWZlcmVuY2VNYXAuc2V0KHJlZk9iaklkLCByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKG9iai5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0T2JqZWN0c0xheWVycyhvYmpzKSB7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2Ygb2Jqcykge1xuICAgICAgICAgICAgaWYgKCgwLCB0aW1lbGluZV8xLm9iakhhc0xheWVyKShvYmopKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzLmFkZChgJHtvYmoubGF5ZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obGF5ZXJzLnZhbHVlcygpKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBsaXN0IG9mIGFsbCBvYmplY3QncyBsYXllcnMgKi9cbiAgICBnZXRBbGxPYmplY3RMYXllcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxPYmplY3RMYXllcnNDYWNoZSkge1xuICAgICAgICAgICAgLy8gQ2FjaGUgdGhpcywgc2luY2UgdGhpcyB3b24ndCBjaGFuZ2U6XG4gICAgICAgICAgICB0aGlzLmFsbE9iamVjdExheWVyc0NhY2hlID0gdGhpcy5nZXRPYmplY3RzTGF5ZXJzKHRoaXMub2JqZWN0c01hcC52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsT2JqZWN0TGF5ZXJzQ2FjaGU7XG4gICAgfVxuICAgIC8qKiBMb29rIHVwIGFuIGV4cHJlc3Npb24sIHVwZGF0ZSByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXQuICovXG4gICAgbG9va3VwRXhwcmVzc2lvbihvYmosIGRpcmVjdFJlZmVyZW5jZXMsIGV4cHIsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc2ltcGxpZmllZEV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24uc2ltcGxpZnlFeHByZXNzaW9uKGV4cHIpO1xuICAgICAgICBjb25zdCBsb29rdXBSZXN1bHQgPSB0aGlzLnJlZmVyZW5jZS5sb29rdXBFeHByZXNzaW9uKG9iaiwgc2ltcGxpZmllZEV4cHJlc3Npb24sIGNvbnRleHQpO1xuICAgICAgICAoMCwgbGliXzEucHVzaFRvQXJyYXkpKGRpcmVjdFJlZmVyZW5jZXMsIGxvb2t1cFJlc3VsdC5hbGxSZWZlcmVuY2VzKTtcbiAgICAgICAgLy8gSWYgZXhwcmVzc2lvbiBpcyBhIGNvbnN0YW50LCBpdCBpcyBhc3N1bWVkIHRvIGJlIGEgdGltZSByZWxhdGl2ZSB0byBpdHMgcGFyZW50OlxuICAgICAgICBjb25zdCByZWZlcnNUb1BhcmVudCA9IG9iai5yZXNvbHZlZC5wYXJlbnRJZCAmJiAoMCwgZXhwcmVzc2lvbl8xLmlzQ29uc3RhbnRFeHByKShzaW1wbGlmaWVkRXhwcmVzc2lvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxSZWZlcmVuY2VzOiBsb29rdXBSZXN1bHQuYWxsUmVmZXJlbmNlcyxcbiAgICAgICAgICAgIHJlc3VsdDogbG9va3VwUmVzdWx0LnJlc3VsdCxcbiAgICAgICAgICAgIHJlZmVyc1RvUGFyZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkVGltZWxpbmVPYmplY3Qob2JqLCBcbiAgICAvKiogQSBudW1iZXIgdGhhdCBpbmNyZWFzZXMgdGhlIG1vcmUgbGV2ZWxzIGluc2lkZSBvZiBhIGdyb3VwIHRoZSBvYmplY3RzIGlzLiAwID0gbm8gcGFyZW50ICovXG4gICAgbGV2ZWxEZWVwLCBcbiAgICAvKiogSUQgb2YgdGhlIHBhcmVudCBvYmplY3QgKi9cbiAgICBwYXJlbnRJZCwgaXNLZXlmcmFtZSkge1xuICAgICAgICBjb25zdCB0b2MgPSAoMCwgcGVyZm9ybWFuY2VfMS50aWMpKCcgIGFkZFRpbWVsaW5lT2JqZWN0Jyk7XG4gICAgICAgIC8vIElzIGl0IGFscmVhZHkgYWRkZWQ/XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmplY3RzTWFwLmhhcyhvYmouaWQpKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgQWxsIHRpbWVsaW5lT2JqZWN0cyBtdXN0IGJlIHVuaXF1ZSEgKGR1cGxpY2F0ZTogXCIke29iai5pZH1cIilgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIG9iamVjdDpcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgbyA9IHtcbiAgICAgICAgICAgICAgICAuLi5vYmosXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RSZXNvbHZlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkUmVmZXJlbmNlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQ29uZmxpY3RzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWxEZWVwOiBsZXZlbERlZXAsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZlJlZmVyZW5jaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0UmVmZXJlbmNlczogW10sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBwYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgaXNLZXlmcmFtZTogaXNLZXlmcmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0c01hcC5zZXQob2JqLmlkLCBvKTtcbiAgICAgICAgICAgIGlmIChvYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gb2JqLmNsYXNzZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbGFzc0xpc3QgPSB0aGlzLmNsYXNzZXNNYXAuZ2V0KGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsYXNzTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTGlzdCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3Nlc01hcC5zZXQoY2xhc3NOYW1lLCBjbGFzc0xpc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NMaXN0LnB1c2gob2JqLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoMCwgdGltZWxpbmVfMS5vYmpIYXNMYXllcikob2JqKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyID0gYCR7b2JqLmxheWVyfWA7XG4gICAgICAgICAgICAgICAgbGV0IGxheWVyTGlzdCA9IHRoaXMubGF5ZXJzTWFwLmdldChsYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllckxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJMaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJzTWFwLnNldChsYXllciwgbGF5ZXJMaXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGF5ZXJMaXN0LnB1c2gob2JqLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHbyB0aHJvdWdoIGNoaWxkcmVuIGFuZCBrZXlmcmFtZXM6XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIEFkZCBjaGlsZHJlbjpcbiAgICAgICAgICAgIGlmIChvYmouaXNHcm91cCAmJiBvYmouY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG9iai5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGltZWxpbmVPYmplY3QoY2hpbGQsIGxldmVsRGVlcCArIDEsIG9iai5pZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCBrZXlmcmFtZXM6XG4gICAgICAgICAgICBpZiAob2JqLmtleWZyYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iai5rZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtmMiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmtleWZyYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXI6ICcnLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRUaW1lbGluZU9iamVjdChrZjIsIGxldmVsRGVlcCArIDEsIG9iai5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGNvbmZsaWN0cyBmb3IgYWxsIGxheWVycyBvZiB0aGUgcHJvdmlkZWQgb2JqZWN0c1xuICAgICAqL1xuICAgIHJlc29sdmVDb25mbGljdHNGb3JPYmpzKFxuICAgIC8qKiBudWxsIG1lYW5zIGFsbCBsYXllcnMgKi9cbiAgICBvYmpzKSB7XG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgICAgcmVzb2x2ZUNvbmZsaWN0c0Zvck9ianMnKTtcbiAgICAgICAgLy8gVGhlc2UgbmVlZCB0byBiZSBjbGVhcmVkLFxuICAgICAgICAvLyBhcyB0aGV5IGFyZSBwb3B1bGF0ZWQgZHVyaW5nIHRoZSB0aGlzLnVwZGF0ZU9iamVjdHNUb1JlUmVzb2x2ZSgpIGJlbG93OlxuICAgICAgICB0aGlzLmNoYW5nZWRPYmpJZHNFeHBsYW5hdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5vYmplY3RzVG9SZVJlc29sdmUuY2xlYXIoKTtcbiAgICAgICAgLyoqIExpc3Qgb2YgbGF5ZXJzIHRvIHJlc29sdmUgY29uZmxpY3RzIG9uICovXG4gICAgICAgIGxldCBsYXllcnM7XG4gICAgICAgIGlmIChvYmpzID09PSBudWxsKSB7XG4gICAgICAgICAgICBsYXllcnMgPSB0aGlzLmdldEFsbE9iamVjdExheWVycygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGF5ZXJzID0gdGhpcy5nZXRPYmplY3RzTGF5ZXJzKG9ianMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXliZUNoYW5nZWRPYmpzID0gdGhpcy5yZXNvbHZlQ29uZmxpY3RzRm9yTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgLy8gcnVuIHRoaXMudXBkYXRlT2JqZWN0c1RvUmVSZXNvbHZlKCkgaGVyZSAoYXMgb3Bwb3NlZCB0byBvdXRzaWRlIHRoZSBsb29wKSxcbiAgICAgICAgICAgIC8vIHRvIGFsbG93IGZvciBhIGZhc3QtcGF0aCBpbiByZXNvbHZlQ29uZmxpY3RzRm9yTGF5ZXIgdGhhdCBza2lwcyByZXNvbHZpbmcgdGhhdCBsYXllciBpZiBpdCBjb250YWluc1xuICAgICAgICAgICAgLy8gb2JqZWN0cyB0aGF0IGRlcGVuZCBvbiBhbHJlYWR5IGNoYW5nZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlT2JqZWN0c1RvUmVSZXNvbHZlKG1heWJlQ2hhbmdlZE9ianMpO1xuICAgICAgICB9XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIGNvbmZsaWN0cyBmb3IgYSBsYXllclxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiBvYmplY3RzIG9uIHRoYXQgbGF5ZXJcbiAgICAgKi9cbiAgICByZXNvbHZlQ29uZmxpY3RzRm9yTGF5ZXIobGF5ZXIpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5ldyBMYXllclN0YXRlSGFuZGxlcl8xLkxheWVyU3RhdGVIYW5kbGVyKHRoaXMsIHRoaXMuaW5zdGFuY2UsIGxheWVyKTtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBhbiBvYmplY3Qgb24gdGhpcyBsYXllciBkZXBlbmRzIG9uIGFuIGFscmVhZHkgY2hhbmdlZCBvYmplY3Qgd2Ugc2hvdWxkIHNraXAgdGhpcyBsYXllciwgdGhpcyBpdGVyYXRpb24uXG4gICAgICAgIC8vIEJlY2F1c2UgdGhlIG9iamVjdHMgd2lsbCBsaWtlbHkgY2hhbmdlIGR1cmluZyB0aGUgbmV4dCByZXNvbHZlLWl0ZXJhdGlvbiBhbnl3YXkuXG4gICAgICAgIGZvciAoY29uc3Qgb2JqSWQgb2YgaGFuZGxlci5vYmplY3RJZHNPbkxheWVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vYmplY3RzVG9SZVJlc29sdmUuaGFzKG9iaklkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdUcmFjZShgb3B0aW1pemF0aW9uOiBTa2lwcGluZyBcIiR7bGF5ZXJ9XCIgc2luY2UgXCIke29iaklkfVwiIGNoYW5nZWRgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlci5yZXNvbHZlQ29uZmxpY3RzKCk7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLm9iamVjdHNPbkxheWVyO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyB0aGUgbmV4dCB1bmlxdWUgaW5zdGFuY2UgaWQgKi9cbiAgICBnZXRJbnN0YW5jZUlkKCkge1xuICAgICAgICByZXR1cm4gYEAkeyh0aGlzLl9pZENvdW50KyspLnRvU3RyaW5nKDM2KX1gO1xuICAgIH1cbiAgICB1cGRhdGVPYmplY3RzVG9SZVJlc29sdmUobWF5YmVDaGFuZ2VkT2Jqcykge1xuICAgICAgICBjb25zdCB0b2MgPSAoMCwgcGVyZm9ybWFuY2VfMS50aWMpKCcgICAgIHVwZGF0ZU9iamVjdHNUb1JlUmVzb2x2ZScpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkT2JqcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgbWF5YmVDaGFuZ2VkT2Jqcykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluc3RhbmNlcyBoYXZlIGNoYW5nZWQ6XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZXNIYXNoID0gKDAsIGluc3RhbmNlXzEuZ2V0SW5zdGFuY2VzSGFzaCkob2JqLnJlc29sdmVkLmluc3RhbmNlcyk7XG4gICAgICAgICAgICBjb25zdCBwcmV2SGFzaCA9IHRoaXMucmVzb2x2ZWRPYmpJbnN0YW5jZXNIYXNoLmdldChvYmouaWQpID8/ICdub3QtZm91bmQnO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlc0hhc2ggIT09IHByZXZIYXNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT2JqSWRzRXhwbGFuYXRpb25zLnB1c2goYFwiJHtvYmouaWR9XCIgY2hhbmdlZCBmcm9tOiBcXG4gICAke3ByZXZIYXNofVxcbiAgICwgdG8gXFxuICAgJHtpbnN0YW5jZXNIYXNofVxcbmApO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZWRPYmpJZHNFeHBsYW5hdGlvbnMubGVuZ3RoID4gMilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkT2JqSWRzRXhwbGFuYXRpb25zLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWJ1Z1RyYWNlKGBjaGFuZ2VkOiAke29iai5pZH06IFwiJHtwcmV2SGFzaH1cIiAtPiBcIiR7aW5zdGFuY2VzSGFzaH1cImApO1xuICAgICAgICAgICAgICAgIGNoYW5nZWRPYmpzLmFkZChvYmouaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRPYmpJbnN0YW5jZXNIYXNoLnNldChvYmouaWQsIGluc3RhbmNlc0hhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlZE9iaklkIG9mIGNoYW5nZWRPYmpzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAvLyBGaW5kIGFsbCBvYmplY3RzIHRoYXQgZGVwZW5kIG9uIHRoaXM6XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RSZWZlcmVuY2VzID0gdGhpcy5kaXJlY3RSZWZlcmVuY2VNYXAuZ2V0KGNoYW5nZWRPYmpJZCkgPz8gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9iaklkIG9mIGRpcmVjdFJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvYmogPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgICAgICAgICAgICAgb2JqLnJlc29sdmVkLnJlc29sdmVkUmVmZXJlbmNlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IG9iai5yZXNvbHZlZC5yZXNvbHZlZENvbmZsaWN0cyB3aWxsIGJlIHNldCB0byBmYWxzZSBsYXRlciB3aGVuIHJlc29sdmluZyByZWZlcmVuY2VzXG4gICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzVG9SZVJlc29sdmUuc2V0KG9iai5pZCwgb2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b2MoKTtcbiAgICB9XG4gICAgZGVidWdUcmFjZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKVxuICAgICAgICAgICAgY29uc29sZS5sb2coLi4uYXJncyk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZlZFRpbWVsaW5lSGFuZGxlciA9IFJlc29sdmVkVGltZWxpbmVIYW5kbGVyO1xuZnVuY3Rpb24gY29tcGFyZUV2ZW50cyhhLCBiKSB7XG4gICAgLy8gc3RhcnQgZXZlbnQgYmUgZmlyc3Q6XG4gICAgY29uc3QgYVZhbHVlID0gYS52YWx1ZTtcbiAgICBjb25zdCBiVmFsdWUgPSBiLnZhbHVlO1xuICAgIGlmIChhVmFsdWUgJiYgIWJWYWx1ZSlcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmICghYVZhbHVlICYmIGJWYWx1ZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgY29uc3QgYUlzUGFyZW50ID0gYS5kYXRhLmlzUGFyZW50O1xuICAgIGNvbnN0IGJJc1BhcmVudCA9IGIuZGF0YS5pc1BhcmVudDtcbiAgICBpZiAoYVZhbHVlKSB7XG4gICAgICAgIC8vIHN0YXJ0OiBwYXJlbnRzIGZpcnN0OlxuICAgICAgICBpZiAoYUlzUGFyZW50ICYmICFiSXNQYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGlmICghYUlzUGFyZW50ICYmIGJJc1BhcmVudClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZW5kOiBwYXJlbnRzIGxhc3Q6XG4gICAgICAgIGlmIChhSXNQYXJlbnQgJiYgIWJJc1BhcmVudClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoIWFJc1BhcmVudCAmJiBiSXNQYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIHBhcmVudHMgZmlyc3Q6XG4gICAgLy8gaWYgKGEuZGF0YS5pc1BhcmVudCAmJiAhYi5kYXRhLmlzUGFyZW50KSByZXR1cm4gLTFcbiAgICAvLyBpZiAoIWEuZGF0YS5pc1BhcmVudCAmJiBiLmRhdGEuaXNQYXJlbnQpIHJldHVybiAxXG4gICAgcmV0dXJuIDA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXNvbHZlZFRpbWVsaW5lSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2ZXJIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgUmVzb2x2ZWRUaW1lbGluZUhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL1Jlc29sdmVkVGltZWxpbmVIYW5kbGVyXCIpO1xuY29uc3QgcmVzb2x2ZWRUaW1lbGluZV8xID0gcmVxdWlyZShcIi4uL2FwaS9yZXNvbHZlZFRpbWVsaW5lXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWIvbGliXCIpO1xuY29uc3QgcGVyZm9ybWFuY2VfMSA9IHJlcXVpcmUoXCIuL2xpYi9wZXJmb3JtYW5jZVwiKTtcbmNvbnN0IHRpbWVsaW5lXzEgPSByZXF1aXJlKFwiLi9saWIvdGltZWxpbmVcIik7XG5jb25zdCBUaW1lbGluZVZhbGlkYXRvcl8xID0gcmVxdWlyZShcIi4vVGltZWxpbmVWYWxpZGF0b3JcIik7XG4vKipcbiAqIE5vdGU6IEEgUmVzb2x2ZXIgaW5zdGFuY2UgaXMgc2hvcnQtbGl2ZWQgYW5kIHVzZWQgdG8gcmVzb2x2ZSBhIHRpbWVsaW5lLlxuICogSW50ZW5kZWQgdXNhZ2U6XG4gKiAxLiBjb25zdCByZXNvbHZlciA9IG5ldyBSZXNvbHZlcihvcHRpb25zKVxuICogMi4gcmVzb2x2ZXIucnVuKHRpbWVsaW5lKVxuICovXG5jbGFzcyBSZXNvbHZlckhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5oYXNSdW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5uZXh0RXZlbnRzID0gW107XG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJ25ldyBSZXNvbHZlcicpO1xuICAgICAgICB0aGlzLnJlc29sdmVkVGltZWxpbmUgPSBuZXcgUmVzb2x2ZWRUaW1lbGluZUhhbmRsZXJfMS5SZXNvbHZlZFRpbWVsaW5lSGFuZGxlcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IG5ldyBUaW1lbGluZVZhbGlkYXRvcl8xLlRpbWVsaW5lVmFsaWRhdG9yKCk7XG4gICAgICAgIHRvYygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHRpbWVsaW5lLCBpLmUuIHJlc29sdmVzIHRoZSByZWZlcmVuY2VzIGJldHdlZW4gb2JqZWN0c1xuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIHJ1biBvbmNlIHBlciBSZXNvbHZlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICByZXNvbHZlVGltZWxpbmUodGltZWxpbmUpIHtcbiAgICAgICAgY29uc3QgdG9jID0gKDAsIHBlcmZvcm1hbmNlXzEudGljKSgncmVzb2x2ZVRpbWVsaW5lJyk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAodGhpcy5oYXNSdW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc29sdmVyLnJlc29sdmVUaW1lbGluZSBjYW4gb25seSBydW4gb25jZSBwZXIgaW5zdGFuY2UhXG5Vc2FnZTpcbmNvbnN0IHJlc29sdmVyID0gbmV3IFJlc29sdmVyKG9wdGlvbnMpO1xucmVzb2x2ZXIucnVuKHRpbWVsaW5lKTtgKTtcbiAgICAgICAgdGhpcy5oYXNSdW4gPSB0cnVlO1xuICAgICAgICAvLyBTdGVwIDA6IFZhbGlkYXRlIHRoZSB0aW1lbGluZTpcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlVGltZWxpbmUodGltZWxpbmUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDE6IFBvcHVsYXRlIFJlc29sdmVkVGltZWxpbmUgd2l0aCB0aGUgdGltZWxpbmU6XG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIHRpbWVsaW5lKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkVGltZWxpbmUuYWRkVGltZWxpbmVPYmplY3Qob2JqKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDI6IFVzZSBjYWNoZTpcbiAgICAgICAgbGV0IGNhY2hlSGFuZGxlcjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jYWNoZSkge1xuICAgICAgICAgICAgY2FjaGVIYW5kbGVyID0gdGhpcy5yZXNvbHZlZFRpbWVsaW5lLmluaXRpYWxpemVDYWNoZSh0aGlzLm9wdGlvbnMuY2FjaGUpO1xuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLmRldGVybWluZUNoYW5nZWRPYmplY3RzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAzOiBHbyB0aHJvdWdoIGFuZCByZXNvbHZlIGFsbCBvYmplY3RzOlxuICAgICAgICB0aGlzLnJlc29sdmVkVGltZWxpbmUucmVzb2x2ZUFsbFRpbWVsaW5lT2JqcygpO1xuICAgICAgICAvLyBTdGVwIDQ6IFBvcHVsYXRlIG5leHRFdmVudHM6XG4gICAgICAgIHRoaXMudXBkYXRlTmV4dEV2ZW50cygpO1xuICAgICAgICAvLyBTdGVwIDU6IHBlcnNpc3QgY2FjaGVcbiAgICAgICAgaWYgKGNhY2hlSGFuZGxlcikge1xuICAgICAgICAgICAgY2FjaGVIYW5kbGVyLnBlcnNpc3REYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUaW1lbGluZSA9ICgwLCBsaWJfMS5saXRlcmFsKSh7XG4gICAgICAgICAgICBvYmplY3RzOiAoMCwgbGliXzEubWFwVG9PYmplY3QpKHRoaXMucmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzTWFwKSxcbiAgICAgICAgICAgIGNsYXNzZXM6ICgwLCBsaWJfMS5tYXBUb09iamVjdCkodGhpcy5yZXNvbHZlZFRpbWVsaW5lLmNsYXNzZXNNYXApLFxuICAgICAgICAgICAgbGF5ZXJzOiAoMCwgbGliXzEubWFwVG9PYmplY3QpKHRoaXMucmVzb2x2ZWRUaW1lbGluZS5sYXllcnNNYXApLFxuICAgICAgICAgICAgbmV4dEV2ZW50czogdGhpcy5uZXh0RXZlbnRzLFxuICAgICAgICAgICAgc3RhdGlzdGljczogdGhpcy5yZXNvbHZlZFRpbWVsaW5lLmdldFN0YXRpc3RpY3MoKSxcbiAgICAgICAgICAgIGVycm9yOiB0aGlzLnJlc29sdmVkVGltZWxpbmUucmVzb2x2ZUVycm9yLFxuICAgICAgICB9KTtcbiAgICAgICAgdG9jKCk7XG4gICAgICAgIHJldHVybiByZXNvbHZlZFRpbWVsaW5lO1xuICAgIH1cbiAgICAvKiogVXBkYXRlIHRoaXMubmV4dEV2ZW50cyAqL1xuICAgIHVwZGF0ZU5leHRFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgdXBkYXRlTmV4dEV2ZW50cycpO1xuICAgICAgICB0aGlzLm5leHRFdmVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsT2JqZWN0cyA9IFtdO1xuICAgICAgICBjb25zdCBhbGxLZXlmcmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgdGhpcy5yZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSkge1xuICAgICAgICAgICAgICAgIGFsbEtleWZyYW1lcy5wdXNoKG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbGxPYmplY3RzLnB1c2gob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiogVXNlZCB0byBmYXN0LXRyYWNrIGluIGNhc2VzIHdoZXJlIHRoZXJlIGFyZSBubyBrZXlmcmFtZXMgKi9cbiAgICAgICAgY29uc3QgaGFzS2V5ZnJhbWVzID0gYWxsS2V5ZnJhbWVzLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IG9iamVjdEluc3RhbmNlU3RhcnRUaW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0SW5zdGFuY2VFbmRUaW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gR28gdGhyb3VnaCBrZXlmcmFtZXMgbGFzdDpcbiAgICAgICAgZm9yIChjb25zdCBvYmogb2YgWy4uLmFsbE9iamVjdHMsIC4uLmFsbEtleWZyYW1lc10pIHtcbiAgICAgICAgICAgIGlmICghb2JqLnJlc29sdmVkLmlzS2V5ZnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoISgwLCB0aW1lbGluZV8xLm9iakhhc0xheWVyKShvYmopKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gdHJhbnNwYXJlbnQgb2JqZWN0cyBhcmUgb21pdHRlZCBpbiBOZXh0RXZlbnRzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvYmoucmVzb2x2ZWQucGFyZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE9iaiA9IHRoaXMucmVzb2x2ZWRUaW1lbGluZS5nZXRPYmplY3Qob2JqLnJlc29sdmVkLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCB0aW1lbGluZV8xLm9iakhhc0xheWVyKShwYXJlbnRPYmopKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIEtleWZyYW1lcyBvZiB0cmFuc3BhcmVudCBvYmplY3RzIGFyZSBvbWl0dGVkIGluIE5leHRFdmVudHNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5yZXNvbHZlZC5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG9iai5yZXNvbHZlZC5pbnN0YW5jZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXJ0ID4gdGhpcy5vcHRpb25zLnRpbWUgJiYgaW5zdGFuY2Uuc3RhcnQgPCAodGhpcy5vcHRpb25zLmxpbWl0VGltZSA/PyBJbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVzZVRoaXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzS2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SW5zdGFuY2VTdGFydFRpbWVzLmFkZChgJHtvYmouaWR9XyR7aW5zdGFuY2Uuc3RhcnR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHB1dCBrZXlmcmFtZSBldmVudCBpZiBpdHMgcGFyZW50IHN0YXJ0cyBhdCB0aGUgc2FtZSB0aW1lOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RJbnN0YW5jZVN0YXJ0VGltZXMuaGFzKGAke29iai5yZXNvbHZlZC5wYXJlbnRJZH1fJHtpbnN0YW5jZS5zdGFydH1gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VUaGlzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VUaGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRFdmVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqSWQ6IG9iai5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBvYmoucmVzb2x2ZWQuaXNLZXlmcmFtZSA/IHJlc29sdmVkVGltZWxpbmVfMS5FdmVudFR5cGUuS0VZRlJBTUUgOiByZXNvbHZlZFRpbWVsaW5lXzEuRXZlbnRUeXBlLlNUQVJULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLnN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbmQgPiB0aGlzLm9wdGlvbnMudGltZSAmJlxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5lbmQgPCAodGhpcy5vcHRpb25zLmxpbWl0VGltZSA/PyBJbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVzZVRoaXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzS2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9iai5yZXNvbHZlZC5pc0tleWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SW5zdGFuY2VFbmRUaW1lcy5hZGQoYCR7b2JqLmlkfV8ke2luc3RhbmNlLmVuZH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gcHV0IGtleWZyYW1lIGV2ZW50IGlmIGl0cyBwYXJlbnQgZW5kcyBhdCB0aGUgc2FtZSB0aW1lOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RJbnN0YW5jZUVuZFRpbWVzLmhhcyhgJHtvYmoucmVzb2x2ZWQucGFyZW50SWR9XyR7aW5zdGFuY2UuZW5kfWApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZVRoaXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZVRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmpJZDogb2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG9iai5yZXNvbHZlZC5pc0tleWZyYW1lID8gcmVzb2x2ZWRUaW1lbGluZV8xLkV2ZW50VHlwZS5LRVlGUkFNRSA6IHJlc29sdmVkVGltZWxpbmVfMS5FdmVudFR5cGUuRU5ELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWU6IGluc3RhbmNlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dEV2ZW50cy5zb3J0KGNvbXBhcmVOZXh0RXZlbnRzKTtcbiAgICAgICAgdG9jKCk7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZlckhhbmRsZXIgPSBSZXNvbHZlckhhbmRsZXI7XG5mdW5jdGlvbiBjb21wYXJlTmV4dEV2ZW50cyhhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZSAtIGIudGltZSB8fCBiLnR5cGUgLSBhLnR5cGUgfHwgKDAsIGxpYl8xLmNvbXBhcmVTdHJpbmdzKShhLm9iaklkLCBiLm9iaklkKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc29sdmVySGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdGVIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgaW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuL2xpYi9pbnN0YW5jZVwiKTtcbmNvbnN0IGxpYl8xID0gcmVxdWlyZShcIi4vbGliL2xpYlwiKTtcbmNvbnN0IHBlcmZvcm1hbmNlXzEgPSByZXF1aXJlKFwiLi9saWIvcGVyZm9ybWFuY2VcIik7XG5jb25zdCB0aW1lbGluZV8xID0gcmVxdWlyZShcIi4vbGliL3RpbWVsaW5lXCIpO1xuY2xhc3MgU3RhdGVIYW5kbGVyIHtcbiAgICBnZXRTdGF0ZShyZXNvbHZlZFRpbWVsaW5lLCB0aW1lLCBldmVudExpbWl0ID0gMCkge1xuICAgICAgICBjb25zdCB0b2MgPSAoMCwgcGVyZm9ybWFuY2VfMS50aWMpKCdnZXRTdGF0ZScpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpbWU6IHRpbWUsXG4gICAgICAgICAgICBsYXllcnM6IHt9LFxuICAgICAgICAgICAgbmV4dEV2ZW50czogcmVzb2x2ZWRUaW1lbGluZS5uZXh0RXZlbnRzLmZpbHRlcigoZSkgPT4gZS50aW1lID4gdGltZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudExpbWl0KVxuICAgICAgICAgICAgc3RhdGUubmV4dEV2ZW50cyA9IHN0YXRlLm5leHRFdmVudHMuc2xpY2UoMCwgZXZlbnRMaW1pdCk7XG4gICAgICAgIGZvciAoY29uc3Qgb2JqIG9mIE9iamVjdC52YWx1ZXMocmVzb2x2ZWRUaW1lbGluZS5vYmplY3RzKSkge1xuICAgICAgICAgICAgaWYgKCEoMCwgdGltZWxpbmVfMS5vYmpIYXNMYXllcikob2JqKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IFdlIGNhbiBhc3N1bWUgdGhhdCBpdCBpcyBub3QgYSBrZXlmcmFtZSBoZXJlLCBiZWNhdXNlIGtleWZyYW1lcyBkb24ndCBoYXZlIGxheWVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBvYmoucmVzb2x2ZWQuaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBpbnN0YW5jZV8xLmluc3RhbmNlSXNBY3RpdmUpKGluc3RhbmNlLCB0aW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29udGVudElzT3JpZ2luYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYmpJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9iaixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlLmxheWVyc1tgJHtvYmoubGF5ZXJ9YF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGFscmVhZHkgYW4gb2JqZWN0IG9uIHRoaXMgbGF5ZXIhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKHN0YXRlLmxheWVyc1tgJHtvYmoubGF5ZXJ9YF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihvYmpJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIEVycm9yOiBUaGVyZSBpcyBhbHJlYWR5IGFuIG9iamVjdCBvbiBsYXllciBcIiR7b2JqLmxheWVyfVwiIWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmxheWVyc1tgJHtvYmoubGF5ZXJ9YF0gPSBvYmpJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93LCBhcHBseSBrZXlmcmFtZXM6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdEtleWZyYW1lcyA9IG9iai5rZXlmcmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb2JqLmtleWZyYW1lcy5tYXAoKGtmKSA9PiByZXNvbHZlZFRpbWVsaW5lLm9iamVjdHNba2YuaWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXlmcmFtZSBvZiB0aGlzLmdldEFjdGl2ZUtleWZyYW1lSW5zdGFuY2VzKG9iamVjdEtleWZyYW1lcywgdGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50SXNPcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gbW9kaWZ5IHRoZSBvcmlnaW5hbCBjb250ZW50LCBzbyB3ZSBkZWVwLWNsb25lIGl0IGJlZm9yZSBtb2RpZnlpbmcgaXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqSW5zdGFuY2UuY29udGVudCA9ICgwLCBsaWJfMS5jbG9uZSkob2JqLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRJc09yaWdpbmFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBTdGF0ZUhhbmRsZXIuYXBwbHlLZXlmcmFtZUNvbnRlbnQob2JqSW5zdGFuY2UuY29udGVudCwga2V5ZnJhbWUuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9jKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkga2V5ZnJhbWUgY29udGVudCBvbnRvIGl0cyBwYXJlbnQgY29udGVudC5cbiAgICAgKiBUaGUga2V5ZnJhbWUgY29udGVudCBpcyBkZWVwbHktYXBwbGllZCBvbnRvIHRoZSBwYXJlbnQgY29udGVudC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlLZXlmcmFtZUNvbnRlbnQocGFyZW50Q29udGVudCwga2V5ZnJhbWVDb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgYXBwbHlLZXlmcmFtZUNvbnRlbnQnKTtcbiAgICAgICAgZm9yIChjb25zdCBbYXR0ciwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGtleWZyYW1lQ29udGVudCkpIHtcbiAgICAgICAgICAgIGlmICgoMCwgbGliXzEuaXNPYmplY3QpKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICgoMCwgbGliXzEuaXNBcnJheSkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwYXJlbnRDb250ZW50W2F0dHJdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseUtleWZyYW1lQ29udGVudChwYXJlbnRDb250ZW50W2F0dHJdLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbnRlbnRbYXR0cl0uc3BsaWNlKHZhbHVlLmxlbmd0aCwgSW5maW5pdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsdWUgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGxpYl8xLmlzT2JqZWN0KShwYXJlbnRDb250ZW50W2F0dHJdKSB8fCBBcnJheS5pc0FycmF5KHBhcmVudENvbnRlbnRbYXR0cl0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29udGVudFthdHRyXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5S2V5ZnJhbWVDb250ZW50KHBhcmVudENvbnRlbnRbYXR0cl0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb250ZW50W2F0dHJdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9jKCk7XG4gICAgfVxuICAgIGdldEFjdGl2ZUtleWZyYW1lSW5zdGFuY2VzKGtleWZyYW1lcywgdGltZSkge1xuICAgICAgICBjb25zdCBrZXlmcmFtZUluc3RhbmNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleWZyYW1lIG9mIGtleWZyYW1lcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBrZXlmcmFtZS5yZXNvbHZlZC5pbnN0YW5jZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGluc3RhbmNlXzEuaW5zdGFuY2VJc0FjdGl2ZSkoaW5zdGFuY2UsIHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleWZyYW1lSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ua2V5ZnJhbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGtleWZyYW1lSW5zdGFuY2VzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIC8vIEhpZ2hlc3QgcHJpb3JpdHkgaXMgYXBwbGllZCBsYXN0OlxuICAgICAgICAgICAgY29uc3QgYVByaW9yaXR5ID0gYS5wcmlvcml0eSA/PyAwO1xuICAgICAgICAgICAgY29uc3QgYlByaW9yaXR5ID0gYi5wcmlvcml0eSA/PyAwO1xuICAgICAgICAgICAgaWYgKGFQcmlvcml0eSA8IGJQcmlvcml0eSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYVByaW9yaXR5ID4gYlByaW9yaXR5KVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgLy8gTGFzdCBzdGFydCB0aW1lIGlzIGFwcGxpZWQgbGFzdDpcbiAgICAgICAgICAgIGlmIChhLmluc3RhbmNlLnN0YXJ0IDwgYi5pbnN0YW5jZS5zdGFydClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBpZiAoYS5pbnN0YW5jZS5zdGFydCA+IGIuaW5zdGFuY2Uuc3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ga2V5ZnJhbWVJbnN0YW5jZXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0ZUhhbmRsZXIgPSBTdGF0ZUhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdGF0ZUhhbmRsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRpbWVsaW5lVmFsaWRhdG9yID0gdm9pZCAwO1xuY29uc3QgRXhwcmVzc2lvbkhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL0V4cHJlc3Npb25IYW5kbGVyXCIpO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWIvbGliXCIpO1xuY29uc3QgcGVyZm9ybWFuY2VfMSA9IHJlcXVpcmUoXCIuL2xpYi9wZXJmb3JtYW5jZVwiKTtcbi8qKiBUaGVzZSBjaGFyYWN0ZXJzIGFyZSByZXNlcnZlZCBhbmQgY2Fubm90IGJlIHVzZWQgaW4gaWRzLCBldGMgKi9cbmNvbnN0IFJFU0VSVkVEX0NIQVJBQ1RFUlMgPSAvWyMuJF0vZztcbi8qKiBUaGVzZSBjaGFyYWN0ZXJzIGFyZSByZXNlcnZlZCBmb3IgcG9zc2libGUgZnV0dXJlIHVzZSBhbmQgY2Fubm90IGJlIHVzZWQgaW4gaWRzLCBldGMgKi9cbmNvbnN0IEZVVFVSRV9SRVNFUlZFRF9DSEFSQUNURVJTID0gL1s9P0B7fVtcXF1ewqddL2c7XG4vKipcbiAqIE5vdGU6IEEgVGltZWxpbmVWYWxpZGF0b3IgaW5zdGFuY2UgaXMgc2hvcnQtbGl2ZWQgYW5kIHVzZWQgdG8gdmFsaWRhdGUgYSB0aW1lbGluZS5cbiAqIEludGVuZGVkIHVzYWdlOlxuICogMS4gY29uc3QgdmFsaWRhdG9yID0gbmV3IFRpbWVsaW5lVmFsaWRhdG9yKClcbiAqIDIuIHZhbGlkYXRvci52YWxpZGF0ZVRpbWVsaW5lKHRpbWVsaW5lKVxuICogb3I6XG4gKiAxLiBjb25zdCB2YWxpZGF0b3IgPSBuZXcgVGltZWxpbmVWYWxpZGF0b3IoKVxuICogMi4gdmFsaWRhdG9yLnZhbGlkYXRlT2JqZWN0KG9iailcbiAqIG9yOlxuICogMS4gY29uc3QgdmFsaWRhdG9yID0gbmV3IFRpbWVsaW5lVmFsaWRhdG9yKClcbiAqIDIuIHZhbGlkYXRvci52YWxpZGF0ZUtleWZyYW1lKG9iailcbiAqL1xuY2xhc3MgVGltZWxpbmVWYWxpZGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnVuaXF1ZUlkcyA9IHt9O1xuICAgIH1cbiAgICAvKiogVmFsaWRhdGVzIGFsbCBvYmplY3RzIGluIHRoZSB0aW1lbGluZS4gVGhyb3dzIGFuIGVycm9yIGlmIHNvbWV0aGluZydzIHdyb25nLiAqL1xuICAgIHZhbGlkYXRlVGltZWxpbmUoXG4gICAgLyoqIFRoZSB0aW1lbGluZSB0byB2YWxpZGF0ZSAqL1xuICAgIHRpbWVsaW5lLCBcbiAgICAvKiogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHNvbWUgb3B0aW9uYWwgc3RyaWN0IHJ1bGVzLiBTZXQgdGhpcyB0byB0cnVlIHRvIGluY3JlYXNlIGZ1dHVyZSBjb21wYXRpYmlsaXR5LiAqL1xuICAgIHN0cmljdCkge1xuICAgICAgICBjb25zdCB0b2MgPSAoMCwgcGVyZm9ybWFuY2VfMS50aWMpKCcgIHZhbGlkYXRlVGltZWxpbmUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgb2JqID0gdGltZWxpbmVbaV07XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlT2JqZWN0KG9iaiwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICB0b2MoKTtcbiAgICB9XG4gICAgLyoqIFZhbGlkYXRlcyBhIHNpbWdsZSBUaW1lbGluZS1vYmplY3QuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZy4gKi9cbiAgICB2YWxpZGF0ZU9iamVjdChcbiAgICAvKiogVGhlIG9iamVjdCB0byB2YWxpZGF0ZSAqL1xuICAgIG9iaiwgXG4gICAgLyoqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBzb21lIG9wdGlvbmFsIHN0cmljdCBydWxlcy4gU2V0IHRoaXMgdG8gdHJ1ZSB0byBpbmNyZWFzZSBmdXR1cmUgY29tcGF0aWJpbGl0eS4gKi9cbiAgICBzdHJpY3QpIHtcbiAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdCBpcyB1bmRlZmluZWRgKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgaXMgbm90IGFuIG9iamVjdGApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUlkKG9iaiwgc3RyaWN0KTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVMYXllcihvYmosIHN0cmljdCk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29udGVudChvYmopO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUVuYWJsZShvYmosIHN0cmljdCk7XG4gICAgICAgICAgICBpZiAob2JqLmtleWZyYW1lcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlmcmFtZSA9IG9iai5rZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlS2V5ZnJhbWUoa2V5ZnJhbWUsIHN0cmljdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWVbJHtpfV06ICR7ZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDbGFzc2VzKG9iaiwgc3RyaWN0KTtcbiAgICAgICAgICAgIGlmIChvYmouY2hpbGRyZW4gJiYgIW9iai5pc0dyb3VwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIFwiY2hpbGRyZW5cIiBpcyBzZXQgYnV0IFwiaXNHcm91cFwiIGlzIG5vdGApO1xuICAgICAgICAgICAgaWYgKG9iai5pc0dyb3VwICYmICFvYmouY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgXCJpc0dyb3VwXCIgaXMgc2V0IGJ1dCBcImNoaWxkcmVuXCIgbWlzc2luZ2ApO1xuICAgICAgICAgICAgaWYgKG9iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gb2JqLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZU9iamVjdChjaGlsZCwgc3RyaWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaGlsZFske2l9XTogJHtlfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai5wcmlvcml0eSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvYmoucHJpb3JpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXR0cmlidXRlIFwicHJpb3JpdHlcIiBpcyBub3QgYSBudW1iZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIyID0gbmV3IEVycm9yKGBPYmplY3QgXCIke29iai5pZH1cIjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICBlcnIyLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFZhbGlkYXRlcyBhIHNpbWdsZSBUaW1lbGluZS1vYmplY3QuIFRocm93cyBhbiBlcnJvciBpZiBzb21ldGhpbmcncyB3cm9uZy4gKi9cbiAgICB2YWxpZGF0ZUtleWZyYW1lKFxuICAgIC8qKiBUaGUgb2JqZWN0IHRvIHZhbGlkYXRlICovXG4gICAga2V5ZnJhbWUsIFxuICAgIC8qKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBvcHRpb25hbCBzdHJpY3QgcnVsZXMuIFNldCB0aGlzIHRvIHRydWUgdG8gaW5jcmVhc2UgZnV0dXJlIGNvbXBhdGliaWxpdHkgKi9cbiAgICBzdHJpY3QpIHtcbiAgICAgICAgaWYgKCFrZXlmcmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ZnJhbWUgaXMgdW5kZWZpbmVkYCk7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ZnJhbWUgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXlmcmFtZSBpcyBub3QgYW4gb2JqZWN0YCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlSWQoa2V5ZnJhbWUsIHN0cmljdCk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29udGVudChrZXlmcmFtZSk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlRW5hYmxlKGtleWZyYW1lLCBzdHJpY3QpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNsYXNzZXMoa2V5ZnJhbWUsIHN0cmljdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyMiA9IG5ldyBFcnJvcihgS2V5ZnJhbWUgXCIke2tleWZyYW1lLmlkfVwiOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIGVycjIuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUlkKG9iaiwgc3RyaWN0KSB7XG4gICAgICAgIGlmICghb2JqLmlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgbWlzc2luZyBcImlkXCIgYXR0cmlidXRlYCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLmlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0IFwiaWRcIiBhdHRyaWJ1dGUgaXMgbm90IGEgc3RyaW5nOiBcIiR7b2JqLmlkfVwiYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBUaW1lbGluZVZhbGlkYXRvci52YWxpZGF0ZVJlZmVyZW5jZVN0cmluZyhvYmouaWQsIHN0cmljdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3QgXCJpZFwiIGF0dHJpYnV0ZTogJHtlcnJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5pcXVlSWRzW29iai5pZF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGlkIFwiJHtvYmouaWR9XCIgaXMgbm90IHVuaXF1ZWApO1xuICAgICAgICB0aGlzLnVuaXF1ZUlkc1tvYmouaWRdID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFsaWRhdGVMYXllcihvYmosIHN0cmljdCkge1xuICAgICAgICBpZiAob2JqLmxheWVyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwibGF5ZXJcIiBhdHRyaWJ1dGUgaXMgdW5kZWZpbmVkLiAoSWYgYW4gb2JqZWN0IGlzIHRvIGhhdmUgbm8gbGF5ZXIsIHNldCB0aGlzIHRvIGFuIGVtcHR5IHN0cmluZy4pYCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBUaW1lbGluZVZhbGlkYXRvci52YWxpZGF0ZVJlZmVyZW5jZVN0cmluZyhgJHtvYmoubGF5ZXJ9YCwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwibGF5ZXJcIiBhdHRyaWJ1dGU6ICR7ZXJyfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlQ29udGVudChvYmopIHtcbiAgICAgICAgaWYgKCFvYmouY29udGVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJjb250ZW50XCIgYXR0cmlidXRlIG11c3QgYmUgc2V0YCk7XG4gICAgfVxuICAgIHZhbGlkYXRlRW5hYmxlKG9iaiwgc3RyaWN0KSB7XG4gICAgICAgIGlmICghb2JqLmVuYWJsZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJlbmFibGVcIiBhdHRyaWJ1dGUgbXVzdCBiZSBzZXRgKTtcbiAgICAgICAgY29uc3QgZW5hYmxlcyA9ICgwLCBsaWJfMS5lbnN1cmVBcnJheSkob2JqLmVuYWJsZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5hYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZW5hYmxlID0gZW5hYmxlc1tpXTtcbiAgICAgICAgICAgIGlmIChlbmFibGUuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZW5hYmxlLndoaWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJlbmFibGUuc3RhcnRcIiBhbmQgXCJlbmFibGUud2hpbGVcIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGVuYWJsZS5lbmQgIT09IHVuZGVmaW5lZCAmJiBlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcImVuYWJsZS5lbmRcIiBhbmQgXCJlbmFibGUuZHVyYXRpb25cIiBjYW5ub3QgYmUgY29tYmluZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuYWJsZS53aGlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZW5kICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJlbmFibGUud2hpbGVcIiBhbmQgXCJlbmFibGUuZW5kXCIgY2Fubm90IGJlIGNvbWJpbmVkYCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBlbmFibGUuZHVyYXRpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcImVuYWJsZS53aGlsZVwiIGFuZCBcImVuYWJsZS5kdXJhdGlvblwiIGNhbm5vdCBiZSBjb21iaW5lZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJlbmFibGUuc3RhcnRcIiBvciBcImVuYWJsZS53aGlsZVwiIG11c3QgYmUgc2V0YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVDbGFzc2VzKG9iaiwgc3RyaWN0KSB7XG4gICAgICAgIGlmIChvYmouY2xhc3Nlcykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmouY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9iai5jbGFzc2VzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJjbGFzc2VzWyR7aX1dXCIgaXMgbm90IGEgc3RyaW5nYCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgVGltZWxpbmVWYWxpZGF0b3IudmFsaWRhdGVSZWZlcmVuY2VTdHJpbmcoY2xhc3NOYW1lLCBzdHJpY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgIFwiY2xhc3Nlc1ske2l9XVwiOiAke2Vycn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGEgc3RyaW5nIHRoYXQgaXMgdXNlZCBpbiBUaW1lbGluZSBhcyBhIHJlZmVyZW5jZSAoYW4gaWQsIGEgY2xhc3Mgb3IgbGF5ZXIpXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIHZhbGlkYXRlXG4gICAgICogQHBhcmFtIHN0cmljdCBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgc29tZSBzdHJpY3QgcnVsZXMgKHJ1bGVzIHRoYXQgY2FuIHBvc3NpYmx5IGJlIGlnbm9yZWQpXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlUmVmZXJlbmNlU3RyaW5nKHN0ciwgc3RyaWN0KSB7XG4gICAgICAgIGlmICghc3RyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBtYXRjaGVzT3BlcmF0b3JzID0gRXhwcmVzc2lvbkhhbmRsZXJfMS5SRUdFWFBfT1BFUkFUT1JTLnRlc3Qoc3RyKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlc1Jlc2VydmVkID0gUkVTRVJWRURfQ0hBUkFDVEVSUy50ZXN0KHN0cik7XG4gICAgICAgIGNvbnN0IG1hdGNoZXNGdXR1cmVSZXNlcnZlZCA9IHN0cmljdCAmJiBGVVRVUkVfUkVTRVJWRURfQ0hBUkFDVEVSUy50ZXN0KHN0cik7XG4gICAgICAgIGlmIChtYXRjaGVzT3BlcmF0b3JzIHx8IG1hdGNoZXNSZXNlcnZlZCB8fCBtYXRjaGVzRnV0dXJlUmVzZXJ2ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoT3BlcmF0b3JzID0gc3RyLm1hdGNoKEV4cHJlc3Npb25IYW5kbGVyXzEuUkVHRVhQX09QRVJBVE9SUykgPz8gW107XG4gICAgICAgICAgICBjb25zdCBtYXRjaFJlc2VydmVkID0gc3RyLm1hdGNoKFJFU0VSVkVEX0NIQVJBQ1RFUlMpID8/IFtdO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hGdXR1cmVSZXNlcnZlZCA9IChzdHJpY3QgJiYgc3RyLm1hdGNoKEZVVFVSRV9SRVNFUlZFRF9DSEFSQUNURVJTKSkgfHwgW107XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdHJpbmcgXCIke3N0cn1cIiBjb250YWlucyBjaGFyYWN0ZXJzIHdoaWNoIGFyZW4ndCBhbGxvd2VkIGluIFRpbWVsaW5lOiAke1tcbiAgICAgICAgICAgICAgICBtYXRjaE9wZXJhdG9ycy5sZW5ndGggPiAwICYmIGAke21hdGNoT3BlcmF0b3JzLm1hcCgobykgPT4gYFwiJHtvfVwiYCkuam9pbignLCAnKX0gKGlzIGFuIG9wZXJhdG9yKWAsXG4gICAgICAgICAgICAgICAgbWF0Y2hSZXNlcnZlZC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgIGAke21hdGNoUmVzZXJ2ZWQubWFwKChvKSA9PiBgXCIke299XCJgKS5qb2luKCcsICcpfSAoaXMgYSByZXNlcnZlZCBjaGFyYWN0ZXIpYCxcbiAgICAgICAgICAgICAgICBtYXRjaEZ1dHVyZVJlc2VydmVkLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYCR7bWF0Y2hGdXR1cmVSZXNlcnZlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgobykgPT4gYFwiJHtvfVwiYClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSAoaXMgYSBzdHJpY3QgcmVzZXJ2ZWQgY2hhcmFjdGVyIGFuZCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmUpYCxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRpbWVsaW5lVmFsaWRhdG9yID0gVGltZWxpbmVWYWxpZGF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lbGluZVZhbGlkYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FjaGUgPSB2b2lkIDA7XG5jbGFzcyBDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoYXV0b0NsZWFudXAgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmF1dG9DbGVhbnVwID0gYXV0b0NsZWFudXA7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRpbWVUb0N1ZU5ld0NsZWFudXAgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NsZWFudXApXG4gICAgICAgICAgICB0aGlzLnRpbWVUb0N1ZU5ld0NsZWFudXAgPSB0cnVlO1xuICAgIH1cbiAgICAvKiogQ2FjaGUgdGhlIHJlc3VsdCBvZiBmdW5jdGlvbiBmb3IgYSBsaW1pdGVkIHRpbWUgKi9cbiAgICBjYWNoZVJlc3VsdChrZXksIGZjbiwgbGltaXRUaW1lKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFjYWNoZSB8fCBjYWNoZS50dGwgPCBEYXRlLm5vdygpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZjbigpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgdHRsOiBEYXRlLm5vdygpICsgbGltaXRUaW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZVRvQ3VlTmV3Q2xlYW51cCkge1xuICAgICAgICAgICAgICAgIHRoaXMudGltZVRvQ3VlTmV3Q2xlYW51cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZVRvQ3VlTmV3Q2xlYW51cCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgIH0sIGxpbWl0VGltZSArIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGUudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBjbGVhblVwKCkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmNhY2hlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLnR0bCA8IG5vdylcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLmNsZWFyVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xlYXJUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50aW1lVG9DdWVOZXdDbGVhbnVwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2FjaGUgPSBDYWNoZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDYXBzVG9SZXN1bWluZyA9IGV4cG9ydHMuam9pbkNhcHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBqb2luQ2FwcyguLi5jYXBzKSB7XG4gICAgY29uc3QgY2FwTWFwID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNhcHMyID0gY2Fwc1tpXTtcbiAgICAgICAgaWYgKGNhcHMyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNhcHMyLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FwMiA9IGNhcHMyW2pdO1xuICAgICAgICAgICAgICAgIGNhcE1hcFtjYXAyLmlkXSA9IGNhcDI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2FwTWFwKTtcbn1cbmV4cG9ydHMuam9pbkNhcHMgPSBqb2luQ2FwcztcbmZ1bmN0aW9uIGFkZENhcHNUb1Jlc3VtaW5nKGluc3RhbmNlLCAuLi5jYXBzKSB7XG4gICAgY29uc3QgY2Fwc1RvQWRkID0gW107XG4gICAgY29uc3Qgam9pbmVkQ2FwcyA9IGpvaW5DYXBzKC4uLmNhcHMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgam9pbmVkQ2Fwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjYXAgPSBqb2luZWRDYXBzW2ldO1xuICAgICAgICBpZiAoY2FwLmVuZCAhPT0gbnVsbCAmJiBpbnN0YW5jZS5lbmQgIT09IG51bGwgJiYgY2FwLmVuZCA+IGluc3RhbmNlLmVuZCkge1xuICAgICAgICAgICAgY2Fwc1RvQWRkLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBjYXAuaWQsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgZW5kOiBjYXAuZW5kLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zdGFuY2UuY2FwcyA9IGpvaW5DYXBzKGluc3RhbmNlLmNhcHMsIGNhcHNUb0FkZCk7XG59XG5leHBvcnRzLmFkZENhcHNUb1Jlc3VtaW5nID0gYWRkQ2Fwc1RvUmVzdW1pbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNvcnRFdmVudHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBzb3J0RXZlbnRzKGV2ZW50cywgYWRkaXRpb25hbFNvcnRGY25CZWZvcmUpIHtcbiAgICByZXR1cm4gZXZlbnRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEudGltZSA+IGIudGltZSlcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBpZiAoYS50aW1lIDwgYi50aW1lKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhZGRpdGlvbmFsU29ydEZjbkJlZm9yZSA/IGFkZGl0aW9uYWxTb3J0RmNuQmVmb3JlKGEsIGIpIDogMDtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGNvbnN0IGFJZCA9IGEuZGF0YSAmJiAoYS5kYXRhLmlkIHx8IGEuZGF0YS5pbnN0YW5jZT8uaWQpO1xuICAgICAgICBjb25zdCBiSWQgPSBiLmRhdGEgJiYgKGIuZGF0YS5pZCB8fCBiLmRhdGEuaW5zdGFuY2U/LmlkKTtcbiAgICAgICAgaWYgKGFJZCAmJiBiSWQgJiYgYUlkID09PSBiSWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBldmVudHMgcmVmZXIgdG8gdGhlIHNhbWUgaW5zdGFuY2UgaWQsIGxldCB0aGUgc3RhcnQgZXZlbnQgYmUgZmlyc3QsXG4gICAgICAgICAgICAvLyB0byBoYW5kbGUgemVyby1sZW5ndGggaW5zdGFuY2VzLlxuICAgICAgICAgICAgaWYgKGEudmFsdWUgJiYgIWIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgaWYgKCFhLnZhbHVlICYmIGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmRzIGV2ZW50cyBmaXJzdDpcbiAgICAgICAgICAgIGlmIChhLnZhbHVlICYmICFiLnZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgaWYgKCFhLnZhbHVlICYmIGIudmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xufVxuZXhwb3J0cy5zb3J0RXZlbnRzID0gc29ydEV2ZW50cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc051bWVyaWNFeHByID0gZXhwb3J0cy5pc0NvbnN0YW50RXhwciA9IHZvaWQgMDtcbi8qKiBSZXR1cm5zIHRydWUgaWYgYW4gZXhwcmVzc2lvbiBpcyBhIGNvbnN0YW50IChpZSBkb2Vzbid0IHJlZmVyZW5jZSBzb21ldGhpbmcgZWxzZSkgKi9cbmZ1bmN0aW9uIGlzQ29uc3RhbnRFeHByKHN0cikge1xuICAgIGlmIChpc051bWVyaWNFeHByKHN0cikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBsU3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsU3RyID09PSAndHJ1ZScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGxTdHIgPT09ICdmYWxzZScpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc0NvbnN0YW50RXhwciA9IGlzQ29uc3RhbnRFeHByO1xuZnVuY3Rpb24gaXNOdW1lcmljRXhwcihzdHIpIHtcbiAgICBpZiAoc3RyID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBzdHIgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiAhIS9eWy0rXT9bMC05Ll0rJC8uZXhlYyhzdHIpICYmICFpc05hTihwYXJzZUZsb2F0KHN0cikpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNOdW1lcmljRXhwciA9IGlzTnVtZXJpY0V4cHI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leHByZXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJbnN0YW5jZUhhc2ggPSBleHBvcnRzLmdldEluc3RhbmNlc0hhc2ggPSBleHBvcnRzLmJhc2VJbnN0YW5jZSA9IGV4cG9ydHMuYmFzZUluc3RhbmNlcyA9IGV4cG9ydHMuc3BsaWNlSW5zdGFuY2VzID0gZXhwb3J0cy5nZXRJbnN0YW5jZUludGVyc2VjdGlvbiA9IGV4cG9ydHMuaW5zdGFuY2VJc0FjdGl2ZSA9IGV4cG9ydHMuaXNJbnN0YW5jZUlkID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5mdW5jdGlvbiBpc0luc3RhbmNlSWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zdGFydHNXaXRoKCdAJyk7XG59XG5leHBvcnRzLmlzSW5zdGFuY2VJZCA9IGlzSW5zdGFuY2VJZDtcbmZ1bmN0aW9uIGluc3RhbmNlSXNBY3RpdmUoaW5zdGFuY2UsIHRpbWUpIHtcbiAgICByZXR1cm4gaW5zdGFuY2Uuc3RhcnQgPD0gdGltZSAmJiAoaW5zdGFuY2UuZW5kID8/IEluZmluaXR5KSA+IHRpbWU7XG59XG5leHBvcnRzLmluc3RhbmNlSXNBY3RpdmUgPSBpbnN0YW5jZUlzQWN0aXZlO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGluc3RhbmNlcy5cbiAqIEV4YW1wbGU6IGZvciAoMTAtMjApIGFuZCAoMTUtMzApLCB0aGUgaW50ZXJzZWN0aW9uIGlzICgxNS0yMCkuXG4gKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICBpZiAoYS5zdGFydCA8IChiLmVuZCA/PyBJbmZpbml0eSkgJiYgKGEuZW5kID8/IEluZmluaXR5KSA+IGIuc3RhcnQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4oYS5lbmQgPz8gSW5maW5pdHksIGIuZW5kID8/IEluZmluaXR5KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmQgPT09IEluZmluaXR5ID8gbnVsbCA6IGVuZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmdldEluc3RhbmNlSW50ZXJzZWN0aW9uID0gZ2V0SW5zdGFuY2VJbnRlcnNlY3Rpb247XG4vKipcbiAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNwbGljZSBhbiBhcnJheSBvZiBpbnN0YW5jZXNcbiAqIEBwYXJhbSBpbnN0YW5jZXMgVGhlIGFycmF5IG9mIGluc3RhbmNlcyB0byBzcGxpY2VcbiAqIEBwYXJhbSBmY24gT3BlcmF0b3IgZnVuY3Rpb24uXG4gKiAgIElzIGNhbGxlZCBmb3IgZWFjaCBpbnN0YW5jZSBpbiB0aGUgYXJyYXksXG4gKiAgIGFuZCBzaG91bGQgcmV0dXJuIGFuIGluc3RhbmNlIChvciBhbiBhcnJheSBvZiBpbnN0YW5jZXMpIHRvIGluc2VydCBpbiBwbGFjZSBvZiB0aGUgb3JpZ2luYWwgaW5zdGFuY2UsXG4gKiAgIG9yIHVuZGVmaW5lZCB0byByZW1vdmUgdGhlIGluc3RhbmNlLlxuICogICAoVG8gbGVhdmUgdGhlIGluc3RhbmNlIHVuY2hhbmdlZCwgcmV0dXJuIHRoZSBvcmlnaW5hbCBpbnN0YW5jZSlcbiAqL1xuZnVuY3Rpb24gc3BsaWNlSW5zdGFuY2VzKGluc3RhbmNlcywgZmNuKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmNuUmVzdWx0ID0gZmNuKGluc3RhbmNlc1tpXSk7XG4gICAgICAgIGNvbnN0IGluc2VydEluc3RhbmNlcyA9IGZjblJlc3VsdCA9PT0gdW5kZWZpbmVkID8gW10gOiAoMCwgbGliXzEuZW5zdXJlQXJyYXkpKGZjblJlc3VsdCk7XG4gICAgICAgIGlmIChpbnNlcnRJbnN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpbnN0YW5jZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluc2VydEluc3RhbmNlc1swXSA9PT0gaW5zdGFuY2VzW2ldKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gcmVwbGFjZTpcbiAgICAgICAgICAgIGluc3RhbmNlcy5zcGxpY2UoaSwgMSwgLi4uaW5zZXJ0SW5zdGFuY2VzKTtcbiAgICAgICAgICAgIGkgKz0gaW5zZXJ0SW5zdGFuY2VzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnNwbGljZUluc3RhbmNlcyA9IHNwbGljZUluc3RhbmNlcztcbmZ1bmN0aW9uIGJhc2VJbnN0YW5jZXMoaW5zdGFuY2VzKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlcy5tYXAoKGluc3RhbmNlKSA9PiBiYXNlSW5zdGFuY2UoaW5zdGFuY2UpKTtcbn1cbmV4cG9ydHMuYmFzZUluc3RhbmNlcyA9IGJhc2VJbnN0YW5jZXM7XG5mdW5jdGlvbiBiYXNlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogaW5zdGFuY2Uuc3RhcnQsXG4gICAgICAgIGVuZDogaW5zdGFuY2UuZW5kLFxuICAgIH07XG59XG5leHBvcnRzLmJhc2VJbnN0YW5jZSA9IGJhc2VJbnN0YW5jZTtcbi8qKiBSZXR1cm5zIGEgc3RyaW5nIGhhc2ggdGhhdCBjaGFuZ2VzIHdoZW5ldmVyIGFueSBpbnN0YW5jZSBoYXMgY2hhbmdlZCBpbiBhIHNpZ25pZmljYW50IHdheSAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VzSGFzaChpbnN0YW5jZXMpIHtcbiAgICBjb25zdCBzdHJzID0gW107XG4gICAgZm9yIChjb25zdCBpbnN0YW5jZSBvZiBpbnN0YW5jZXMpIHtcbiAgICAgICAgc3Rycy5wdXNoKGdldEluc3RhbmNlSGFzaChpbnN0YW5jZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3Rycy5qb2luKCcsJyk7XG59XG5leHBvcnRzLmdldEluc3RhbmNlc0hhc2ggPSBnZXRJbnN0YW5jZXNIYXNoO1xuLyoqIFJldHVybnMgYSBzdHJpbmcgaGFzaCB0aGF0IGNoYW5nZXMgd2hlbmV2ZXIgYW4gaW5zdGFuY2UgaGFzIGNoYW5nZWQgaW4gYSBzaWduaWZpY2FudCB3YXkgKi9cbmZ1bmN0aW9uIGdldEluc3RhbmNlSGFzaChpbnN0YW5jZSkge1xuICAgIGNvbnN0IG9yZ1N0YXJ0ID0gaW5zdGFuY2Uub3JpZ2luYWxTdGFydCA/PyBpbnN0YW5jZS5zdGFydDtcbiAgICBjb25zdCBvcmdFbmQgPSBpbnN0YW5jZS5vcmlnaW5hbEVuZCA/PyBpbnN0YW5jZS5lbmQ7XG4gICAgcmV0dXJuIGAke2luc3RhbmNlLnN0YXJ0fV8ke2luc3RhbmNlLmVuZCA/PyAnbnVsbCd9KCR7b3JnU3RhcnR9XyR7b3JnRW5kID8/ICdudWxsJ30pYDtcbn1cbmV4cG9ydHMuZ2V0SW5zdGFuY2VIYXNoID0gZ2V0SW5zdGFuY2VIYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5zdGFuY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBhcmVTdHJpbmdzID0gZXhwb3J0cy5tYXBUb09iamVjdCA9IGV4cG9ydHMuYXNzZXJ0TmV2ZXIgPSBleHBvcnRzLmlzQXJyYXkgPSBleHBvcnRzLmVuc3VyZUFycmF5ID0gZXhwb3J0cy5pc0VtcHR5ID0gZXhwb3J0cy5zb3J0QnkgPSBleHBvcnRzLm9taXQgPSBleHBvcnRzLnVuaXEgPSBleHBvcnRzLmNsb25lID0gZXhwb3J0cy5wdXNoVG9BcnJheSA9IGV4cG9ydHMucmVkdWNlT2JqID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMubGFzdCA9IGV4cG9ydHMuY29tcGFjdCA9IGV4cG9ydHMubGl0ZXJhbCA9IHZvaWQgMDtcbmZ1bmN0aW9uIGxpdGVyYWwobykge1xuICAgIHJldHVybiBvO1xufVxuZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbmZ1bmN0aW9uIGNvbXBhY3QoYXJyKSB7XG4gICAgY29uc3QgcmV0dXJuVmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdiA9IGFycltpXTtcbiAgICAgICAgaWYgKCEhdiB8fCAodiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IG51bGwgJiYgdiAhPT0gJycpKVxuICAgICAgICAgICAgcmV0dXJuVmFsdWVzLnB1c2godik7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG59XG5leHBvcnRzLmNvbXBhY3QgPSBjb21wYWN0O1xuZnVuY3Rpb24gbGFzdChhcnIpIHtcbiAgICByZXR1cm4gYXJyW2Fyci5sZW5ndGggLSAxXTtcbn1cbmV4cG9ydHMubGFzdCA9IGxhc3Q7XG4vKiogUmV0dXJucyB0cnVlIGlmIGFyZ3VtZW50IGlzIGFuIG9iamVjdCAob3IgYW4gYXJyYXksIGJ1dCBOT1QgbnVsbCkgKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KG8pIHtcbiAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5mdW5jdGlvbiByZWR1Y2VPYmoob2JqcywgZmNuLCBpbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqcykucmVkdWNlKChtZW1vLCBba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBmY24obWVtbywgdmFsdWUsIGtleSwgaW5kZXgpO1xuICAgIH0sIGluaXRpYWxWYWx1ZSk7XG59XG5leHBvcnRzLnJlZHVjZU9iaiA9IHJlZHVjZU9iajtcbi8qKlxuICogQ29uY2F0ZW5hdGUgdHdvIGFycmF5cyBvZiB2YWx1ZXMuXG4gKiBUaGlzIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgdHdvIGFycmF5cyBhcmUgb2YgdGhlIHNhbWUgdHlwZS5cbiAqIEBwYXJhbSBhcnIwIFRoZSBhcnJheSBvZiB2YWx1ZXMgdG8gcHVzaCBpbnRvXG4gKiBAcGFyYW0gYXJyMSBBbiBhcnJheSBvZiB2YWx1ZXMgdG8gcHVzaCBpbnRvIGFycjBcbiAqL1xuZnVuY3Rpb24gcHVzaFRvQXJyYXkoYXJyMCwgYXJyMSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIxKSB7XG4gICAgICAgIGFycjAucHVzaChpdGVtKTtcbiAgICB9XG59XG5leHBvcnRzLnB1c2hUb0FycmF5ID0gcHVzaFRvQXJyYXk7XG5mdW5jdGlvbiBjbG9uZShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbmV4cG9ydHMuY2xvbmUgPSBjbG9uZTtcbmZ1bmN0aW9uIHVuaXEoYXJyKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnIpKTtcbn1cbmV4cG9ydHMudW5pcSA9IHVuaXE7XG5mdW5jdGlvbiBvbWl0KG9iaiwgLi4ua2V5cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG9iaikpIHtcbiAgICAgICAgaWYgKGtleXMuc29tZSgoaykgPT4gKEFycmF5LmlzQXJyYXkoaykgPyBrLmluY2x1ZGVzKGtleSkgOiBrID09PSBrZXkpKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5vbWl0ID0gb21pdDtcbmZ1bmN0aW9uIHNvcnRCeShhcnIsIGZjbikge1xuICAgIGNvbnN0IHNvcnRBcnJheSA9IGFyci5tYXAoKGl0ZW0pID0+ICh7IGl0ZW0sIHZhbHVlOiBmY24oaXRlbSkgfSkpO1xuICAgIHNvcnRBcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLnZhbHVlIDwgYi52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGEudmFsdWUgPiBiLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHJldHVybiBzb3J0QXJyYXkubWFwKChpdGVtKSA9PiBpdGVtLml0ZW0pO1xufVxuZXhwb3J0cy5zb3J0QnkgPSBzb3J0Qnk7XG5mdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydHMuaXNFbXB0eSA9IGlzRW1wdHk7XG5mdW5jdGlvbiBlbnN1cmVBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cbmV4cG9ydHMuZW5zdXJlQXJyYXkgPSBlbnN1cmVBcnJheTtcbi8qKlxuICogU2xpZ2h0bHkgZmFzdGVyIHRoYW4gQXJyYXkuaXNBcnJheSgpLlxuICogTm90ZTogRW5zdXJlIHRoYXQgdGhlIHZhbHVlIHByb3ZpZGVkIGlzIG5vdCBudWxsIVxuICovXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICAgIC8vIEZhc3QtcGF0aCBvcHRpbWl6YXRpb246IGNoZWNraW5nIGZvciAubGVuZ3RoIGlzIGZhc3RlciB0aGFuIEFycmF5LmlzQXJyYXkoKVxuICAgIHJldHVybiBhcmcubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheShhcmcpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHNpbXBseSBhc3NlcnQgdGhhdCB0aGUgdmFsdWUgaXMgb2YgdGhlIHR5cGUgbmV2ZXIuXG4gKiBVc2FnZTogYXQgdGhlIGVuZCBvZiBpZi9lbHNlIG9yIHN3aXRjaCwgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gZmFsbHRocm91Z2guXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE5ldmVyKF92YWx1ZSkge1xuICAgIC8vIGRvZXMgbm90aGluZ1xufVxuZXhwb3J0cy5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuZnVuY3Rpb24gbWFwVG9PYmplY3QobWFwKSB7XG4gICAgY29uc3QgbyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvO1xufVxuZXhwb3J0cy5tYXBUb09iamVjdCA9IG1hcFRvT2JqZWN0O1xuZnVuY3Rpb24gY29tcGFyZVN0cmluZ3MoYSwgYikge1xuICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcbn1cbmV4cG9ydHMuY29tcGFyZVN0cmluZ3MgPSBjb21wYXJlU3RyaW5ncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpYi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGljVG9jUHJpbnQgPSBleHBvcnRzLnRpYyA9IGV4cG9ydHMuYWN0aXZhdGVQZXJmb3JtYW5jZURlYnVnZ2luZyA9IHZvaWQgMDtcbmNvbnN0IHBlcmZfaG9va3NfMSA9IHJlcXVpcmUoXCJwZXJmX2hvb2tzXCIpO1xubGV0IGR1cmF0aW9ucyA9IHt9O1xubGV0IGNhbGxDb3VudHMgPSB7fTtcbmxldCBmaXJzdFN0YXJ0VGltZSA9IDA7XG5sZXQgYWN0aXZlID0gZmFsc2U7XG5mdW5jdGlvbiBhY3RpdmF0ZVBlcmZvcm1hbmNlRGVidWdnaW5nKGFjdGl2YXRlKSB7XG4gICAgYWN0aXZlID0gYWN0aXZhdGU7XG59XG5leHBvcnRzLmFjdGl2YXRlUGVyZm9ybWFuY2VEZWJ1Z2dpbmcgPSBhY3RpdmF0ZVBlcmZvcm1hbmNlRGVidWdnaW5nO1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBub3RoaW5nXG59XG4vKipcbiAqIFVzZWQgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZS5cbiAqIFN0YXJ0cyBhIG1lYXN1cmVtZW50LCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIG1lYXN1cmVtZW50IGlzIGRvbmUuXG4gKi9cbmZ1bmN0aW9uIHRpYyhpZCkge1xuICAgIGlmICghYWN0aXZlKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBpZiAoIWZpcnN0U3RhcnRUaW1lKVxuICAgICAgICBmaXJzdFN0YXJ0VGltZSA9IHBlcmZfaG9va3NfMS5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoIWR1cmF0aW9uc1tpZF0pXG4gICAgICAgIGR1cmF0aW9uc1tpZF0gPSAwO1xuICAgIGlmICghY2FsbENvdW50c1tpZF0pXG4gICAgICAgIGNhbGxDb3VudHNbaWRdID0gMDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmX2hvb2tzXzEucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3QgZHVyYXRpb24gPSBwZXJmX2hvb2tzXzEucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICAgIGR1cmF0aW9uc1tpZF0gPSBkdXJhdGlvbnNbaWRdICsgZHVyYXRpb247XG4gICAgICAgIGNhbGxDb3VudHNbaWRdKys7XG4gICAgfTtcbn1cbmV4cG9ydHMudGljID0gdGljO1xuZnVuY3Rpb24gdGljVG9jUHJpbnQoKSB7XG4gICAgaWYgKCFhY3RpdmUpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gcGVyZl9ob29rc18xLnBlcmZvcm1hbmNlLm5vdygpIC0gZmlyc3RTdGFydFRpbWU7XG4gICAgY29uc3QgbWF4S2V5TGVuZ3RoID0gTWF0aC5tYXgoLi4uT2JqZWN0LmtleXMoZHVyYXRpb25zKS5tYXAoKGspID0+IGsubGVuZ3RoKSk7XG4gICAgY29uc29sZS5sb2coJ3RpY1RvY1ByaW50XFxuJyArXG4gICAgICAgIHBhZFN0cihgVG90YWwgZHVyYXRpb24gYCwgbWF4S2V5TGVuZ3RoICsgMikgK1xuICAgICAgICBgJHtNYXRoLmZsb29yKHRvdGFsRHVyYXRpb24pfVxcbmAgK1xuICAgICAgICBPYmplY3QuZW50cmllcyhkdXJhdGlvbnMpXG4gICAgICAgICAgICAubWFwKChkKSA9PiB7XG4gICAgICAgICAgICBsZXQgc3RyID0gcGFkU3RyKGAke2RbMF19IGAsIG1heEtleUxlbmd0aCArIDIpO1xuICAgICAgICAgICAgc3RyICs9IHBhZFN0cihgJHtNYXRoLmZsb29yKGRbMV0gKiAxMCkgLyAxMH1gLCA4KTtcbiAgICAgICAgICAgIHN0ciArPSBwYWRTdHIoYCR7TWF0aC5mbG9vcigoZFsxXSAvIHRvdGFsRHVyYXRpb24pICogMTAwMCkgLyAxMH0lYCwgNyk7XG4gICAgICAgICAgICBzdHIgKz0gYCR7Y2FsbENvdW50c1tkWzBdXX1gO1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKSk7XG4gICAgZHVyYXRpb25zID0ge307XG4gICAgY2FsbENvdW50cyA9IHt9O1xufVxuZXhwb3J0cy50aWNUb2NQcmludCA9IHRpY1RvY1ByaW50O1xuZnVuY3Rpb24gcGFkU3RyKHN0ciwgbGVuZ3RoKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpXG4gICAgICAgIHN0ciArPSAnICc7XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZvcm1hbmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1JlZmVyZW5jZSA9IGV4cG9ydHMuam9pblJlZmVyZW5jZXMgPSBleHBvcnRzLmdldFJlZkluc3RhbmNlSWQgPSBleHBvcnRzLmlzSW5zdGFuY2VSZWZlcmVuY2UgPSBleHBvcnRzLmdldFJlZkxheWVyID0gZXhwb3J0cy5pc0xheWVyUmVmZXJlbmNlID0gZXhwb3J0cy5nZXRSZWZDbGFzcyA9IGV4cG9ydHMuaXNDbGFzc1JlZmVyZW5jZSA9IGV4cG9ydHMuZ2V0UmVmT2JqZWN0SWQgPSBleHBvcnRzLmlzT2JqZWN0UmVmZXJlbmNlID0gdm9pZCAwO1xuY29uc3QgbGliXzEgPSByZXF1aXJlKFwiLi9saWJcIik7XG5jb25zdCBwZXJmb3JtYW5jZV8xID0gcmVxdWlyZShcIi4vcGVyZm9ybWFuY2VcIik7XG4vKlxuICogUmVmZXJlbmNlcyBhcmUgc3RyaW5ncyB0aGF0IGFyZSBhZGRlZCB0byBpbnN0YW5jZXMsXG4gKiB0byBpbmRpY2F0ZSB3aGF0IG9iamVjdHMsIGxheWVycyBvciBjbGFzc2VzIHRoZXkgYXJlIGRlcml2ZWQgZnJvbS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RSZWZlcmVuY2UocmVmKSB7XG4gICAgcmV0dXJuIHJlZi5zdGFydHNXaXRoKCcjJyk7XG59XG5leHBvcnRzLmlzT2JqZWN0UmVmZXJlbmNlID0gaXNPYmplY3RSZWZlcmVuY2U7XG5mdW5jdGlvbiBnZXRSZWZPYmplY3RJZChyZWYpIHtcbiAgICByZXR1cm4gcmVmLnNsaWNlKDEpO1xufVxuZXhwb3J0cy5nZXRSZWZPYmplY3RJZCA9IGdldFJlZk9iamVjdElkO1xuZnVuY3Rpb24gaXNDbGFzc1JlZmVyZW5jZShyZWYpIHtcbiAgICByZXR1cm4gcmVmLnN0YXJ0c1dpdGgoJy4nKTtcbn1cbmV4cG9ydHMuaXNDbGFzc1JlZmVyZW5jZSA9IGlzQ2xhc3NSZWZlcmVuY2U7XG5mdW5jdGlvbiBnZXRSZWZDbGFzcyhyZWYpIHtcbiAgICByZXR1cm4gcmVmLnNsaWNlKDEpO1xufVxuZXhwb3J0cy5nZXRSZWZDbGFzcyA9IGdldFJlZkNsYXNzO1xuZnVuY3Rpb24gaXNMYXllclJlZmVyZW5jZShyZWYpIHtcbiAgICByZXR1cm4gcmVmLnN0YXJ0c1dpdGgoJyQnKTtcbn1cbmV4cG9ydHMuaXNMYXllclJlZmVyZW5jZSA9IGlzTGF5ZXJSZWZlcmVuY2U7XG5mdW5jdGlvbiBnZXRSZWZMYXllcihyZWYpIHtcbiAgICByZXR1cm4gcmVmLnNsaWNlKDEpO1xufVxuZXhwb3J0cy5nZXRSZWZMYXllciA9IGdldFJlZkxheWVyO1xuZnVuY3Rpb24gaXNJbnN0YW5jZVJlZmVyZW5jZShyZWYpIHtcbiAgICByZXR1cm4gcmVmLnN0YXJ0c1dpdGgoJ0AnKTtcbn1cbmV4cG9ydHMuaXNJbnN0YW5jZVJlZmVyZW5jZSA9IGlzSW5zdGFuY2VSZWZlcmVuY2U7XG5mdW5jdGlvbiBnZXRSZWZJbnN0YW5jZUlkKHJlZikge1xuICAgIHJldHVybiByZWYuc2xpY2UoMSk7XG59XG5leHBvcnRzLmdldFJlZkluc3RhbmNlSWQgPSBnZXRSZWZJbnN0YW5jZUlkO1xuLyoqIEFkZCAvIGpvaW4gcmVmZXJlbmNlcyBBcnJheXMuIFJldHVybnMgYSBzb3J0ZWQgbGlzdCBvZiB1bmlxdWUgcmVmZXJlbmNlcyAqL1xuZnVuY3Rpb24gam9pblJlZmVyZW5jZXMocmVmZXJlbmNlcywgLi4uYWRkUmVmZXJlbmNlcykge1xuICAgIGNvbnN0IHRvYyA9ICgwLCBwZXJmb3JtYW5jZV8xLnRpYykoJyAgICAgam9pblJlZmVyZW5jZXMnKTtcbiAgICAvLyBGYXN0IHBhdGg6IFdoZW4gbm90aGluZyBpcyBhZGRlZCwgcmV0dXJuIHRoZSBvcmlnaW5hbCByZWZlcmVuY2VzOlxuICAgIGlmIChhZGRSZWZlcmVuY2VzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYWRkUmVmZXJlbmNlc1swXSAhPT0gJ3N0cmluZycgJiYgYWRkUmVmZXJlbmNlc1swXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFsuLi5yZWZlcmVuY2VzXTtcbiAgICB9XG4gICAgbGV0IGZhc3RQYXRoID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdGluZ1JlZnMgPSBbXTtcbiAgICAvLyBGYXN0IHBhdGg6IFdoZW4gYSBzaW5nbGUgcmVmIGlzIGFkZGVkXG4gICAgaWYgKGFkZFJlZmVyZW5jZXMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhZGRSZWZlcmVuY2VzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocmVmZXJlbmNlcy5pbmNsdWRlcyhhZGRSZWZlcmVuY2VzWzBdKSkge1xuICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGFscmVhZHkgZXhpc3RzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHJlZmVyZW5jZXM6XG4gICAgICAgICAgICByZXR1cm4gWy4uLnJlZmVyZW5jZXNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8ganVzdCBxdWlja2x5IGFkZCB0aGUgcmVmZXJlbmNlIGFuZCBqdW1wIGZvcndhcmQgdG8gc29ydGluZyBvZiByZXN1bHRpbmdSZWZzOlxuICAgICAgICAgICAgcmVzdWx0aW5nUmVmcyA9IFsuLi5yZWZlcmVuY2VzXTtcbiAgICAgICAgICAgIHJlc3VsdGluZ1JlZnMucHVzaChhZGRSZWZlcmVuY2VzWzBdKTtcbiAgICAgICAgICAgIGZhc3RQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZhc3RQYXRoKSB7XG4gICAgICAgIGNvbnN0IHJlZlNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKCFyZWZTZXQuaGFzKHJlZikpIHtcbiAgICAgICAgICAgICAgICByZWZTZXQuYWRkKHJlZik7XG4gICAgICAgICAgICAgICAgcmVzdWx0aW5nUmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBhZGRSZWZlcmVuY2Ugb2YgYWRkUmVmZXJlbmNlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhZGRSZWZlcmVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZTZXQuaGFzKGFkZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmU2V0LmFkZChhZGRSZWZlcmVuY2UpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRpbmdSZWZzLnB1c2goYWRkUmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBhZGRSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWZTZXQuaGFzKHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZlNldC5hZGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdGluZ1JlZnMucHVzaChyZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdGluZ1JlZnMuc29ydChsaWJfMS5jb21wYXJlU3RyaW5ncyk7XG4gICAgdG9jKCk7XG4gICAgcmV0dXJuIHJlc3VsdGluZ1JlZnM7XG59XG5leHBvcnRzLmpvaW5SZWZlcmVuY2VzID0gam9pblJlZmVyZW5jZXM7XG5mdW5jdGlvbiBpc1JlZmVyZW5jZShyZWYpIHtcbiAgICByZXR1cm4gcmVmICE9PSBudWxsICYmIHR5cGVvZiByZWYudmFsdWUgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc1JlZmVyZW5jZSA9IGlzUmVmZXJlbmNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmZXJlbmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vYmpIYXNMYXllciA9IHZvaWQgMDtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBoYXMgYSBsYXllci5cbiAqIE5vdGU6IE9iamVjdHMgd2l0aG91dCBhIGxheWVyIGFyZSBjYWxsZWQgXCJ0cmFuc3BhcmVudCBvYmplY3RzXCIsXG4gKiBhbmQgd29uJ3QgYmUgcHJlc2VudCBpbiB0aGUgcmVzb2x2ZWQgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIG9iakhhc0xheWVyKG9iaikge1xuICAgIHJldHVybiBvYmoubGF5ZXIgIT09IHVuZGVmaW5lZCAmJiBvYmoubGF5ZXIgIT09ICcnICYmIG9iai5sYXllciAhPT0gbnVsbDtcbn1cbmV4cG9ydHMub2JqSGFzTGF5ZXIgPSBvYmpIYXNMYXllcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVsaW5lLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgZ2xvYmFsLCBkZWZpbmUsIFN5bWJvbCwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19lc0RlY29yYXRlO1xyXG52YXIgX19ydW5Jbml0aWFsaXplcnM7XHJcbnZhciBfX3Byb3BLZXk7XHJcbnZhciBfX3NldEZ1bmN0aW9uTmFtZTtcclxudmFyIF9fbWV0YWRhdGE7XHJcbnZhciBfX2F3YWl0ZXI7XHJcbnZhciBfX2dlbmVyYXRvcjtcclxudmFyIF9fZXhwb3J0U3RhcjtcclxudmFyIF9fdmFsdWVzO1xyXG52YXIgX19yZWFkO1xyXG52YXIgX19zcHJlYWQ7XHJcbnZhciBfX3NwcmVhZEFycmF5cztcclxudmFyIF9fc3ByZWFkQXJyYXk7XHJcbnZhciBfX2F3YWl0O1xyXG52YXIgX19hc3luY0dlbmVyYXRvcjtcclxudmFyIF9fYXN5bmNEZWxlZ2F0b3I7XHJcbnZhciBfX2FzeW5jVmFsdWVzO1xyXG52YXIgX19tYWtlVGVtcGxhdGVPYmplY3Q7XHJcbnZhciBfX2ltcG9ydFN0YXI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQ7XHJcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRJbjtcclxudmFyIF9fY3JlYXRlQmluZGluZztcclxudmFyIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlO1xyXG52YXIgX19kaXNwb3NlUmVzb3VyY2VzO1xyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuICAgIHZhciByb290ID0gdHlwZW9mIGdsb2JhbCA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiID8gc2VsZiA6IHR5cGVvZiB0aGlzID09PSBcIm9iamVjdFwiID8gdGhpcyA6IHt9O1xyXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAgICAgZGVmaW5lKFwidHNsaWJcIiwgW1wiZXhwb3J0c1wiXSwgZnVuY3Rpb24gKGV4cG9ydHMpIHsgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihleHBvcnRzKSkpOyB9KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290LCBjcmVhdGVFeHBvcnRlcihtb2R1bGUuZXhwb3J0cykpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cywgcHJldmlvdXMpIHtcclxuICAgICAgICBpZiAoZXhwb3J0cyAhPT0gcm9vdCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGlkLCB2KSB7IHJldHVybiBleHBvcnRzW2lkXSA9IHByZXZpb3VzID8gcHJldmlvdXMoaWQsIHYpIDogdjsgfTtcclxuICAgIH1cclxufSlcclxuKGZ1bmN0aW9uIChleHBvcnRlcikge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3Jlc3QgPSBmdW5jdGlvbiAocywgZSkge1xyXG4gICAgICAgIHZhciB0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2VzRGVjb3JhdGUgPSBmdW5jdGlvbiAoY3RvciwgZGVzY3JpcHRvckluLCBkZWNvcmF0b3JzLCBjb250ZXh0SW4sIGluaXRpYWxpemVycywgZXh0cmFJbml0aWFsaXplcnMpIHtcclxuICAgICAgICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cclxuICAgICAgICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSAhZGVzY3JpcHRvckluICYmIGN0b3IgPyBjb250ZXh0SW5bXCJzdGF0aWNcIl0gPyBjdG9yIDogY3Rvci5wcm90b3R5cGUgOiBudWxsO1xyXG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xyXG4gICAgICAgIHZhciBfLCBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSB7fTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluLmFjY2VzcykgY29udGV4dC5hY2Nlc3NbcF0gPSBjb250ZXh0SW4uYWNjZXNzW3BdO1xyXG4gICAgICAgICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwiYWNjZXNzb3JcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5nZXQpKSBkZXNjcmlwdG9yLmdldCA9IF87XHJcbiAgICAgICAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xyXG4gICAgICAgICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBkZXNjcmlwdG9yW2tleV0gPSBfO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGNvbnRleHRJbi5uYW1lLCBkZXNjcmlwdG9yKTtcclxuICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgX19ydW5Jbml0aWFsaXplcnMgPSBmdW5jdGlvbiAodGhpc0FyZywgaW5pdGlhbGl6ZXJzLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gdXNlVmFsdWUgPyBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnLCB2YWx1ZSkgOiBpbml0aWFsaXplcnNbaV0uY2FsbCh0aGlzQXJnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcHJvcEtleSA9IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NldEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uIChmLCBuYW1lLCBwcmVmaXgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmLCBcIm5hbWVcIiwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBwcmVmaXggPyBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiLCBuYW1lKSA6IG5hbWUgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uKG0sIG8pIHtcclxuICAgICAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgICAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG4gICAgfSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgICAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgICAgIG9bazJdID0gbVtrXTtcclxuICAgIH0pO1xyXG5cclxuICAgIF9fdmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3JlYWQgPSBmdW5jdGlvbiAobywgbikge1xyXG4gICAgICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgICAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xyXG4gICAgX19zcHJlYWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZEFycmF5ID0gZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICAgICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IGZhbHNlIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNWYWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgICAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19tYWtlVGVtcGxhdGVPYmplY3QgPSBmdW5jdGlvbiAoY29va2VkLCByYXcpIHtcclxuICAgICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgICAgIHJldHVybiBjb29rZWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbiAgICB9KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgICAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbiAgICB9O1xyXG5cclxuICAgIF9faW1wb3J0U3RhciA9IGZ1bmN0aW9uIChtb2QpIHtcclxuICAgICAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgICAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgICAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgICAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEluID0gZnVuY3Rpb24gKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYWRkRGlzcG9zYWJsZVJlc291cmNlID0gZnVuY3Rpb24gKGVudiwgdmFsdWUsIGFzeW5jKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZC5cIik7XHJcbiAgICAgICAgICAgIHZhciBkaXNwb3NlO1xyXG4gICAgICAgICAgICBpZiAoYXN5bmMpIHtcclxuICAgICAgICAgICAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgICAgICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXNwb3NlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgICAgIGlmICghU3ltYm9sLmRpc3Bvc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuZGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICAgICAgICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGlzcG9zZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IG5vdCBkaXNwb3NhYmxlLlwiKTtcclxuICAgICAgICAgICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXN5bmMpIHtcclxuICAgICAgICAgICAgZW52LnN0YWNrLnB1c2goeyBhc3luYzogdHJ1ZSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGlzcG9zZVJlc291cmNlcyA9IGZ1bmN0aW9uIChlbnYpIHtcclxuICAgICAgICBmdW5jdGlvbiBmYWlsKGUpIHtcclxuICAgICAgICAgICAgZW52LmVycm9yID0gZW52Lmhhc0Vycm9yID8gbmV3IF9TdXBwcmVzc2VkRXJyb3IoZSwgZW52LmVycm9yLCBcIkFuIGVycm9yIHdhcyBzdXBwcmVzc2VkIGR1cmluZyBkaXNwb3NhbC5cIikgOiBlO1xyXG4gICAgICAgICAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBuZXh0KCkge1xyXG4gICAgICAgICAgICB3aGlsZSAoZW52LnN0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYyA9IGVudi5zdGFjay5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlYy5kaXNwb3NlICYmIHJlYy5kaXNwb3NlLmNhbGwocmVjLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHQoKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0ZXIoXCJfX2V4dGVuZHNcIiwgX19leHRlbmRzKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3NpZ25cIiwgX19hc3NpZ24pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3Jlc3RcIiwgX19yZXN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19kZWNvcmF0ZVwiLCBfX2RlY29yYXRlKTtcclxuICAgIGV4cG9ydGVyKFwiX19wYXJhbVwiLCBfX3BhcmFtKTtcclxuICAgIGV4cG9ydGVyKFwiX19lc0RlY29yYXRlXCIsIF9fZXNEZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcnVuSW5pdGlhbGl6ZXJzXCIsIF9fcnVuSW5pdGlhbGl6ZXJzKTtcclxuICAgIGV4cG9ydGVyKFwiX19wcm9wS2V5XCIsIF9fcHJvcEtleSk7XHJcbiAgICBleHBvcnRlcihcIl9fc2V0RnVuY3Rpb25OYW1lXCIsIF9fc2V0RnVuY3Rpb25OYW1lKTtcclxuICAgIGV4cG9ydGVyKFwiX19tZXRhZGF0YVwiLCBfX21ldGFkYXRhKTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdGVyXCIsIF9fYXdhaXRlcik7XHJcbiAgICBleHBvcnRlcihcIl9fZ2VuZXJhdG9yXCIsIF9fZ2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19leHBvcnRTdGFyXCIsIF9fZXhwb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9fY3JlYXRlQmluZGluZ1wiLCBfX2NyZWF0ZUJpbmRpbmcpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3ZhbHVlc1wiLCBfX3ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fcmVhZFwiLCBfX3JlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZFwiLCBfX3NwcmVhZCk7XHJcbiAgICBleHBvcnRlcihcIl9fc3ByZWFkQXJyYXlzXCIsIF9fc3ByZWFkQXJyYXlzKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRBcnJheVwiLCBfX3NwcmVhZEFycmF5KTtcclxuICAgIGV4cG9ydGVyKFwiX19hd2FpdFwiLCBfX2F3YWl0KTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0dlbmVyYXRvclwiLCBfX2FzeW5jR2VuZXJhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY0RlbGVnYXRvclwiLCBfX2FzeW5jRGVsZWdhdG9yKTtcclxuICAgIGV4cG9ydGVyKFwiX19hc3luY1ZhbHVlc1wiLCBfX2FzeW5jVmFsdWVzKTtcclxuICAgIGV4cG9ydGVyKFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgX19tYWtlVGVtcGxhdGVPYmplY3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2ltcG9ydFN0YXJcIiwgX19pbXBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnREZWZhdWx0XCIsIF9faW1wb3J0RGVmYXVsdCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRTZXRcIiwgX19jbGFzc1ByaXZhdGVGaWVsZFNldCk7XHJcbiAgICBleHBvcnRlcihcIl9fY2xhc3NQcml2YXRlRmllbGRJblwiLCBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FkZERpc3Bvc2FibGVSZXNvdXJjZVwiLCBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSk7XHJcbiAgICBleHBvcnRlcihcIl9fZGlzcG9zZVJlc291cmNlc1wiLCBfX2Rpc3Bvc2VSZXNvdXJjZXMpO1xyXG59KTtcclxuIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fc3ByZWFkQXJyYXlzO1xyXG52YXIgX19hd2FpdDtcclxudmFyIF9fYXN5bmNHZW5lcmF0b3I7XHJcbnZhciBfX2FzeW5jRGVsZWdhdG9yO1xyXG52YXIgX19hc3luY1ZhbHVlcztcclxudmFyIF9fbWFrZVRlbXBsYXRlT2JqZWN0O1xyXG52YXIgX19pbXBvcnRTdGFyO1xyXG52YXIgX19pbXBvcnREZWZhdWx0O1xyXG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldDtcclxudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQ7XHJcbnZhciBfX2NyZWF0ZUJpbmRpbmc7XHJcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xyXG4gICAgdmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsID09PSBcIm9iamVjdFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgPT09IFwib2JqZWN0XCIgPyBzZWxmIDogdHlwZW9mIHRoaXMgPT09IFwib2JqZWN0XCIgPyB0aGlzIDoge307XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoXCJ0c2xpYlwiLCBbXCJleHBvcnRzXCJdLCBmdW5jdGlvbiAoZXhwb3J0cykgeyBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMpKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QsIGNyZWF0ZUV4cG9ydGVyKG1vZHVsZS5leHBvcnRzKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZmFjdG9yeShjcmVhdGVFeHBvcnRlcihyb290KSk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFeHBvcnRlcihleHBvcnRzLCBwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChleHBvcnRzICE9PSByb290KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoaWQsIHYpIHsgcmV0dXJuIGV4cG9ydHNbaWRdID0gcHJldmlvdXMgPyBwcmV2aW91cyhpZCwgdikgOiB2OyB9O1xyXG4gICAgfVxyXG59KVxyXG4oZnVuY3Rpb24gKGV4cG9ydGVyKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbiAgICBfX2V4dGVuZHMgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVzdCA9IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICAgICAgdmFyIHQgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19kZWNvcmF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgICAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcGFyYW0gPSBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWV0YWRhdGEgPSBmdW5jdGlvbiAobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2F3YWl0ZXIgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgX19nZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xyXG4gICAgICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICAgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICAgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2NyZWF0ZUJpbmRpbmcgPSBmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICAgICAgb1trMl0gPSBtW2tdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2V4cG9ydFN0YXIgPSBmdW5jdGlvbiAobSwgZXhwb3J0cykge1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcclxuICAgIH07XHJcblxyXG4gICAgX192YWx1ZXMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICAgICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICAgICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fcmVhZCA9IGZ1bmN0aW9uIChvLCBuKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICAgICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgICAgICByZXR1cm4gYXI7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fc3ByZWFkQXJyYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxuICAgIH07XHJcblxyXG4gICAgX19hc3luY1ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ha2VUZW1wbGF0ZU9iamVjdCA9IGZ1bmN0aW9uIChjb29rZWQsIHJhdykge1xyXG4gICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICAgICAgcmV0dXJuIGNvb2tlZDtcclxuICAgIH07XHJcblxyXG4gICAgX19pbXBvcnRTdGFyID0gZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICAgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuXHJcbiAgICBfX2ltcG9ydERlZmF1bHQgPSBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbiAgICB9O1xyXG5cclxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcclxuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcclxuICAgIH07XHJcblxyXG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydGVyKFwiX19leHRlbmRzXCIsIF9fZXh0ZW5kcyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXNzaWduXCIsIF9fYXNzaWduKTtcclxuICAgIGV4cG9ydGVyKFwiX19yZXN0XCIsIF9fcmVzdCk7XHJcbiAgICBleHBvcnRlcihcIl9fZGVjb3JhdGVcIiwgX19kZWNvcmF0ZSk7XHJcbiAgICBleHBvcnRlcihcIl9fcGFyYW1cIiwgX19wYXJhbSk7XHJcbiAgICBleHBvcnRlcihcIl9fbWV0YWRhdGFcIiwgX19tZXRhZGF0YSk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRlclwiLCBfX2F3YWl0ZXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2dlbmVyYXRvclwiLCBfX2dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fZXhwb3J0U3RhclwiLCBfX2V4cG9ydFN0YXIpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NyZWF0ZUJpbmRpbmdcIiwgX19jcmVhdGVCaW5kaW5nKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3NwcmVhZEFycmF5c1wiLCBfX3NwcmVhZEFycmF5cyk7XHJcbiAgICBleHBvcnRlcihcIl9fYXdhaXRcIiwgX19hd2FpdCk7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNHZW5lcmF0b3JcIiwgX19hc3luY0dlbmVyYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgX19hc3luY0RlbGVnYXRvcik7XHJcbiAgICBleHBvcnRlcihcIl9fYXN5bmNWYWx1ZXNcIiwgX19hc3luY1ZhbHVlcyk7XHJcbiAgICBleHBvcnRlcihcIl9fbWFrZVRlbXBsYXRlT2JqZWN0XCIsIF9fbWFrZVRlbXBsYXRlT2JqZWN0KTtcclxuICAgIGV4cG9ydGVyKFwiX19pbXBvcnRTdGFyXCIsIF9faW1wb3J0U3Rhcik7XHJcbiAgICBleHBvcnRlcihcIl9faW1wb3J0RGVmYXVsdFwiLCBfX2ltcG9ydERlZmF1bHQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIF9fY2xhc3NQcml2YXRlRmllbGRTZXQpO1xyXG59KTtcclxuIl19"}